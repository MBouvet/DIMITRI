<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:47 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>mpcurvefit.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="mpcurvefit.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   MPCURVEFIT</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;   UPDATED VERSIONs can be found on my WEB PAGE: </span>
<span class="comments">;      http://cow.physics.wisc.edu/~craigm/idl/idl.html</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Perform Levenberg-Marquardt least-squares fit (replaces CURVEFIT)</span>
<span class="comments">;</span>
<span class="comments">; MAJOR TOPICS:</span>
<span class="comments">;   Curve and Surface Fitting</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   YFIT = MPCURVEFIT(X, Y, WEIGHTS, P, [SIGMA,] FUNCTION_NAME=FUNC, </span>
<span class="comments">;                     ITER=iter, ITMAX=itmax, </span>
<span class="comments">;                     CHISQ=chisq, NFREE=nfree, DOF=dof, </span>
<span class="comments">;                     NFEV=nfev, COVAR=covar, [/NOCOVAR, ] [/NODERIVATIVE, ]</span>
<span class="comments">;                     FUNCTARGS=functargs, PARINFO=parinfo,</span>
<span class="comments">;                     FTOL=ftol, XTOL=xtol, GTOL=gtol, TOL=tol,</span>
<span class="comments">;                     ITERPROC=iterproc, ITERARGS=iterargs,</span>
<span class="comments">;                     NPRINT=nprint, QUIET=quiet, </span>
<span class="comments">;                     ERRMSG=errmsg, STATUS=status)</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION:</span>
<span class="comments">;</span>
<span class="comments">;  MPCURVEFIT fits a user-supplied model -- in the form of an IDL</span>
<span class="comments">;  function -- to a set of user-supplied data.  MPCURVEFIT calls</span>
<span class="comments">;  MPFIT, the MINPACK-1 least-squares minimizer, to do the main</span>
<span class="comments">;  work.</span>
<span class="comments">;</span>
<span class="comments">;  Given the data and their uncertainties, MPCURVEFIT finds the best</span>
<span class="comments">;  set of model parameters which match the data (in a least-squares</span>
<span class="comments">;  sense) and returns them in the parameter P.  </span>
<span class="comments">;</span>
<span class="comments">;  MPCURVEFIT returns the best fit function.</span>
<span class="comments">;  </span>
<span class="comments">;  The user must supply the following items:</span>
<span class="comments">;   - An array of independent variable values ("X").</span>
<span class="comments">;   - An array of "measured" *dependent* variable values ("Y").</span>
<span class="comments">;   - An array of weighting values ("WEIGHTS").</span>
<span class="comments">;   - The name of an IDL function which computes Y given X ("FUNC").</span>
<span class="comments">;   - Starting guesses for all of the parameters ("P").</span>
<span class="comments">;</span>
<span class="comments">;  There are very few restrictions placed on X, Y or FUNCT.  Simply</span>
<span class="comments">;  put, FUNCT must map the "X" values into "Y" values given the</span>
<span class="comments">;  model parameters.  The "X" values may represent any independent</span>
<span class="comments">;  variable (not just Cartesian X), and indeed may be multidimensional</span>
<span class="comments">;  themselves.  For example, in the application of image fitting, X</span>
<span class="comments">;  may be a 2xN array of image positions.</span>
<span class="comments">;</span>
<span class="comments">;  MPCURVEFIT carefully avoids passing large arrays where possible to</span>
<span class="comments">;  improve performance.</span>
<span class="comments">;</span>
<span class="comments">;  See below for an example of usage.</span>
<span class="comments">;   </span>
<span class="comments">; USER FUNCTION</span>
<span class="comments">;</span>
<span class="comments">;  The user must define a function which returns the model value.  For</span>
<span class="comments">;  applications which use finite-difference derivatives -- the default</span>
<span class="comments">;  -- the user function should be declared in the following way:</span>
<span class="comments">;</span>
<span class="comments">;    PRO MYFUNCT, X, P, YMOD</span>
<span class="comments">;     ; The independent variable is X</span>
<span class="comments">;     ; Parameter values are passed in "P"</span>
<span class="comments">;     YMOD = ... computed model values at X ...</span>
<span class="comments">;    END</span>
<span class="comments">;</span>
<span class="comments">;  The returned array YMOD must have the same dimensions and type as</span>
<span class="comments">;  the "measured" Y values.</span>
<span class="comments">;</span>
<span class="comments">;  User functions may also indicate a fatal error condition</span>
<span class="comments">;  using the ERROR_CODE common block variable, as described</span>
<span class="comments">;  below under the MPFIT_ERROR common block definition.</span>
<span class="comments">;</span>
<span class="comments">;  See the discussion under "ANALYTIC DERIVATIVES" and AUTODERIVATIVE</span>
<span class="comments">;  in MPFIT.PRO if you wish to compute the derivatives for yourself.</span>
<span class="comments">;  AUTODERIVATIVE is accepted and passed directly to MPFIT.  The user</span>
<span class="comments">;  function must accept one additional parameter, DP, which contains</span>
<span class="comments">;  the derivative of the user function with respect to each parameter</span>
<span class="comments">;  at each data point, as described in MPFIT.PRO.</span>
<span class="comments">;</span>
<span class="comments">; CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD</span>
<span class="comments">;</span>
<span class="comments">;  The behavior of MPFIT can be modified with respect to each</span>
<span class="comments">;  parameter to be fitted.  A parameter value can be fixed; simple</span>
<span class="comments">;  boundary constraints can be imposed; limitations on the parameter</span>
<span class="comments">;  changes can be imposed; properties of the automatic derivative can</span>
<span class="comments">;  be modified; and parameters can be tied to one another.</span>
<span class="comments">;</span>
<span class="comments">;  These properties are governed by the PARINFO structure, which is</span>
<span class="comments">;  passed as a keyword parameter to MPFIT.</span>
<span class="comments">;</span>
<span class="comments">;  PARINFO should be an array of structures, one for each parameter.</span>
<span class="comments">;  Each parameter is associated with one element of the array, in</span>
<span class="comments">;  numerical order.  The structure can have the following entries</span>
<span class="comments">;  (none are required):</span>
<span class="comments">;  </span>
<span class="comments">;     .VALUE - the starting parameter value (but see the START_PARAMS</span>
<span class="comments">;              parameter for more information).</span>
<span class="comments">;  </span>
<span class="comments">;     .FIXED - a boolean value, whether the parameter is to be held</span>
<span class="comments">;              fixed or not.  Fixed parameters are not varied by</span>
<span class="comments">;              MPFIT, but are passed on to MYFUNCT for evaluation.</span>
<span class="comments">;  </span>
<span class="comments">;     .LIMITED - a two-element boolean array.  If the first/second</span>
<span class="comments">;                element is set, then the parameter is bounded on the</span>
<span class="comments">;                lower/upper side.  A parameter can be bounded on both</span>
<span class="comments">;                sides.  Both LIMITED and LIMITS must be given</span>
<span class="comments">;                together.</span>
<span class="comments">;  </span>
<span class="comments">;     .LIMITS - a two-element float or double array.  Gives the</span>
<span class="comments">;               parameter limits on the lower and upper sides,</span>
<span class="comments">;               respectively.  Zero, one or two of these values can be</span>
<span class="comments">;               set, depending on the values of LIMITED.  Both LIMITED</span>
<span class="comments">;               and LIMITS must be given together.</span>
<span class="comments">;  </span>
<span class="comments">;     .PARNAME - a string, giving the name of the parameter.  The</span>
<span class="comments">;                fitting code of MPFIT does not use this tag in any</span>
<span class="comments">;                way.  However, the default ITERPROC will print the</span>
<span class="comments">;                parameter name if available.</span>
<span class="comments">;  </span>
<span class="comments">;     .STEP - the step size to be used in calculating the numerical</span>
<span class="comments">;             derivatives.  If set to zero, then the step size is</span>
<span class="comments">;             computed automatically.  Ignored when AUTODERIVATIVE=0.</span>
<span class="comments">;             This value is superceded by the RELSTEP value.</span>
<span class="comments">;</span>
<span class="comments">;     .RELSTEP - the *relative* step size to be used in calculating</span>
<span class="comments">;                the numerical derivatives.  This number is the</span>
<span class="comments">;                fractional size of the step, compared to the</span>
<span class="comments">;                parameter value.  This value supercedes the STEP</span>
<span class="comments">;                setting.  If the parameter is zero, then a default</span>
<span class="comments">;                step size is chosen.</span>
<span class="comments">;</span>
<span class="comments">;     .MPSIDE - the sidedness of the finite difference when computing</span>
<span class="comments">;               numerical derivatives.  This field can take four</span>
<span class="comments">;               values:</span>
<span class="comments">;</span>
<span class="comments">;                  0 - one-sided derivative computed automatically</span>
<span class="comments">;                  1 - one-sided derivative (f(x+h) - f(x)  )/h</span>
<span class="comments">;                 -1 - one-sided derivative (f(x)   - f(x-h))/h</span>
<span class="comments">;                  2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)</span>
<span class="comments">;</span>
<span class="comments">;              Where H is the STEP parameter described above.  The</span>
<span class="comments">;              "automatic" one-sided derivative method will chose a</span>
<span class="comments">;              direction for the finite difference which does not</span>
<span class="comments">;              violate any constraints.  The other methods do not</span>
<span class="comments">;              perform this check.  The two-sided method is in</span>
<span class="comments">;              principle more precise, but requires twice as many</span>
<span class="comments">;              function evaluations.  Default: 0.</span>
<span class="comments">;</span>
<span class="comments">;     .MPMAXSTEP - the maximum change to be made in the parameter</span>
<span class="comments">;                  value.  During the fitting process, the parameter</span>
<span class="comments">;                  will never be changed by more than this value in</span>
<span class="comments">;                  one iteration.</span>
<span class="comments">;</span>
<span class="comments">;                  A value of 0 indicates no maximum.  Default: 0.</span>
<span class="comments">;  </span>
<span class="comments">;     .TIED - a string expression which "ties" the parameter to other</span>
<span class="comments">;             free or fixed parameters.  Any expression involving</span>
<span class="comments">;             constants and the parameter array P are permitted.</span>
<span class="comments">;             Example: if parameter 2 is always to be twice parameter</span>
<span class="comments">;             1 then use the following: parinfo(2).tied = '2 * P(1)'.</span>
<span class="comments">;             Since they are totally constrained, tied parameters are</span>
<span class="comments">;             considered to be fixed; no errors are computed for them.</span>
<span class="comments">;             [ NOTE: the PARNAME can't be used in expressions. ]</span>
<span class="comments">;</span>
<span class="comments">;     .MPPRINT - if set to 1, then the default ITERPROC will print the</span>
<span class="comments">;                parameter value.  If set to 0, the parameter value</span>
<span class="comments">;                will not be printed.  This tag can be used to</span>
<span class="comments">;                selectively print only a few parameter values out of</span>
<span class="comments">;                many.  Default: 1 (all parameters printed)</span>
<span class="comments">;</span>
<span class="comments">;  </span>
<span class="comments">;  Future modifications to the PARINFO structure, if any, will involve</span>
<span class="comments">;  adding structure tags beginning with the two letters "MP".</span>
<span class="comments">;  Therefore programmers are urged to avoid using tags starting with</span>
<span class="comments">;  the same letters; otherwise they are free to include their own</span>
<span class="comments">;  fields within the PARINFO structure, and they will be ignored.</span>
<span class="comments">;  </span>
<span class="comments">;  PARINFO Example:</span>
<span class="comments">;  parinfo = replicate({value:0.D, fixed:0, limited:[0,0], $</span>
<span class="comments">;                       limits:[0.D,0]}, 5)</span>
<span class="comments">;  parinfo(0).fixed = 1</span>
<span class="comments">;  parinfo(4).limited(0) = 1</span>
<span class="comments">;  parinfo(4).limits(0)  = 50.D</span>
<span class="comments">;  parinfo(*).value = [5.7D, 2.2, 500., 1.5, 2000.]</span>
<span class="comments">;  </span>
<span class="comments">;  A total of 5 parameters, with starting values of 5.7,</span>
<span class="comments">;  2.2, 500, 1.5, and 2000 are given.  The first parameter</span>
<span class="comments">;  is fixed at a value of 5.7, and the last parameter is</span>
<span class="comments">;  constrained to be above 50.</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;   X - Array of independent variable values.</span>
<span class="comments">;</span>
<span class="comments">;   Y - Array of "measured" dependent variable values.  Y should have</span>
<span class="comments">;       the same data type as X.  The function FUNCT should map</span>
<span class="comments">;       X->Y.</span>
<span class="comments">;</span>
<span class="comments">;   WEIGHTS - Array of weights to be used in calculating the</span>
<span class="comments">;             chi-squared value.  If WEIGHTS is specified then the ERR</span>
<span class="comments">;             parameter is ignored.  The chi-squared value is computed</span>
<span class="comments">;             as follows:</span>
<span class="comments">;</span>
<span class="comments">;                CHISQ = TOTAL( (Y-FUNCT(X,P))^2 * ABS(WEIGHTS) )</span>
<span class="comments">;</span>
<span class="comments">;             Here are common values of WEIGHTS:</span>
<span class="comments">;</span>
<span class="comments">;                1D/ERR^2 - Normal weighting (ERR is the measurement error)</span>
<span class="comments">;                1D/Y     - Poisson weighting (counting statistics)</span>
<span class="comments">;                1D       - Unweighted</span>
<span class="comments">;</span>
<span class="comments">;   P - An array of starting values for each of the parameters of the</span>
<span class="comments">;       model.  The number of parameters should be fewer than the</span>
<span class="comments">;       number of measurements.  Also, the parameters should have the</span>
<span class="comments">;       same data type as the measurements (double is preferred).</span>
<span class="comments">;</span>
<span class="comments">;       Upon successful completion the new parameter values are</span>
<span class="comments">;       returned in P.</span>
<span class="comments">;</span>
<span class="comments">;       If both START_PARAMS and PARINFO are passed, then the starting</span>
<span class="comments">;       *value* is taken from START_PARAMS, but the *constraints* are</span>
<span class="comments">;       taken from PARINFO.</span>
<span class="comments">; </span>
<span class="comments">;   SIGMA - The formal 1-sigma errors in each parameter, computed from</span>
<span class="comments">;           the covariance matrix.  If a parameter is held fixed, or</span>
<span class="comments">;           if it touches a boundary, then the error is reported as</span>
<span class="comments">;           zero.</span>
<span class="comments">;</span>
<span class="comments">;           If the fit is unweighted (i.e. no errors were given, or</span>
<span class="comments">;           the weights were uniformly set to unity), then SIGMA will</span>
<span class="comments">;           probably not represent the true parameter uncertainties.</span>
<span class="comments">;</span>
<span class="comments">;           *If* you can assume that the true reduced chi-squared</span>
<span class="comments">;           value is unity -- meaning that the fit is implicitly</span>
<span class="comments">;           assumed to be of good quality -- then the estimated</span>
<span class="comments">;           parameter uncertainties can be computed by scaling SIGMA</span>
<span class="comments">;           by the measured chi-squared value.</span>
<span class="comments">;</span>
<span class="comments">;              DOF     = N_ELEMENTS(X) - N_ELEMENTS(P) ; deg of freedom</span>
<span class="comments">;              CSIGMA  = SIGMA * SQRT(CHISQ / DOF)     ; scaled uncertainties</span>
<span class="comments">;</span>
<span class="comments">; RETURNS:</span>
<span class="comments">;</span>
<span class="comments">;   Returns the array containing the best-fitting function.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORD PARAMETERS:</span>
<span class="comments">;</span>
<span class="comments">;   CHISQ - the value of the summed, squared, weighted residuals for</span>
<span class="comments">;           the returned parameter values, i.e. the chi-square value.</span>
<span class="comments">;</span>
<span class="comments">;   COVAR - the covariance matrix for the set of parameters returned</span>
<span class="comments">;           by MPFIT.  The matrix is NxN where N is the number of</span>
<span class="comments">;           parameters.  The square root of the diagonal elements</span>
<span class="comments">;           gives the formal 1-sigma statistical errors on the</span>
<span class="comments">;           parameters IF errors were treated "properly" in MYFUNC.</span>
<span class="comments">;           Parameter errors are also returned in PERROR.</span>
<span class="comments">;</span>
<span class="comments">;           To compute the correlation matrix, PCOR, use this:</span>
<span class="comments">;           IDL> PCOR = COV * 0</span>
<span class="comments">;           IDL> FOR i = 0, n-1 DO FOR j = 0, n-1 DO $</span>
<span class="comments">;                PCOR(i,j) = COV(i,j)/sqrt(COV(i,i)*COV(j,j))</span>
<span class="comments">;</span>
<span class="comments">;           If NOCOVAR is set or MPFIT terminated abnormally, then</span>
<span class="comments">;           COVAR is set to a scalar with value !VALUES.D_NAN.</span>
<span class="comments">;</span>
<span class="comments">;   DOF - number of degrees of freedom, computed as</span>
<span class="comments">;             DOF = N_ELEMENTS(DEVIATES) - NFREE</span>
<span class="comments">;         Note that this doesn't account for pegged parameters (see</span>
<span class="comments">;         NPEGGED).</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - a string error or warning message is returned.</span>
<span class="comments">;</span>
<span class="comments">;   FTOL - a nonnegative input variable. Termination occurs when both</span>
<span class="comments">;          the actual and predicted relative reductions in the sum of</span>
<span class="comments">;          squares are at most FTOL (and STATUS is accordingly set to</span>
<span class="comments">;          1 or 3).  Therefore, FTOL measures the relative error</span>
<span class="comments">;          desired in the sum of squares.  Default: 1D-10</span>
<span class="comments">;</span>
<span class="comments">;   FUNCTION_NAME - a scalar string containing the name of an IDL</span>
<span class="comments">;                   procedure to compute the user model values, as</span>
<span class="comments">;                   described above in the "USER MODEL" section.</span>
<span class="comments">;</span>
<span class="comments">;   FUNCTARGS - A structure which contains the parameters to be passed</span>
<span class="comments">;               to the user-supplied function specified by FUNCT via</span>
<span class="comments">;               the _EXTRA mechanism.  This is the way you can pass</span>
<span class="comments">;               additional data to your user-supplied function without</span>
<span class="comments">;               using common blocks.</span>
<span class="comments">;</span>
<span class="comments">;               By default, no extra parameters are passed to the</span>
<span class="comments">;               user-supplied function.</span>
<span class="comments">;</span>
<span class="comments">;   GTOL - a nonnegative input variable. Termination occurs when the</span>
<span class="comments">;          cosine of the angle between fvec and any column of the</span>
<span class="comments">;          jacobian is at most GTOL in absolute value (and STATUS is</span>
<span class="comments">;          accordingly set to 4). Therefore, GTOL measures the</span>
<span class="comments">;          orthogonality desired between the function vector and the</span>
<span class="comments">;          columns of the jacobian.  Default: 1D-10</span>
<span class="comments">;</span>
<span class="comments">;   ITER - the number of iterations completed.</span>
<span class="comments">;</span>
<span class="comments">;   ITERARGS - The keyword arguments to be passed to ITERPROC via the</span>
<span class="comments">;              _EXTRA mechanism.  This should be a structure, and is</span>
<span class="comments">;              similar in operation to FUNCTARGS.</span>
<span class="comments">;              Default: no arguments are passed.</span>
<span class="comments">;</span>
<span class="comments">;   ITERPROC - The name of a procedure to be called upon each NPRINT</span>
<span class="comments">;              iteration of the MPFIT routine.  It should be declared</span>
<span class="comments">;              in the following way:</span>
<span class="comments">;</span>
<span class="comments">;              PRO ITERPROC, FUNCT, p, iter, fnorm, FUNCTARGS=fcnargs, $</span>
<span class="comments">;                PARINFO=parinfo, QUIET=quiet, ...</span>
<span class="comments">;                ; perform custom iteration update</span>
<span class="comments">;              END</span>
<span class="comments">;         </span>
<span class="comments">;              ITERPROC must either accept all three keyword</span>
<span class="comments">;              parameters (FUNCTARGS, PARINFO and QUIET), or at least</span>
<span class="comments">;              accept them via the _EXTRA keyword.</span>
<span class="comments">;          </span>
<span class="comments">;              FUNCT is the user-supplied function to be minimized,</span>
<span class="comments">;              P is the current set of model parameters, ITER is the</span>
<span class="comments">;              iteration number, and FUNCTARGS are the arguments to be</span>
<span class="comments">;              passed to FUNCT.  FNORM should be the</span>
<span class="comments">;              chi-squared value.  QUIET is set when no textual output</span>
<span class="comments">;              should be printed.  See below for documentation of</span>
<span class="comments">;              PARINFO.</span>
<span class="comments">;</span>
<span class="comments">;              In implementation, ITERPROC can perform updates to the</span>
<span class="comments">;              terminal or graphical user interface, to provide</span>
<span class="comments">;              feedback while the fit proceeds.  If the fit is to be</span>
<span class="comments">;              stopped for any reason, then ITERPROC should set the</span>
<span class="comments">;              common block variable ERROR_CODE to negative value (see</span>
<span class="comments">;              MPFIT_ERROR common block below).  In principle,</span>
<span class="comments">;              ITERPROC should probably not modify the parameter</span>
<span class="comments">;              values, because it may interfere with the algorithm's</span>
<span class="comments">;              stability.  In practice it is allowed.</span>
<span class="comments">;</span>
<span class="comments">;              Default: an internal routine is used to print the</span>
<span class="comments">;                       parameter values.</span>
<span class="comments">;</span>
<span class="comments">;   ITMAX - The maximum number of iterations to perform.  If the</span>
<span class="comments">;             number is exceeded, then the STATUS value is set to 5</span>
<span class="comments">;             and MPFIT returns.</span>
<span class="comments">;             Default: 200 iterations</span>
<span class="comments">;</span>
<span class="comments">;   NFEV - the number of FUNCT function evaluations performed.</span>
<span class="comments">;</span>
<span class="comments">;   NFREE - the number of free parameters in the fit.  This includes</span>
<span class="comments">;           parameters which are not FIXED and not TIED, but it does</span>
<span class="comments">;           include parameters which are pegged at LIMITS.</span>
<span class="comments">;</span>
<span class="comments">;   NOCOVAR - set this keyword to prevent the calculation of the</span>
<span class="comments">;             covariance matrix before returning (see COVAR)</span>
<span class="comments">;</span>
<span class="comments">;   NODERIVATIVE - if set, then the user function will not be queried</span>
<span class="comments">;                  for analytical derivatives, and instead the</span>
<span class="comments">;                  derivatives will be computed by finite differences</span>
<span class="comments">;                  (and according to the PARINFO derivative settings;</span>
<span class="comments">;                  see above for a description).</span>
<span class="comments">;</span>
<span class="comments">;   NPRINT - The frequency with which ITERPROC is called.  A value of</span>
<span class="comments">;            1 indicates that ITERPROC is called with every iteration,</span>
<span class="comments">;            while 2 indicates every other iteration, etc.  Note that</span>
<span class="comments">;            several Levenberg-Marquardt attempts can be made in a</span>
<span class="comments">;            single iteration.</span>
<span class="comments">;            Default value: 1</span>
<span class="comments">;</span>
<span class="comments">;   PARINFO - Provides a mechanism for more sophisticated constraints</span>
<span class="comments">;             to be placed on parameter values.  When PARINFO is not</span>
<span class="comments">;             passed, then it is assumed that all parameters are free</span>
<span class="comments">;             and unconstrained.  Values in PARINFO are never </span>
<span class="comments">;             modified during a call to MPFIT.</span>
<span class="comments">;</span>
<span class="comments">;             See description above for the structure of PARINFO.</span>
<span class="comments">;</span>
<span class="comments">;             Default value:  all parameters are free and unconstrained.</span>
<span class="comments">;</span>
<span class="comments">;   QUIET - set this keyword when no textual output should be printed</span>
<span class="comments">;           by MPFIT</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - an integer status code is returned.  All values other</span>
<span class="comments">;            than zero can represent success.  It can have one of the</span>
<span class="comments">;            following values:</span>
<span class="comments">;</span>
<span class="comments">;	   0  improper input parameters.</span>
<span class="comments">;         </span>
<span class="comments">;	   1  both actual and predicted relative reductions</span>
<span class="comments">;	      in the sum of squares are at most FTOL.</span>
<span class="comments">;         </span>
<span class="comments">;	   2  relative error between two consecutive iterates</span>
<span class="comments">;	      is at most XTOL</span>
<span class="comments">;         </span>
<span class="comments">;	   3  conditions for STATUS = 1 and STATUS = 2 both hold.</span>
<span class="comments">;         </span>
<span class="comments">;	   4  the cosine of the angle between fvec and any</span>
<span class="comments">;	      column of the jacobian is at most GTOL in</span>
<span class="comments">;	      absolute value.</span>
<span class="comments">;         </span>
<span class="comments">;	   5  the maximum number of iterations has been reached</span>
<span class="comments">;         </span>
<span class="comments">;	   6  FTOL is too small. no further reduction in</span>
<span class="comments">;	      the sum of squares is possible.</span>
<span class="comments">;         </span>
<span class="comments">;	   7  XTOL is too small. no further improvement in</span>
<span class="comments">;	      the approximate solution x is possible.</span>
<span class="comments">;         </span>
<span class="comments">;	   8  GTOL is too small. fvec is orthogonal to the</span>
<span class="comments">;	      columns of the jacobian to machine precision.</span>
<span class="comments">;</span>
<span class="comments">;   TOL - synonym for FTOL.  Use FTOL instead.</span>
<span class="comments">;</span>
<span class="comments">;   XTOL - a nonnegative input variable. Termination occurs when the</span>
<span class="comments">;          relative error between two consecutive iterates is at most</span>
<span class="comments">;          XTOL (and STATUS is accordingly set to 2 or 3).  Therefore,</span>
<span class="comments">;          XTOL measures the relative error desired in the approximate</span>
<span class="comments">;          solution.  Default: 1D-10</span>
<span class="comments">;</span>
<span class="comments">;   YERROR - upon return, the root-mean-square variance of the</span>
<span class="comments">;            residuals.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   ; First, generate some synthetic data</span>
<span class="comments">;   npts = 200</span>
<span class="comments">;   x  = dindgen(npts) * 0.1 - 10.                  ; Independent variable </span>
<span class="comments">;   yi = gauss1(x, [2.2D, 1.4, 3000.])              ; "Ideal" Y variable</span>
<span class="comments">;   y  = yi + randomn(seed, npts) * sqrt(1000. + yi); Measured, w/ noise</span>
<span class="comments">;   sy = sqrt(1000.D + y)                           ; Poisson errors</span>
<span class="comments">;</span>
<span class="comments">;   ; Now fit a Gaussian to see how well we can recover</span>
<span class="comments">;   p0 = [1.D, 1., 1000.]                           ; Initial guess</span>
<span class="comments">;   yfit = mpcurvefit(x, y, 1/sy^2, p0, $           ; Fit a function</span>
<span class="comments">;                     FUNCTION_NAME='GAUSS1P',/autoderivative)</span>
<span class="comments">;   print, p</span>
<span class="comments">;</span>
<span class="comments">;   Generates a synthetic data set with a Gaussian peak, and Poisson</span>
<span class="comments">;   statistical uncertainty.  Then the same function is fitted to the</span>
<span class="comments">;   data to see how close we can get.  GAUSS1 and GAUSS1P are</span>
<span class="comments">;   available from the same web page.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;</span>
<span class="comments">;   COMMON MPFIT_ERROR, ERROR_CODE</span>
<span class="comments">;</span>
<span class="comments">;     User routines may stop the fitting process at any time by</span>
<span class="comments">;     setting an error condition.  This condition may be set in either</span>
<span class="comments">;     the user's model computation routine (MYFUNCT), or in the</span>
<span class="comments">;     iteration procedure (ITERPROC).</span>
<span class="comments">;</span>
<span class="comments">;     To stop the fitting, the above common block must be declared,</span>
<span class="comments">;     and ERROR_CODE must be set to a negative number.  After the user</span>
<span class="comments">;     procedure or function returns, MPFIT checks the value of this</span>
<span class="comments">;     common block variable and exits immediately if the error</span>
<span class="comments">;     condition has been set.  By default the value of ERROR_CODE is</span>
<span class="comments">;     zero, indicating a successful function/procedure call.</span>
<span class="comments">;</span>
<span class="comments">; REFERENCES:</span>
<span class="comments">;</span>
<span class="comments">;   MINPACK-1, Jorge More', available from netlib (www.netlib.org).</span>
<span class="comments">;   "Optimization Software Guide," Jorge More' and Stephen Wright, </span>
<span class="comments">;     SIAM, *Frontiers in Applied Mathematics*, Number 14.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Translated from MPFITFUN, 25 Sep 1999, CM</span>
<span class="comments">;   Alphabetized documented keywords, 02 Oct 1999, CM</span>
<span class="comments">;   Added QUERY keyword and query checking of MPFIT, 29 Oct 1999, CM</span>
<span class="comments">;   Check to be sure that X and Y are present, 02 Nov 1999, CM</span>
<span class="comments">;   Documented SIGMA for unweighted fits, 03 Nov 1999, CM</span>
<span class="comments">;   Changed to ERROR_CODE for error condition, 28 Jan 2000, CM</span>
<span class="comments">;   Copying permission terms have been liberalized, 26 Mar 2000, CM</span>
<span class="comments">;   Propagated improvements from MPFIT, 17 Dec 2000, CM</span>
<span class="comments">;   Corrected behavior of NODERIVATIVE, 13 May 2002, CM</span>
<span class="comments">;   Documented RELSTEP field of PARINFO (!!), CM, 25 Oct 2002</span>
<span class="comments">;   Make more consistent with comparable IDL routines, 30 Jun 2003, CM</span>
<span class="comments">;   Minor documentation adjustment, 03 Feb 2004, CM</span>
<span class="comments">;   Fix error in documentation, 26 Aug 2005, CM</span>
<span class="comments">;   Convert to IDL 5 array syntax (!), 16 Jul 2006, CM</span>
<span class="comments">;   Move STRICTARR compile option inside each function/procedure, 9 Oct 2006</span>
<span class="comments">;</span>
<span class="comments">;  $Id: mpcurvefit.pro,v 1.9 2006/10/09 19:25:29 craigm Exp $</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 1997-2000, 2002, 2003, 2004, 2005, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

FORWARD_FUNCTION mpcurvefit_eval, mpcurvefit, mpfit

<span class="comments">; This is the call-back function for MPFIT.  It evaluates the</span>
<span class="comments">; function, subtracts the data, and returns the residuals.</span>
<a id="mpcurvefit_eval:source"></a>function mpcurvefit_eval, p, dp, _EXTRA=extra

  COMPILE_OPT strictarr
  common mpcurvefit_common, fcn, x, y, wts, f, fcnargs

  <span class="comments">;; The function is evaluated here.  There are four choices,</span>
  <span class="comments">;; depending on whether (a) FUNCTARGS was passed to MPCURVEFIT, which</span>
  <span class="comments">;; is passed to this function as "hf"; or (b) the derivative</span>
  <span class="comments">;; parameter "dp" is passed, meaning that derivatives should be</span>
  <span class="comments">;; calculated analytically by the function itself.</span>
  if n_elements(fcnargs) GT 0 then begin
      if n_params() GT 1 then call_procedure, fcn, x, p, f, dp,_EXTRA=fcnargs $
      else                    call_procedure, fcn, x, p, f,    _EXTRA=fcnargs
  endif else begin
      if n_params() GT 1 then call_procedure, fcn, x, p, f, dp $
      else                    call_procedure, fcn, x, p, f
  endelse

  <span class="comments">;; Compute the deviates, applying the weights</span>
  result = (y-f)*wts
      
  <span class="comments">;; Make sure the returned result is one-dimensional.</span>
  result = reform(result, n_elements(result), /overwrite)
  return, result
  
end

<a id="mpcurvefit:source"></a>function mpcurvefit, x, y, wts, p, perror, function_name=fcn, $
                     iter=iter, itmax=maxiter, $
                     chisq=bestnorm, nfree=nfree, dof=dof, $
                     nfev=nfev, covar=covar, nocovar=nocovar, yerror=yerror, $
                     noderivative=noderivative, tol=tol, ftol=ftol, $
                     FUNCTARGS=fa, parinfo=parinfo, $
                     errmsg=errmsg, STATUS=status, QUIET=quiet, $
                     query=query, _EXTRA=extra

  COMPILE_OPT strictarr
  status = 0L
  errmsg = ''

  <span class="comments">;; Detect MPFIT and crash if it was not found</span>
  catch, catcherror
  if catcherror NE 0 then begin
      MPFIT_NOTFOUND:
      catch, /cancel
      message, 'ERROR: the required function MPFIT must be in your IDL path', /info
      return, !values.d_nan
  endif
  if mpfit(/query) NE 1 then goto, MPFIT_NOTFOUND
  catch, /cancel
  if keyword_set(query) then return, 1

  if n_params() EQ 0 then begin
      message, "USAGE: YFIT = MPCURVEFIT(X, Y, WTS, P, DP)", /info
      return, !values.d_nan
  endif
  if n_elements(x) EQ 0 OR n_elements(y) EQ 0 then begin
      message, 'ERROR: X and Y must be defined', /info
      return, !values.d_nan
  endif
  if n_elements(fcn) EQ 0 then fcn = 'funct'
  if n_elements(noderivative) EQ 0 then noderivative = 0

  common mpcurvefit_common, fc, xc, yc, wc, mc, ac
  fc = fcn & xc = x & yc = y & wc = sqrt(abs(wts)) & mc = 0L
  ac = 0 & dummy = size(temporary(ac))
  if n_elements(fa) GT 0 then ac = fa

  if n_elements(tol) GT 0 then ftol = tol

  result = mpfit('mpcurvefit_eval', p, maxiter=maxiter, $
                 autoderivative=noderivative, ftol=ftol, $
                 parinfo=parinfo, STATUS=status, nfev=nfev, BESTNORM=bestnorm,$
                 covar=covar, perror=perror, niter=iter, nfree=nfree, dof=dof,$
                 ERRMSG=errmsg, quiet=quiet, _EXTRA=extra)

  <span class="comments">;; Retrieve the fit value</span>
  yfit = temporary(mc)
  <span class="comments">;; Now do some clean-up</span>
  xc = 0 & yc = 0 & wc = 0 & mc = 0 & ac = 0

  if NOT keyword_set(quiet) AND errmsg NE '' then $
    message, errmsg, /info $
  else $
    p = result

  yerror = p[0]*0
  if n_elements(dof) GT 0 AND dof[0] GT 0 then begin
      yerror[0] = sqrt( total( (y-yfit)^2 ) / dof[0] )
  endif

  return, yfit
end
</code>
    </div>
  </body>
</html>