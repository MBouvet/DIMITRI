<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:42 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>envisat.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="envisat.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; +</span>
<span class="comments">; LIBRARY ENVISAT.PRO (c) RAL/CCLRC 2002</span>
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.3  TJN  09-JAN-2003  Add ENVISAT_READ_DS generic data set</span>
<span class="comments">;                            reading routine.</span>
<span class="comments">;     1.2  TJN  18-NOV-2002  Change ENVISAT_DEFINE_MJD function</span>
<span class="comments">;                            name to take advantage of automatic</span>
<span class="comments">;                            IDL structure definitions.</span>
<span class="comments">;     1.1  TJN  25-OCT-2002  Add ENVISAT_MJD_TO_TIME and associated</span>
<span class="comments">;                            routines to generate date and time</span>
<span class="comments">;                            strings from MJDs.</span>
<span class="comments">;     1.0  TJN  16-SEP-2002  Original.</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;      ENVISAT generic structure prototypes and routines to ingest</span>
<span class="comments">;      instrument data.</span>
<span class="comments">;</span>
<span class="comments">; Code starts here ------------------------------------------------</span>
<span class="comments">;</span>



<span class="comments">;******************************************************************</span>
<span class="comments">; ENVISAT constants</span>
<span class="comments">;******************************************************************</span>



PRO ENVISAT_DEFINE_CONSTANTS
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.0  TJN  05-SEP-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Program-wide definitions for constants not contained</span>
<span class="comments">;     in the product file.</span>
<span class="comments">;</span>
<span class="comments">; Code starts here ------------------------------------------------</span>
<span class="comments">;</span>
  DEFSYSV, '!ENVISAT', {ENVISAT_CONSTANTS, $
    MPH_SIZE      : 1247,     $
    SPH_SIZE      :  836      $   <span class="comments">; L0 SPH size (all instruments)</span>
  }
END



<span class="comments">;******************************************************************</span>
<span class="comments">; ENVISAT prototype structures</span>
<span class="comments">;******************************************************************</span>



PRO ENVISAT_MJD__DEFINE
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.1  TJN  15-NOV-2002  Change function name from</span>
<span class="comments">;                            ENVISAT_DEFINE_MJD to take advantage</span>
<span class="comments">;                            of automatic structure definitions.</span>
<span class="comments">;     1.0  TJN  05-SEP-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Generates a structure prototype for the ENVISAT Modified</span>
<span class="comments">;     Julian Day time representation.</span>
<span class="comments">;</span>
<span class="comments">; Code starts here ------------------------------------------------</span>
<span class="comments">;</span>
  Temp = {ENVISAT_MJD, $
    DAY         : 0L,  $
    SECOND      : 0UL, $
    MICROSECOND : 0UL  $
  }
END



<span class="comments">;******************************************************************</span>
<span class="comments">; ENVISAT generic functions</span>
<span class="comments">;******************************************************************</span>



FUNCTION ENVISAT_BILINEAR, P, IX, JY, EXTRAPOLATE=EX
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.0  TJN  16-SEP-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Drop-in replacement for the IDL routine BILINEAR, with the</span>
<span class="comments">;     exception that ENVISAT_BILINEAR can extrapolate beyond the</span>
<span class="comments">;     limits of the input array P when EXTRAPOLATE is set, whereas</span>
<span class="comments">;     BILINEAR limits at the appropriate extreme value in P.</span>
<span class="comments">;     Extrapolation is needed for the edges of AATSR solar and</span>
<span class="comments">;     satellite view angles.</span>
<span class="comments">;</span>
<span class="comments">;     Array initialisation - matrix multiplication vs. row-by-row</span>
<span class="comments">;     copies in BILINEAR - is MUCH faster in this version.</span>
<span class="comments">;</span>
<span class="comments">; Get array sizes -------------------------------------------------</span>
<span class="comments">;</span>
  sp = SIZE(p)
  si = SIZE(ix)
  sj = SIZE(jy)
<span class="comments">;</span>
<span class="comments">; Build 2-D indices if needed ------------------------------------</span>
<span class="comments">;</span>
  IF (si[0] EQ 1) THEN ix = ix # REPLICATE(1, sj[sj[0]])
  IF (sj[0] EQ 1) THEN jy = REPLICATE(1, si[1]) # jy
<span class="comments">;</span>
<span class="comments">; Skip out if extrapolation not required -------------------------</span>
<span class="comments">;</span>
  IF NOT KEYWORD_SET(Ex) THEN RETURN, INTERPOLATE(p, ix, jy)
<span class="comments">;</span>
<span class="comments">; Make 'x' indices and offsets -----------------------------------</span>
<span class="comments">;</span>
  i0 = (0 > FLOOR(ix)) &lt<span class="comments">; (sp[1] - 2)</span>
  i1 = i0 + 1
  di = ix - i0
<span class="comments">;</span>
<span class="comments">; Make 'y' indices and offsets -----------------------------------</span>
<span class="comments">;</span>
  j0 = (0 > FLOOR(jy)) &lt<span class="comments">; (sp[2] - 2)</span>
  j1 = j0 + 1
  dj = jy - j0
<span class="comments">;</span>
<span class="comments">; Interpolate P array to IX and JY virtual indices ---------------</span>
<span class="comments">;</span>
<span class="comments">; N.B. 4 * , 8 +/- here, v.s. 8 *, 7 +/- in old BILINEAR method</span>
<span class="comments">;</span>
  RETURN, P[i0, j0] + $
    di * (P[i1, j0] - P[i0, j0]) + $
    dj * (P[i0, j1] - P[i0, j0]) + $
    di * dj * (P[i0, j0] - P[i1, j0] - P[i0, j1] + P[i1, j1])
END



FUNCTION ENVISAT_GET_VALUE, TOKEN
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.0  TJN  02-SEP-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Interprets tokens parsed by ENVISAT_GET_HEADER as values.</span>
<span class="comments">;</span>
<span class="comments">; MANDATORY PARAMETER</span>
<span class="comments">;     TOKEN    Token string representing value</span>
<span class="comments">;</span>
<span class="comments">; Fetch byte stream ------------------------------------------</span>
<span class="comments">;</span>
  IF (STRMID(Token, 0, 1) EQ '"') THEN RETURN, STRMID(Token, 1) <span class="comments">; Character strings</span>
  IF (STRPOS(Token, '.') GE 0) THEN RETURN, DOUBLE(Token)       <span class="comments">; Floating point</span>
  IF (STREGEX(Token, '[A-Za-z]') GE 0) THEN RETURN, Token       <span class="comments">; Single letters</span>
  i = STRSPLIT(Token, '+-', LENGTH=j) & n = N_ELEMENTS(i)       <span class="comments">; Identify multiple elements</span>
  IF (n GT 1) THEN RETURN, LONG64(STRMID(Token, i-1, j+1))      <span class="comments">; Integer array</span>
  RETURN, LONG64(Token)                                         <span class="comments">; Integer</span>
END



FUNCTION ENVISAT_GET_HEADER, UNIT, LENGTH, OFFSET, NAME=NAME, N_TAGS=NTAGS
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.0  TJN  02-SEP-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Breaks up byte stream into tokens. Strips out all units</span>
<span class="comments">;     &lt;...>, equality signs, and trailing white space and</span>
<span class="comments">;     close quotes in string expressions, leaving the opening</span>
<span class="comments">;     quote as a string marker. Loads tokens into output</span>
<span class="comments">;     structure.</span>
<span class="comments">;</span>
<span class="comments">; MANDATORY PARAMETERS</span>
<span class="comments">;     UNIT     File unit number</span>
<span class="comments">;     LENGTH   Size of header in bytes</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL PARAMETERS</span>
<span class="comments">;     OFFSET   Offset into file of header start in bytes</span>
<span class="comments">;              (default: current file position)</span>
<span class="comments">;     NAME     Output structure name (default: anonymous)</span>
<span class="comments">; Fetch byte stream ------------------------------------------</span>
<span class="comments">;</span>
  BS = BYTARR(Length)
  IF KEYWORD_SET(Offset) THEN POINT_LUN, Unit, Offset
  READU, Unit, BS
<span class="comments">;</span>
<span class="comments">; Split into tokens ------------------------------------------</span>
<span class="comments">;</span>
  Token = STRSPLIT(STRING(BS), '&lt;[ -z]+>| *= *| *"?' + STRING(10B), /REGEX, /EXTRACT)

  n = N_ELEMENTS(Token)
  nTags = n / 2 & IF (nTags EQ 0) THEN RETURN, -1
<span class="comments">;</span>
<span class="comments">; Load tokens into output structure --------------------------</span>
<span class="comments">;</span>
  x = CREATE_STRUCT(Token[0], ENVISAT_GET_VALUE(Token[1]))
  FOR i = 2, n-2, 2 DO BEGIN
  x = CREATE_STRUCT(x, token[i], ENVISAT_GET_VALUE(Token[i+1])) 
  ENDFOR	
  RETURN, CREATE_STRUCT(x, NAME=Name)

END



FUNCTION ENVISAT_INDEX_DSD, DSD, N_TAGS=J, ADS=A, GADS=G, MDS=M, REFERENCE=R, NAME=NAME
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.2  TJN  11-NOV-2002  Add GADS option</span>
<span class="comments">;     1.1  TJN  22-OCT-2002  Functionality extended. Original</span>
<span class="comments">;                            equivalent to /ADS and /MDS options.</span>
<span class="comments">;     1.0  TJN  11-OCT-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Returns a structure with tag names constructed from</span>
<span class="comments">;     sanitised versions of DSD[*].DS_NAME. Tags for the reference</span>
<span class="comments">;     ('R') files contain the file name. Those for data sets</span>
<span class="comments">;     contain the index to the corresponding DSD, e.g., for AATSR:</span>
<span class="comments">;</span>
<span class="comments">;       Index    = ENVISAT_INDEX_DSD(DSD)</span>
<span class="comments">;       Quality  = AATSR_READ_ADS_SQ(Unit, DSD[Index.SUMMARY_QUALITY_ADS])</span>
<span class="comments">;       Filename = Index.INSTRUMENT_DATA_FILE</span>
<span class="comments">;</span>
<span class="comments">;     By default, ENVISAT_INDEX_DSD returns values for all data set</span>
<span class="comments">;     types.</span>
<span class="comments">;</span>
<span class="comments">; MANDATORY PARAMETERS</span>
<span class="comments">;     DSD        Array of Data Set Descriptors.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL PARAMETERS</span>
<span class="comments">;    /ADS        Return indices to Annotation Data Set DSDs.</span>
<span class="comments">;    /GADS       Return indices to Global Annotation Data Set DSDs.</span>
<span class="comments">;    /MDS        Return indices to Measurement Data Set DSDs.</span>
<span class="comments">;    /REFERENCE  Return reference filenames.</span>
<span class="comments">;     NAME       Output structure name (default: anonymous)</span>
<span class="comments">;</span>
<span class="comments">; Choose options ------------------------------------------------------</span>
<span class="comments">;</span>
  ADS  = KEYWORD_SET(A)
  GADS = KEYWORD_SET(G)
  MDS  = KEYWORD_SET(M)
  Ref  = KEYWORD_SET(R)
  None = NOT (ADS OR GADS OR MDS OR Ref)
  ADS  = None OR ADS
  GADS = None OR GADS
  MDS  = None OR MDS
  Ref  = None OR Ref
<span class="comments">;</span>
<span class="comments">; Fill structure -----------------------------------------------------</span>
<span class="comments">;</span>
  j = 0L
  FOR i = 0L, N_ELEMENTS(DSD)-1 DO BEGIN
    IF      ADS  AND (DSD[i].DS_TYPE EQ 'A') THEN Value = i $
    ELSE IF GADS AND (DSD[i].DS_TYPE EQ 'G') THEN Value = i $
    ELSE IF MDS  AND (DSD[i].DS_TYPE EQ 'M') THEN Value = i $
    ELSE IF Ref  AND (DSD[i].DS_TYPE EQ 'R') THEN Value = DSD[i].FILENAME $
    ELSE CONTINUE
    Tag = STRJOIN(STRSPLIT(DSD[i].DS_NAME, '    ()[]{}/\.', /EXTRACT), '_')
    IF (STREGEX(Tag, '[0-9]') EQ 0) THEN Tag = '_' + Tag
    IF (j EQ 0) THEN Index = CREATE_STRUCT(Tag, Value) $
    ELSE Index = CREATE_STRUCT(Index, Tag, Value)
    j = j + 1
  ENDFOR

  RETURN, CREATE_STRUCT(Index, NAME=Name)
END



FUNCTION ENVISAT_LEAPYEAR, YEAR
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.0  TJN  06-SEP-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Returns '1' for leap years, '0' otherwise.</span>
<span class="comments">;</span>
<span class="comments">; MANDATORY PARAMETERS</span>
<span class="comments">;     YEAR     Input scalar or array of years</span>
<span class="comments">;</span>
<span class="comments">; Code starts here ---------------------------------------------------</span>
<span class="comments">;</span>
  RETURN, (Year MOD 4 EQ 0) AND NOT $
    ( (Year MOD 100 EQ 0) AND NOT (Year MOD 400 EQ 0) )
END



PRO ENVISAT_JDAY_TO_DAY, YEAR, JDAY, MONTH, DAY
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.1  TJN  20-NOV-2002  Ensure that JDAY scalars and any-</span>
<span class="comments">;                            dimensional arrays accepted and, if</span>
<span class="comments">;                            a scalar YEAR is given, it is used</span>
<span class="comments">;                            for all elements of an array JDAY.</span>
<span class="comments">;                            return consistent scalar or array</span>
<span class="comments">;                            MONTH and DAY</span>
<span class="comments">;     1.0  TJN  25-OCT-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Calculates MONTH and DAY from JDAY. The algorithm sums all</span>
<span class="comments">;     permutations of (JDAY GE Day[]) over the elements of Day[],</span>
<span class="comments">;     where Day[] is an array containing the first Julian day</span>
<span class="comments">;     of the month.</span>
<span class="comments">;</span>
<span class="comments">; MANDATORY PARAMETERS</span>
<span class="comments">;     YEAR    Scalar or array containing year</span>
<span class="comments">;     JDAY    Scalar or array containing Julian day, defined as</span>
<span class="comments">;             the integer or fractional day of the year, starting</span>
<span class="comments">;             at 1.0 at the beginning of the 1st January</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL PARAMETERS</span>
<span class="comments">;     MONTH   Output scalar or array containing month number</span>
<span class="comments">;     DAY     Output scalar or array containing day number</span>
<span class="comments">;</span>
<span class="comments">; Start with first days of month ----------------------------------</span>
<span class="comments">;</span>
  Days = [ $
    [1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], $
    [1, 32, 61, 92, 122, 153, 183, 214, 245, 275, 306, 336]  $
  ]
<span class="comments">;</span>
<span class="comments">; Force all input arrays to be 1D ---------------------------------</span>
<span class="comments">;</span>
  s = SIZE(JDay)
  n = s[s[0] + 2]
  J = REFORM([JDay], n)
  IF (N_ELEMENTS(Year) GT 1) THEN LY = ENVISAT_LEAPYEAR(Year) $
  ELSE LY = REPLICATE(ENVISAT_LEAPYEAR(Year[0]), n)
<span class="comments">;</span>
<span class="comments">; The interesting stuff -------------------------------------------</span>
<span class="comments">;</span>
  One = 1  + INTARR(12)
  D = TRANSPOSE(Days[*, LY])
  Month = FIX(((J # One) GE D) # One)
  Day = 1 + J - Days[Month - 1, LY]
<span class="comments">;</span>
<span class="comments">; Unwind output arrays to conform to the input array dimensions ---</span>
<span class="comments">;</span>
  IF (s[0] EQ 0) THEN BEGIN
    Month = Month[0]
    Day = Day[0]
  ENDIF ELSE BEGIN
    Month = REFORM(Month, s[1:s[0]], /OVERWRITE)
    Day = REFORM(Day, s[1:s[0]], /OVERWRITE)
  ENDELSE
END



PRO ENVISAT_MJD_TO_JDAY, MJD, YEAR, JDAY, INTEGER=INTEGER
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.2  TJN  20-NOV-2002  Ensure that any-dimensional MJD array</span>
<span class="comments">;                            accepted and that returned YEAR and</span>
<span class="comments">;                            JDAY array dimensions are consistent</span>
<span class="comments">;                            with MJD array</span>
<span class="comments">;     1.1  TJN  25-OCT-2002  Revamped to cope properly with single</span>
<span class="comments">;                            values. INTEGER option added</span>
<span class="comments">;     1.0  TJN  06-SEP-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Calculates YEAR and JDAY from ENVISAT MJD. The algorithm sums</span>
<span class="comments">;     all permutations of (MJD[].DAY GE Day[]) over the elements of</span>
<span class="comments">;     Day[], where Day[] is an array containing the first day of the</span>
<span class="comments">;     year, starting at 2000.</span>
<span class="comments">;</span>
<span class="comments">; MANDATORY PARAMETERS</span>
<span class="comments">;     MJD     Input scalar or array of ENVISAT_MJD structures</span>
<span class="comments">;             containing ENVISAT Modified Julian Day values</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL PARAMETERS</span>
<span class="comments">;     YEAR     Output array containing year</span>
<span class="comments">;     JDAY     Output array containing Julian day, defined as the</span>
<span class="comments">;              fractional day of the year, starting at 1.0 at the</span>
<span class="comments">;              beginning of the 1st January</span>
<span class="comments">;    /INTEGER  Return integer part of Julian day only</span>
<span class="comments">;</span>
<span class="comments">; Start with first day of year -------------------------------------</span>
<span class="comments">;</span>
  Days = [0, 366, 731, 1096, 1461, 1827, 2192, 2557, 2922, 3288]
<span class="comments">;</span>
<span class="comments">; Force input array to be 1D ---------------------------------------</span>
<span class="comments">;</span>
  s = SIZE(MJD)
  n = s[s[0] + 2]
  M = REFORM(MJD, n)
<span class="comments">;</span>
<span class="comments">; The interesting stuff -------------------------------------------</span>
<span class="comments">;</span>
  One = 1 + INTARR(10)              <span class="comments">; TRANSPOSE + INTARR force D to</span>
  D = TRANSPOSE(Days[*, INTARR(n)]) <span class="comments">; a 2D array for all MJD sizes</span>
  Year = FIX(1999 + ((M.DAY # One) GE D) # One)
  JDay = 1 + M.DAY - Days[Year - 2000]
  IF NOT KEYWORD_SET(Integer) THEN $
    JDay = JDay + (1000000ULL * M.SECOND + M.MICROSECOND) / 8.64d10
<span class="comments">;</span>
<span class="comments">; Unwind output arrays to conform to the input array dimensions ---</span>
<span class="comments">;</span>
  Year = REFORM(Year, s[1:s[0]], /OVERWRITE)
  JDay = REFORM(JDay, s[1:s[0]], /OVERWRITE)
END



PRO ENVISAT_MJD_TO_TIME, MJD, DATE, TIME, DECIMAL_PLACES=DP
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.1  TJN  15-NOV-2002  Tinker with formatting statements.</span>
<span class="comments">;     1.0  TJN  25-OCT-2002  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Given an ENVISAT Modified Julian Day (MJD) scalar or 1D array,</span>
<span class="comments">;     returns string scalars or arrays containing date (DD-MMM-YYYY)</span>
<span class="comments">;     and time (HH:MM:SS[.SSSSSS]), both rounded to DECIMAL_PLACES</span>
<span class="comments">;     seconds.</span>
<span class="comments">;</span>
<span class="comments">; MANDATORY PARAMETERS</span>
<span class="comments">;     MJD     Input scalar or array of ENVISAT_MJD structures</span>
<span class="comments">;             containing ENVISAT Modified Julian Day values</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL PARAMETERS</span>
<span class="comments">;     DATE            String scalar or array containing MJD date</span>
<span class="comments">;     TIME            String scalar or array containing MJD time</span>
<span class="comments">;     DECIMAL_PLACES  Number of seconds decimal places (0-6, default:3)</span>
<span class="comments">;</span>
<span class="comments">; Build time string --------------------------------------------------</span>
<span class="comments">;</span>
  IF (N_ELEMENTS(DP) GT 0) THEN Place = (0 > ROUND(DP)) &lt<span class="comments">; 6 ELSE Place = 3</span>
  Div = 10L ^ Place & Div6 = 1000000L / Div

  x = (1000000LL * MJD.SECOND + MJD.MICROSECOND + Div6 / 2) / Div6
  Thou   =  x MOD Div  & x = x / Div
  Second =  x MOD 60   & x = x / 60
  Minute =  x MOD 60   & x = x / 60
  Hour   =  x MOD 24

  Time = STRING(Hour,  FORMAT='(I2.2)') + $
    STRING(Minute, FORMAT='(":",I2.2)') + $
    STRING(Second, FORMAT='(":",I2.2)')

  IF (Place GT 0) THEN BEGIN
    P = STRTRIM(Place, 2)
    Format = '(".",I' + P + '.' + P + ')'
    Time = Time + STRING(Thou, FORMAT=Format)
  ENDIF
<span class="comments">;</span>
<span class="comments">; Build time string --------------------------------------------------</span>
<span class="comments">;</span>
  Name = ['BAD', $
    'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', $
    'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'  $
  ]

  Wrap = MJD & Wrap.Day = Wrap.Day + (x EQ 24)
  ENVISAT_MJD_TO_JDAY, Wrap, Year, JDay, /INTEGER
  ENVISAT_JDAY_TO_DAY, Year, JDay, Month, Day

  Date = STRING(Day, FORMAT='(I2.2)') + $
    STRING(Name[Month], FORMAT='("-",A3)') + $
    STRING(Year, FORMAT='("-",I4.4)')
END



FUNCTION ENVISAT_READ_DS, UNIT, DSD, RECORD, OFFSET=OFFSET, SIZE=SIZE
<span class="comments">;</span>
<span class="comments">; VERSION</span>
<span class="comments">;     1.0  TJN  09-JAN-2003  Original</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION</span>
<span class="comments">;     Reads in any ENVISAT data set or, optionally, a subsection</span>
<span class="comments">;     of the data set. If any supplied values of OFFSET and SIZE</span>
<span class="comments">;     describe a segment that extends beyond the dataset, the</span>
<span class="comments">;     returned array is truncated at the data set boundaries. If</span>
<span class="comments">;     the required segment does not overlap the data set then the</span>
<span class="comments">;     error value -1 is returned.</span>
<span class="comments">;</span>
<span class="comments">; MANDATORY PARAMETERS</span>
<span class="comments">;     UNIT     File unit number</span>
<span class="comments">;     DSD      Data Set Descriptor specifying the required</span>
<span class="comments">;              Measurement Data Set</span>
<span class="comments">;     RECORD   Prototype data set record structure</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL PARAMETERS</span>
<span class="comments">;     OFFSET   Starting record number (default: 0)</span>
<span class="comments">;     SIZE     Number of records returned (default: To end of DS)</span>
<span class="comments">;</span>
<span class="comments">; Code starts here with input conditions -------------------------</span>
<span class="comments">;</span>
  IF NOT KEYWORD_SET(Offset) THEN Offset = 0L
  IF NOT KEYWORD_SET(Size) THEN Size = DSD.NUM_DSR - Offset
<span class="comments">;</span>
<span class="comments">; Skip out if no valid data --------------------------------------</span>
<span class="comments">;</span>
  IF (Offset GE DSD.NUM_DSR) OR (Offset + Size LE 0) THEN RETURN, -1
<span class="comments">;</span>
<span class="comments">; Calculate (truncated) offset and size --------------------------</span>
<span class="comments">;</span>
  i = Offset > 0
  n = ((Size + Offset) &lt<span class="comments">; DSD.NUM_DSR) - i</span>
<span class="comments">;</span>
<span class="comments">; Move to start point --------------------------------------------</span>
<span class="comments">;</span>
  POINT_LUN, Unit, DSD.DS_OFFSET + i * DSD.DSR_SIZE
<span class="comments">;</span>
<span class="comments">; Copy out coefficients ------------------------------------------</span>
<span class="comments">;</span>
  DS = REPLICATE(Record, n)
  READU, Unit, DS
  RETURN, DS
END
</code>
    </div>
  </body>
</html>