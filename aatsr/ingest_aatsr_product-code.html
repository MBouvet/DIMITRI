<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:42 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>ingest_aatsr_product.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="ingest_aatsr_product.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
FUNCTION INGEST_AATSR_PRODUCT,IFILES,INPUT_FOLDER=INPUT_FOLDER,ICOORDS=ICOORDS,$
         ENDIAN_SZE=ENDIAN_SIZE,COLOUR_TABLE=COLOUR_TABLE,$
         PLOT_XSIZE=PLOT_XSIZE,PLOT_YSIZE=PLOT_YSIZE,NO_ZBUFF=NO_ZBUFF,NO_QUICKLOOK=NO_QUICKLOOK,$
         VERBOSE=VERBOSE
    
 <span class="comments">;+</span>
 <span class="comments">; :Description:</span>
 <span class="comments">;   ingests aatsr l1b data into dimitri database. multiple product</span>
 <span class="comments">;   extraction is available but it expects all files to be the same region/processing.</span>
 <span class="comments">;   outputs quicklook images, updates database and appends data to sav file for</span>
 <span class="comments">;   specified region and processing.</span>
 <span class="comments">;</span>
 <span class="comments">; :Name:</span>
 <span class="comments">;      INGEST_AATSR_PRODUCT</span>

 <span class="comments">; :Calling_sequence:</span>
 <span class="comments">;      RES = INGEST_AATSR_PRODUCT(IFILES)</span>
 <span class="comments">;</span>
 <span class="comments">;</span>
 <span class="comments">; :Params:</span>
 <span class="comments">;      IFILES : in, required, type=string or string array</span>
 <span class="comments">;        a string or string array of the full path filenames of products for ingestion.</span>
 <span class="comments">;</span>
 <span class="comments">; :Keywords:</span>
 <span class="comments">;      INPUT_FOLDER:  </span>
 <span class="comments">;        a string containing the full path of the 'input' folder, if not provided then it is derived from the filename</span>
 <span class="comments">;</span>
 <span class="comments">;      ICOORDS:            </span>
 <span class="comments">;        a four element floating-point array containing the north, south, east and west coordinates of the roi, e.g [50.,45.,10.,0.]</span>
 <span class="comments">;</span>
 <span class="comments">;      NB_PIX_THRESHOLD:   </span>
 <span class="comments">;        number of pixels within roi to be accepted</span>
 <span class="comments">;</span>
 <span class="comments">;      ENDIAN_SZE:         </span>
 <span class="comments">;        machine endian size (0: little, 1: big), if not provided then computed.</span>
 <span class="comments">;</span>
 <span class="comments">;      COLOUR_TABLE:       </span>
 <span class="comments">;        user defined idl colour table index (default is 39)</span>
 <span class="comments">;</span>
 <span class="comments">;      PLOT_XSIZE:         </span>
 <span class="comments">;        width of generated plots (default is 700px)</span>
 <span class="comments">;</span>
 <span class="comments">;      PLOT_YSIZE:         </span>
 <span class="comments">;        height of generated plots (default is 400px)</span>
 <span class="comments">;</span>
 <span class="comments">;      NO_ZBUFF:           </span>
 <span class="comments">;        if set then plots are generated in windows and not wihtin the z-buffer.</span>
 <span class="comments">;</span>
 <span class="comments">;      NO_QUICKLOOK: </span>
 <span class="comments">;         IF SET THEN QUICKLOOKS ARE NOT GENERATED FOR IFILES.</span>
 <span class="comments">;</span>
 <span class="comments">;      VERBOSE: </span>
 <span class="comments">;        PROCESSING STATUS OUTPUTS</span>
 <span class="comments">;</span>
 <span class="comments">; </span>
 <span class="comments">; :Returns:</span>
 <span class="comments">;      STATUS  - 1: no errors reported, (-1) or 0: errors during ingestion</span>
 <span class="comments">;</span>
 <span class="comments">; :History:</span>
 <span class="comments">;                      M BOUVET  - PROTOTYPE DIMITRI VERSION</span>
 <span class="comments">;        08 DEC 2010 - C KENT    - DIMITRI-2 V1.0</span>
 <span class="comments">;        08 DEC 2010 - C KENT    - UPDATED REFLECTANCE CALCULATION SECTION</span>
 <span class="comments">;        20 DEC 2010 - C KENT    - MINOR CHANGES TO COMMENTS</span>
 <span class="comments">;        07 JAN 2011 - C KENT    - UPDATED ROI PIXEL RECORDING DUE TO MULTIPLE ANGLES</span>
 <span class="comments">;        10 JAN 2011 - C KENT    - CHANGED SAVED OUTPUT VARIABLE TO SENSOR_L1B_REF</span>
 <span class="comments">;        12 JAN 2011 - C KENT    - OUTPUT RGB QUICKLOOKS AS DEFUALT, UPDATED OUTPUT DATA</span>
 <span class="comments">;                                  WITH SAA AND VAA (REMOVED RAA)</span>
 <span class="comments">;        21 MAR 2011 - C KENT    - MODIFIED FILE DEFINITION TO USE GET_DIMITRI_LOCATION</span>
 <span class="comments">;        22 MAR 2011 - C KENT    - ADDED CONFIGURAITON FILE DEPENDENCE</span>
 <span class="comments">;        01 JUL 2011 - C KENT    - ADDED ANGLE CORRECTOR</span>
 <span class="comments">;        04 JUL 2011 - C KENT    - ADDED AUX INFO TO OUTPUT SAV</span>
 <span class="comments">;        12 JUL 2011 - C KENT    - FIXED LAT/LON AND ANGLE EXTRACTION BUG</span>
 <span class="comments">;        14 JUL 2011 - C KENT    - UPDATED TIME EXTRACTION SECTION</span>
 <span class="comments">;        12 SEP 2011 - C KENT    - ADDED NETCDF OUTPUT STRUCTURE</span>
 <span class="comments">;        08 MAR 2012 - C KENT    - ADDED ROI COVERAGE</span>
 <span class="comments">;</span>
 <span class="comments">; :File_comments:</span>
 <span class="comments">;    :VALIDATION HISTORY:</span>
 <span class="comments">;        08 DEC 2010 - C KENT    - WINDOWS 32BIT MACHINE IDL 7.1: COMPILATION AND EXECUTION</span>
 <span class="comments">;                                  SUCCESSFUL. OPERATION TESTED MULTIPLE OPTIONS ON MULTIPLE</span>
 <span class="comments">;                                  PRODUCTS</span>
 <span class="comments">;        12 APR 2011 - C KENT    - LINUX 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL</span>
 <span class="comments">;-</span>

<span class="comments">;------------------------</span>
<span class="comments">; KEYWORD PARAMETER CHECK - NOTE, ASSUMES ALL PRODUCT ARE RELATED TO THE SAME REGION/PROCESSING</span>

  IF STRCMP(STRING(IFILES[0]),'') THEN BEGIN
    PRINT, 'AATSR L1B INGEST: ERROR, NO INPUT FILES PROVIDED, RETURNING...'
    RETURN,-1
  ENDIF  
  IF N_ELEMENTS(INPUT_FOLDER) EQ 0 THEN INPUT_FOLDER = GET_DIMITRI_LOCATION('INPUT')

  DELIM = GET_DIMITRI_LOCATION('DL')
  TEMP = STRSPLIT(IFILES[0],DELIM,/EXTRACT)
 
  TEMP_INF  = WHERE(STRCMP(TEMP,'Input') EQ 1)
  TEMP_INF  = TEMP_INF(N_ELEMENTS(TEMP_INF)-1)
  IREGION   = TEMP[TEMP_INF+1]
  IREGION   = STRMID(IREGION,5,STRLEN(IREGION)) 
  SENSOR    = TEMP[TEMP_INF+2]
  IPROC     = TEMP[TEMP_INF+3]
  IPROC     = STRMID(IPROC,5,STRLEN(IPROC)) 
  CFIG_DATA = GET_DIMITRI_CONFIGURATION()
  ATS_SITE_TYPE = GET_SITE_TYPE(IREGION,VERBOSE=VERBOSE)
  
  IF N_ELEMENTS(ICOORDS) EQ 0 THEN BEGIN
    PRINT, 'AATSR L1B INGEST: NO ROI COORDINATES PROVIDED, USING DEFAULT OF [90.,-90,180.0,-180.0]'
    ICOORDS = [90.,-90.,180.0,-180.0]
  ENDIF
  IF N_ELEMENTS(COLOUR_TABLE) EQ 0 THEN BEGIN
    PRINT, 'AATSR L1B INGEST: NO COLOR_TABLE SET, USING DEFAULT OF 39'
    COLOUR_TABLE = CFIG_DATA.(1)[2]
  ENDIF
  IF N_ELEMENTS(PLOT_XSIZE) EQ 0 THEN BEGIN
    PRINT, 'AATSR L1B INGEST: PLOT_XSIZE NOT SET, USING DEFAULT OF 700'
    PLOT_XSIZE = CFIG_DATA.(1)[0]
  ENDIF
  IF N_ELEMENTS(PLOT_YSIZE) EQ 0 THEN BEGIN
    PRINT, 'AATSR L1B INGEST: PLOT_YSIZE NOT SET, USING DEFAULT OF 400'
    PLOT_YSIZE = CFIG_DATA.(1)[1]
  ENDIF  

  DRIFT_TABLE = GET_DIMITRI_LOCATION('AATSR_DRIFT')
  DRIFT_PATH  = GET_DIMITRI_LOCATION('AUX')
  TEMP = STRSPLIT(DRIFT_TABLE,DELIM,/EXTRACT)
  DRIFT_FILE  =TEMP[N_ELEMENTS(TEMP)-1]
    
  TEMP = FILE_INFO(DRIFT_TABLE)
  IF TEMP.EXISTS EQ 0 THEN BEGIN
    PRINT,'AATSR L1B INGEST: ERROR, DRIFT TABLE NOT FOUND'
    RETURN,-1
  ENDIF

<span class="comments">;------------------------------------------------</span>
<span class="comments">; READ THE DRIFT LUT</span>
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: READING AATSR DRIFT TABLE'
  DRIFT_TABLE_IN=AATSR_READ_DRIFT_TABLE(DRIFT_TABLE, PATH=DRIFT_PATH, FILE=DRIFT_FILE)

<span class="comments">;------------------------------------------------</span>
<span class="comments">; IF ENDIAN SIZE NOT PROVIDED THEN GET VALUE</span>

   IF N_ELEMENTS(ENDIAN_SIZE) EQ 0 THEN BEGIN
    IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: NO ENDIAN SIZE PROVIDED, RETRIEVING...'
      ENDIAN_SIZE = GET_ENDIAN_SIZE(VERBOSE=VERBOSE)
  ENDIF

<span class="comments">;------------------------</span>
<span class="comments">; DEFINE OUTPUT</span>

  OUTPUT_SAV = STRING(INPUT_FOLDER+DELIM+'Site_'+IREGION+DELIM+SENSOR+DELIM+'Proc_'+IPROC+DELIM+SENSOR+'_TOA_REF.dat')
  NCDF_FILENAME = STRING(INPUT_FOLDER+DELIM+'Site_'+IREGION+DELIM+SENSOR+DELIM+'Proc_'+IPROC+DELIM+IREGION+'_'+SENSOR+'_Proc_'+IPROC+'.nc')

<span class="comments">;------------------------</span>
<span class="comments">; GET NUMBER OF IFILES </span>

  NB_FILES = N_ELEMENTS(IFILES)

<span class="comments">;-----------------------------------------------</span>
<span class="comments">; GET THE DATABASE STRUCTURE</span>

  DB_DATA = GET_DIMITRI_TEMPLATE(NB_FILES,/DB)
  
<span class="comments">;-----------------------------------------------  </span>
<span class="comments">; ADD DATA OF INGESTION TO DB_DATA</span>

  TEMP = SYSTIME()
  TEMP = STRMATCH(STRMID(TEMP,8,1),' ') ? '0'+STRUPCASE(STRING(STRMID(TEMP,9,1)+'-'+STRMID(TEMP,4,3)+'-'+STRMID(TEMP,20,4))) : STRUPCASE(STRING( STRMID(TEMP,8,2)+'-'+STRMID(TEMP,4,3)+'-'+STRMID(TEMP,20,4)))
  DB_DATA.DIMITRI_DATE = TEMP 

<span class="comments">;-----------------------------------------------</span>
<span class="comments">; ADD REGION, SENSOR AND PROC VERSION TO DB_DATA</span>

  DB_DATA.REGION = IREGION
  DB_DATA.SENSOR = SENSOR
  DB_DATA.PROCESSING_VERSION = IPROC
  
<span class="comments">;----------------------------------</span>
<span class="comments">; DEFINE AATSR SPECIFIC PARAMETERS </span>

  NB_BANDS = SENSOR_BAND_INFO('AATSR') 
  NB_BANDS = NB_BANDS[0]
  FNAME_STR = 'ATS_TOA_1'
  AATSR_DIRC = ['NADIR', 'FWARD']
  NB_DIRECTIONS = N_ELEMENTS(AATSR_DIRC)

<span class="comments">;----------------------------------</span>
<span class="comments">; DEFINE THE STATISTICAL ARRAYS</span>

	BADVAL = -999.0
	ROI_AVG_TOA_REF  = FLTARR(NB_BANDS,2*NB_FILES)
	ROI_STD_TOA_REF  = FLTARR(NB_BANDS,2*NB_FILES)
	NB_ROI_PX        = FLTARR(2*NB_FILES)
	GOOD_RECORD      = MAKE_ARRAY(2*NB_FILES,/INTEGER,VALUE=0)
	IFILE_DATE 	     = DBLARR(5,2*NB_FILES)<span class="comments">;CONTAINS YEAR,MONTH,DAY,DOY,DECIMEL_YEAR</span>
	IFILE_VIEW 	     = DBLARR(4,2*NB_FILES)<span class="comments">;CONTAINS SENSOR ZENITH,SENSOR AZIMUTH,SOLAR ZENITH,SOLAR AZIMUTH</span>
  IFILE_AUX        = FLTARR(12,2*NB_FILES)<span class="comments">;CONTAINS OZONE,PRESSURE,RELHUMIDITY,WIND_ZONAL,WIND_MERID, AND WVAP (MU AND SIGMA)</span>
  
  IF KEYWORD_SET(VERBOSE) THEN BEGIN
    PRINT, 'AATSR L1B INGEST: DEFINITION OF OUTPUT ARRAYS:'
    HELP, ROI_AVG_TOA_REF,ROI_STD_TOA_REF,NB_ROI_PX,GOOD_RECORD,IFILE_DATE,IFILE_VIEW
  ENDIF

<span class="comments">;---------------------------------</span>
<span class="comments">; ADD DATA TO NETCDF OUTPUT STRUCTURE</span>

  NCDF_OUT = GET_DIMITRI_EXTRACT_NCDF_DATA_STRUCTURE(NB_FILES,NB_BANDS,2)
  NCDF_OUT.ATT_FNAME  = 'Site_'+IREGION+'_'+SENSOR+'_'+'Proc_'+IPROC+'.nc'
  NCDF_OUT.ATT_TOOL   = GET_DIMITRI_LOCATION('TOOL')
  NCDF_OUT.ATT_SENSOR = SENSOR
  NCDF_OUT.ATT_PROCV  = IPROC
  NCDF_OUT.ATT_PRES   = STRTRIM(STRING(SENSOR_PIXEL_SIZE(SENSOR)),2)+' KM'
  NCDF_OUT.ATT_NBANDS = STRTRIM(STRING(NB_BANDS),2)
  NCDF_OUT.ATT_NDIRS  = STRTRIM(STRING(NB_DIRECTIONS),2)
  NCDF_OUT.ATT_SITEN  = IREGION
  NCDF_OUT.ATT_SITEC  = STRJOIN(STRTRIM(STRING(ICOORDS),2),' ')
  NCDF_OUT.ATT_SITET  = ATS_SITE_TYPE

<span class="comments">;----------------------------------</span>
<span class="comments">; START MAIN LOOP OVER EACH IFILE</span>

  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: STARTING INGESTION LOOP ON AATSR PRODUCTS'
	FOR IN_FNAME=0l,NB_FILES-1 DO BEGIN<span class="comments">; IN_FNAME IS RESERVED FOR LOOPS WITHIN THE INGESTION ROUTINES</span>

    TEMP = STRSPLIT(IFILES[IN_FNAME],DELIM,/EXTRACT)
    DB_DATA.FILENAME[IN_FNAME] = TEMP[N_ELEMENTS(TEMP)-1]

<span class="comments">;------------------------------------------</span>
<span class="comments">; GENERATE A QUICKLOOK WITH THE ROI OVERLAID</span>
  
    IF N_ELEMENTS(NO_QUICKLOOK) EQ 0 THEN BEGIN
      IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: GENERATE QUICKLOOK OF PRODUCT'
      IF FIX(CFIG_DATA.(1)[3]) EQ 1 THEN QL_STATUS =  GET_AATSR_QUICKLOOK(IFILES[IN_FNAME],/ROI,/RGB,ICOORDS=ICOORDS,QL_QUALITY=QL_QUALITY,ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE) $
        ELSE QL_STATUS =  GET_AATSR_QUICKLOOK(IFILES[IN_FNAME],/ROI,ICOORDS=ICOORDS,QL_QUALITY=QL_QUALITY,ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)
      
      IF KEYWORD_SET(VERBOSE) THEN $
        IF QL_STATUS EQ -1 THEN PRINT, 'AATSR L1B INGEST: QUICKLOOK GENERATION FAILED - ',IFILES[IN_FNAME] $
          ELSE PRINT, 'AATSR L1B INGEST: QUICKLOOK GENERATION SUCCESS' 
    ENDIF   

<span class="comments">;------------------------------------------</span>
<span class="comments">; RETRIEVE AUX DATA FILENAMES FOR DB_DATA</span>

	 TEMP = GET_AATSR_AUX_FILES(IFILES[IN_FNAME],VERBOSE=VERBOSE)	
   
	 DB_DATA.AUX_DATA_1[IN_FNAME] = TEMP[0]
   DB_DATA.AUX_DATA_2[IN_FNAME] = TEMP[1] 
   DB_DATA.AUX_DATA_3[IN_FNAME] = TEMP[2] 
   DB_DATA.AUX_DATA_4[IN_FNAME] = TEMP[3] 
   DB_DATA.AUX_DATA_5[IN_FNAME] = TEMP[4] 
   DB_DATA.AUX_DATA_6[IN_FNAME] = TEMP[5] 
   DB_DATA.AUX_DATA_7[IN_FNAME] = TEMP[6] 
   DB_DATA.AUX_DATA_8[IN_FNAME] = TEMP[7] 
   DB_DATA.AUX_DATA_9[IN_FNAME] = TEMP[8] 
   DB_DATA.AUX_DATA_10[IN_FNAME] = TEMP[9] 
        
<span class="comments">;----------------------------------</span>
<span class="comments">; RETRIEVE DATE INFORMATION</span>

   IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: RETRIEVING DATE INFORMATION'
   STR_POS 		            = STRPOS(IFILES[IN_FNAME],FNAME_STR, /REVERSE_SEARCH)
   IFILE_DATE[0,2*IN_FNAME:2*IN_FNAME+1]	= STRMID(IFILES[IN_FNAME],STR_POS+14,4)+0.
   IFILE_DATE[1,2*IN_FNAME:2*IN_FNAME+1]	= STRMID(IFILES[IN_FNAME],STR_POS+18,2)+0.
   IFILE_DATE[2,2*IN_FNAME:2*IN_FNAME+1]	= STRMID(IFILES[IN_FNAME],STR_POS+20,2)+0.
   IF FLOAT(IFILE_DATE[0,2*IN_FNAME]) MOD 4 EQ 0 THEN DIY = 366.0 ELSE DIY = 365.0
     
   DATE_HR =STRMID(IFILES[IN_FNAME],STR_POS+23,2) 
   DATE_MIN =STRMID(IFILES[IN_FNAME],STR_POS+25,2) 
   DATE_SEC =STRMID(IFILES[IN_FNAME],STR_POS+27,2) 
   
   THR = FLOAT(STRMID(IFILES[IN_FNAME],STR_POS+23,2))
   TMM = FLOAT(STRMID(IFILES[IN_FNAME],STR_POS+25,2))
   TSS = FLOAT(STRMID(IFILES[IN_FNAME],STR_POS+27,2))
   TTIME = DOUBLE((THR/(DIY*24.))+(TMM/(DIY*60.*24.))+TSS/(DIY*60.*60.*24.))
      
   IFILE_DATE[3,2*IN_FNAME:2*IN_FNAME+1]	= JULDAY(IFILE_DATE[1,2*IN_FNAME],IFILE_DATE[2,2*IN_FNAME],IFILE_DATE[0,2*IN_FNAME])-JULDAY(1,0,IFILE_DATE[0,2*IN_FNAME])
   IFILE_DATE[4,2*IN_FNAME:2*IN_FNAME+1]  = double(IFILE_DATE[0,2*IN_FNAME])+double(DOUBLE(IFILE_DATE[3,2*IN_FNAME])/DIY)+double(TTIME)

<span class="comments">;----------------------------------</span>
<span class="comments">; ADD DATE INFORMATION TO DB_DATA</span>

   DB_DATA.YEAR[IN_FNAME] = IFILE_DATE[0,2*IN_FNAME]
   DB_DATA.MONTH[IN_FNAME] = IFILE_DATE[1,2*IN_FNAME]
   DB_DATA.DAY[IN_FNAME] = IFILE_DATE[2,2*IN_FNAME]
   DB_DATA.DOY[IN_FNAME] = IFILE_DATE[3,2*IN_FNAME]
   DB_DATA.DECIMAL_YEAR[IN_FNAME] = IFILE_DATE[4,2*IN_FNAME]
	
<span class="comments">;----------------------------------</span>
<span class="comments">; LOOP OVER BOTH DIRECTIONS	</span>

    TEMP_AUTO_CS = DOUBLE(-1.0)	
    TEMP_PIX = -1	
	  FOR IN_DIR = 0,NB_DIRECTIONS-1 DO BEGIN

<span class="comments">;----------------------------------</span>
<span class="comments">; RETRIEVE INPUT FILE L1B RADIANCE - BASE PIXEL VALIDITY ON B0</span>

    IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: RETRIEVING REFLECTANCE INFORMATION'
    IFILE_TOA = GET_AATSR_L1B_REFLECTANCE(IFILES[IN_FNAME],0,AATSR_DIRC[IN_DIR],ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)
    TOA_DIMS = SIZE(IFILE_TOA)

<span class="comments">;----------------------------------</span>
<span class="comments">; RETRIEVE INPUT FILE GEOLOCATION</span>

    IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: RETRIEVING GEOLOCATION INFORMATION'
		IFILE_GEO = GET_AATSR_LAT_LON(IFILES[IN_FNAME],AATSR_DIRC[IN_DIR],TOA_DIMS[2],TOA_DIMS[1],VERBOSE=VERBOSE)

<span class="comments">;------------------------------------------</span>
<span class="comments">; RETRIEVE INDEX OF NOMINAL DATA WITHIN ROI</span>

    IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: RETRIEVING INDEX OF PIXELS WITHIN ROI'
		ROI_INDEX = WHERE($
			  	IFILE_GEO.LAT LT ICOORDS[0] AND $
			  	IFILE_GEO.LAT GT ICOORDS[1] AND $
			  	IFILE_GEO.LON LT ICOORDS[2] AND $
			  	IFILE_GEO.LON gT ICOORDS[3] AND $
			  	IFILE_TOA GT 0.0    , $
          NB_PIX $
			  	)
	    	
    IF NB_PIX GT TEMP_PIX THEN TEMP_PIX = NB_PIX 
    DB_DATA.NUM_ROI_PX[IN_FNAME] = TEMP_PIX 
    IF TEMP_PIX LT 1 THEN DB_DATA.NUM_ROI_PX[IN_FNAME] = -1

<span class="comments">;-----------------------------------------</span>
<span class="comments">; CHECK ROI COVERAGE</span>

    IF nb_pix GT 5 THEN BEGIN
      TROI = CHECK_ROI_COVERAGE(IFILE_GEO.LAT,IFILE_GEO.LON,ROI_INDEX,ICOORDS,VERBOSE=VERBOSE)
      IF TROI GT DB_DATA.ROI_COVER[IN_FNAME] THEN DB_DATA.ROI_COVER[IN_FNAME]=TROI
    ENDIF

<span class="comments">;-----------------------------------------</span>
<span class="comments">; SET INITIAL VALUES OF CLOUD SCREENING</span>

    DB_DATA.AUTO_CS[IN_FNAME] = -1.0
    DB_DATA.MANUAL_CS[IN_FNAME] = -1

<span class="comments">;-----------------------------------------</span>
<span class="comments">; STORE DATE IN NETCDF STRUCTURE</span>

    NCDF_OUT.VAR_PNAME[IN_FNAME]  = DB_DATA.FILENAME[IN_FNAME] 
    NCDF_OUT.VAR_PTIME[IN_FNAME]  = STRMID(IFILES[IN_FNAME],STR_POS+14,8)+' '+DATE_HR+':'+DATE_MIN+':'+DATE_SEC
    NCDF_OUT.VAR_DTIME[IN_FNAME]  = DB_DATA.DECIMAL_YEAR[IN_FNAME]

<span class="comments">;-----------------------------------------</span>
<span class="comments">; IF NUMBER OF PIXELS IN ROI LESS THAN </span>
<span class="comments">; DEFINED THRESHOLD THEN DO NOT RETRIEVE </span>
<span class="comments">; TOA REFLECTANCE</span>

		IF ROI_INDEX[0] EQ -1 THEN BEGIN
      IFILE_VIEW[*,2*IN_FNAME+IN_DIR]= BADVAL
      IFILE_AUX[*,2*IN_FNAME+IN_DIR] = BADVAL
      ROI_AVG_TOA_REF(*,2*IN_FNAME+IN_DIR) = BADVAL
      ROI_STD_TOA_REF(*,2*IN_FNAME+IN_DIR) = BADVAL
      GOTO, NO_ROI
		ENDIF
		
		GOOD_RECORD[IN_FNAME]=1
		
<span class="comments">;------------------------------------------</span>
<span class="comments">; DEFINE ARRAY TO HOLD CS RHO</span>

    CS_RHO = FLTARR(NB_PIX,NB_BANDS)

<span class="comments">;------------------------------------------</span>
<span class="comments">; RETRIEVE VIEWING GEOMETRIES</span>

    IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: RETRIEVING VIEWING GEOMETRIES'
    TEMP = GET_AATSR_VIEWING_GEOMETRIES(IFILES[IN_FNAME],AATSR_DIRC[IN_DIR],TOA_DIMS[2],TOA_DIMS[1],VERBOSE=VERBOSE)
    TEMP_ANGLES = DIMITRI_ANGLE_CORRECTOR(TEMP.VZA,TEMP.VAA,TEMP.SZA,TEMP.SAA,VERBOSE=VERBOSE)    
    
    IFILE_VIEW[0,2*IN_FNAME+IN_DIR]=MEAN(TEMP_ANGLES.VZA[ROI_INDEX])
    IFILE_VIEW[1,2*IN_FNAME+IN_DIR]=MEAN(TEMP_ANGLES.VAA[ROI_INDEX])
    IFILE_VIEW[2,2*IN_FNAME+IN_DIR]=MEAN(TEMP_ANGLES.SZA[ROI_INDEX])
    IFILE_VIEW[3,2*IN_FNAME+IN_DIR]=MEAN(TEMP_ANGLES.SAA[ROI_INDEX])
    TEMP_SZA = TEMP_ANGLES.SZA
    TEMP=0
    TEMP_ANGLES=0

<span class="comments">;----------------------------------------</span>
<span class="comments">; SET AUX INFORMATION AS MISSING</span>

    IFILE_AUX[*,2*IN_FNAME+IN_DIR] = BADVAL

<span class="comments">;----------------------------------------</span>
<span class="comments">; COMPUTE TOA REFLECTANCE FOR EACH BAND </span>

    IFILE_TOA = 0
    IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: STARTING LOOP OVER EACH BAND'
		
		FOR IN_BAND=0,NB_BANDS-1 DO BEGIN
    
      IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: RETRIEVING RADIANCE FOR BAND -',IN_BAND
      TOA_REF=GET_AATSR_L1B_REFLECTANCE(IFILES[IN_FNAME],IN_BAND,AATSR_DIRC[IN_DIR],ENDIAN_SIZE=ENDIAN_SIZE,VERBOSE=VERBOSE)
	
<span class="comments">;---------------------------------------</span>
<span class="comments">; CORRECT RELFECTANCE FOR SZA</span>

      IF IN_BAND LE 3 THEN TOA_REF = TOA_REF*0.01/COS(TEMP_SZA*!DTOR)

<span class="comments">;---------------------------------------</span>
<span class="comments">; COMPUTE MEAN AND STANDARD DEVIATION OVER ROI</span>

      VALID = WHERE(TOA_REF[ROI_INDEX] GT 0.0,COUNT)
      IF COUNT EQ 0 THEN CONTINUE
      ROI_AVG_TOA_REF(IN_BAND,2*IN_FNAME+IN_DIR) = MEAN(TOA_REF(ROI_INDEX[VALID]))
      ROI_STD_TOA_REF(IN_BAND,2*IN_FNAME+IN_DIR) = STDDEV(TOA_REF(ROI_INDEX[VALID]))

<span class="comments">;---------------------------------------</span>
<span class="comments">; COMPUTE DRIFT CORRECTION</span>
     
      IF IN_BAND LE 3 THEN BEGIN
 
        OPENR, IN_LUN, IFILES[IN_FNAME], /GET_LUN, /SWAP_IF_LITTLE_ENDIAN
        AATSR_GET_HEADERS, IN_LUN, IN_MPH, IN_SPH, IN_DSD 
        GC1_FILENAME = IN_DSD[31].FILENAME
        VC1_FILENAME = IN_DSD[30].FILENAME
        ACQ_DATE = STRMID(IN_MPH.SENSING_START, 0, 20)
      
        TEMP_REF = ROI_AVG_TOA_REF(IN_BAND,2*IN_FNAME+IN_DIR)

<span class="comments">;---------------------------------------</span>
<span class="comments">; CORRECT 1.6 MICRON BAND</span>

        IF IN_BAND EQ 3 THEN TEMP_REF = AATSR_CORRECT_V16_NONLINEARITY(GC1_FILENAME, TEMP_REF)

<span class="comments">;---------------------------------------</span>
<span class="comments">; REMOVE CURRENT CORRECTIONS, APPLY NEW CORRECTIONS AND STORE DATA</span>

        TEMP_REF = AATSR_REMOVE_DRIFT_CORRECTION(VC1_FILENAME,ACQ_DATE, IN_BAND, TEMP_REF)
        TEMP_REF = AATSR_APPLY_DRIFT_CORRECTION(ACQ_DATE,IN_BAND,TEMP_REF,DRIFT_TABLE=DRIFT_TABLE)
        
        ROI_AVG_TOA_REF(IN_BAND,2*IN_FNAME+IN_DIR) = TEMP_REF

<span class="comments">;---------------------------------------</span>
<span class="comments">; CLOSE THE FILE</span>

        FREE_LUN,IN_LUN

<span class="comments">;---------------------------------------</span>
<span class="comments">; STORE REF IN CS ARRAY</span>
  
        SF = TEMP_REF/MEAN(TOA_REF(ROI_INDEX))
        CS_RHO[*,IN_BAND] = SF*TOA_REF(ROI_INDEX)
    
      ENDIF ELSE BEGIN<span class="comments">;DRIFT CORRECTION</span>
      CS_RHO[*,IN_BAND] = TOA_REF(ROI_INDEX)
      ENDELSE

<span class="comments">;-----------------------------------------</span>
<span class="comments">; STORE DATA IN NETCDF STRUCTURE</span>

      NCDF_OUT.VAR_VZA[IN_DIR,IN_FNAME]      = IFILE_VIEW[0,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_VAA[IN_DIR,IN_FNAME]      = IFILE_VIEW[1,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_SZA[IN_DIR,IN_FNAME]      = IFILE_VIEW[2,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_SAA[IN_DIR,IN_FNAME]      = IFILE_VIEW[3,2*IN_FNAME+IN_DIR]

      NCDF_OUT.VAR_PIX[IN_BAND,IN_FNAME,IN_DIR]      = COUNT
      NCDF_OUT.VAR_RHOMU[IN_BAND,IN_FNAME,IN_DIR]    = ROI_AVG_TOA_REF(IN_BAND,2*IN_FNAME+IN_DIR)
      NCDF_OUT.VAR_RHOSD[IN_BAND,IN_FNAME,IN_DIR]    = ROI_STD_TOA_REF(IN_BAND,2*IN_FNAME+IN_DIR)
      NCDF_OUT.VAR_OZONEMU[IN_FNAME]  = IFILE_AUX[0,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_OZONESD[IN_FNAME]  = IFILE_AUX[1,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_PRESSMU[IN_FNAME]  = IFILE_AUX[2,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_PRESSSD[IN_FNAME]  = IFILE_AUX[3,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_RHUMMU[IN_FNAME]   = IFILE_AUX[4,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_RHUMSD[IN_FNAME]   = IFILE_AUX[5,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_ZONALMU[IN_FNAME]  = IFILE_AUX[6,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_ZONALSD[IN_FNAME]  = IFILE_AUX[7,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_MERIDMU[IN_FNAME]  = IFILE_AUX[8,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_MERIDSD[IN_FNAME]  = IFILE_AUX[9,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_WVAPMU[IN_FNAME]   = IFILE_AUX[10,2*IN_FNAME+IN_DIR]
      NCDF_OUT.VAR_WVAPSD[IN_FNAME]   = IFILE_AUX[11,2*IN_FNAME+IN_DIR]


    IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: END OF LOOP ON BAND - ',IN_BAND
		ENDFOR<span class="comments">; END OF BAND ANALYSIS</span>

<span class="comments">;----------------------------------</span>
<span class="comments">; APPLY CLOUD SCREENING</span>
 
    CS_AATSR = DIMITRI_CLOUD_SCREENING(SENSOR,ATS_SITE_TYPE,CS_RHO,0,'LCCA',verbose=verbose)
    IF CS_AATSR[0] GT TEMP_AUTO_CS THEN TEMP_AUTO_CS = DOUBLE(CS_AATSR[0])

	NO_ROI:<span class="comments">; IF ROI IS NOT WITHIN THE PRODUCT </span>
	ENDFOR<span class="comments">; END OF LOOP ON DIRECTIONS</span>
	
	DB_DATA.AUTO_CS[IN_FNAME] = TEMP_AUTO_CS
  NCDF_OUT.VAR_CLOUD_AUT[IN_FNAME]  = TEMP_AUTO_CS
  NCDF_OUT.VAR_CLOUD_MAN[IN_FNAME]  = -1
  NCDF_OUT.VAR_ROI[IN_FNAME]        = DB_DATA.ROI_COVER[IN_FNAME]
	
	IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: END OF LOOP ON PRODUCT'
	ENDFOR<span class="comments">; END OF FILE ANALYSIS</span>

<span class="comments">;------------------------------------</span>
<span class="comments">; AMEND/SAVE DATA TO SAV FILE </span>

  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: DEFINING OUTPUT ARRAY'
  NUM_NON_REF = 5+12
  NB_COLS = NUM_NON_REF+2*(NB_BANDS)

	SENSOR_L1B_REF          = DBLARR(NB_COLS,2*NB_FILES)
  SENSOR_L1B_REF[0,*]     = IFILE_DATE[4,*] <span class="comments">;UPDATED FROM DAY OF YEAR TO DECIMEL YEAR</span>
  SENSOR_L1B_REF[1:4,*]   = IFILE_VIEW[*,*]
  SENSOR_L1B_REF[5:16,*]  = IFILE_AUX[*,*]
  SENSOR_L1B_REF[NUM_NON_REF:NUM_NON_REF+NB_BANDS-1,*]  = ROI_AVG_TOA_REF[*,*] 
  SENSOR_L1B_REF[NUM_NON_REF+NB_BANDS:NB_COLS-1,*] = ROI_STD_TOA_REF[*,*] 

  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: AMMENDING DATA TO OUTPUT SAV FILE'
	TEMP = FILE_INFO(OUTPUT_SAV)
	IF TEMP.EXISTS EQ 1 THEN BEGIN
	 TEMP_NEW = SENSOR_L1B_REF
   RESTORE,OUTPUT_SAV
   TEMP_OLD = SENSOR_L1B_REF
   RES_DIMS = SIZE(TEMP_OLD)
     
   SENSOR_L1B_REF = MAKE_ARRAY(NB_COLS,RES_DIMS[2]+2*NB_FILES,/DOUBLE)
   SENSOR_L1B_REF[*,0:RES_DIMS[2]-1] = TEMP_OLD
   SENSOR_L1B_REF[*,RES_DIMS[2]:RES_DIMS[2]+2*NB_FILES-1] = TEMP_NEW
           
 	ENDIF
	
	RES = SORT(SENSOR_L1B_REF[0,*])
  SENSOR_L1B_REF = SENSOR_L1B_REF[*,RES]
	SAVE,SENSOR_L1B_REF,FILENAME=OUTPUT_SAV

<span class="comments">;------------------------------------</span>
<span class="comments">; GENERATE PLOTS WITH NEW TIME SERIES DATA</span>

  RES = GET_AATSR_TIMESERIES_PLOTS(OUTPUT_SAV,COLOUR_TABLE=COLOUR_TABLE,PLOT_XSIZE=PLOT_XSIZE,PLOT_YSIZE=PLOT_YSIZE,VERBOSE=VERBOSE)

<span class="comments">;------------------------------------</span>
<span class="comments">; SAVE DATA TO NETCDF FILE</span>

  RES = DIMITRI_INTERFACE_EXTRACT_TOA_NCDF(NCDF_OUT,NCDF_FILENAME)  
  
<span class="comments">;------------------------------------</span>
<span class="comments">; AMEND DATA TO DATABASE</span>

  IF KEYWORD_SET(VERBOSE) THEN PRINT, 'AATSR L1B INGEST: SENDING DATA TO UPDATE DATABASE'
  RES = UPDATE_DIMITRI_DATABASE(DB_DATA,/SORT_DB,VERBOSE=VERBOSE)  
 
	RETURN,1 
END
</code>
    </div>
  </body>
</html>