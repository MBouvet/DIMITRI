<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:33 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsv_rraw.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsv_rraw.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSV_RRAW</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Read raw SAVE data from input block or file unit</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   DATA = CMSV_RRAW( BLOCK, POINTER, NELT, UNIT=UNIT, $</span>
<span class="comments">;                     STRING=STRING, LONG=LONG, BYTE=BYTE, TYPE=TYPE, $</span>
<span class="comments">;                     OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG )</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   This function reads raw integer or string data from an IDL SAVE</span>
<span class="comments">;   file.  This is the lowest level reading function in the library,</span>
<span class="comments">;   intended for developers who are investigating new and existing</span>
<span class="comments">;   SAVE file formats.</span>
<span class="comments">;</span>
<span class="comments">;   The primary use of this function will be to read raw integer and</span>
<span class="comments">;   string data from the input.  By default, a single value is read as</span>
<span class="comments">;   a scalar; however a vector of values can be read using the NELT</span>
<span class="comments">;   parameter.  Special keywords are provided for the common data</span>
<span class="comments">;   types STRING, LONG and BYTE.  Other integer types can be read</span>
<span class="comments">;   using the TYPE keyword.  Users who want to read the data from an</span>
<span class="comments">;   IDL variable should use CMSV_RDATA, which can handle</span>
<span class="comments">;   multidimensional data, as well as floating point and structure</span>
<span class="comments">;   data.</span>
<span class="comments">;</span>
<span class="comments">;   A secondary use of this function is to buffer the data in BLOCK.</span>
<span class="comments">;   This will ensure that BLOCK contains enough data to convert NELT</span>
<span class="comments">;   integers without reading from disk.  CMSV_RRAW itself does not</span>
<span class="comments">;   convert any values so the return value should be ignored.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; BLOCK, POINTER, OFFSET</span>
<span class="comments">;</span>
<span class="comments">;   This procedure can read data from a byte array, a file unit, or</span>
<span class="comments">;   both.  In fact, this procedure is designed to implement "lazy"</span>
<span class="comments">;   reading from a file, which is to say, it normally reads from a</span>
<span class="comments">;   byte array of data.  However, if the requested data goes beyond</span>
<span class="comments">;   the end of the byte array, more data is read from the file on</span>
<span class="comments">;   demand.  This way the user gets the benefit of fast memory access</span>
<span class="comments">;   for small reads, but guaranteed file access for large reads.</span>
<span class="comments">;</span>
<span class="comments">;   The terminology is as follows: BLOCK is a byte array which</span>
<span class="comments">;   represents a portion of, or an entire, IDL SAVE file.  The block</span>
<span class="comments">;   may be a cached portion of an on-disk file, or an entire in-memory</span>
<span class="comments">;   SAVE file.  POINTER is the current file pointer within BLOCK</span>
<span class="comments">;   (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a</span>
<span class="comments">;   POINTER value of 0 refers to the start of the block.  OFFSET is</span>
<span class="comments">;   the file offset of the 0th byte of BLOCK; thus "POINT_LUN,</span>
<span class="comments">;   OFFSET+POINTER" should point to the same byte as BLOCK[POINTER].</span>
<span class="comments">;   The following diagram shows the meanings for BLOCK, POINTER and</span>
<span class="comments">;   OFFSET schematically:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;                 0 &lt;-  OFFSET  -> |</span>
<span class="comments">;   FILE          |----------------|------*--------|---------></span>
<span class="comments">;</span>
<span class="comments">;   BLOCK                          |------*--------|</span>
<span class="comments">;                                  0      ^ POINTER</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK - a byte array, a cache of the SAVE file.  Users will</span>
<span class="comments">;           usually not access this array directly.  Users are advised</span>
<span class="comments">;           to clear BLOCK after calling POINT_LUN.</span>
<span class="comments">;</span>
<span class="comments">;   POINTER - a long integer, a pointer to the next byte to be read</span>
<span class="comments">;             from BLOCK.  CMSVLIB routines will automatically</span>
<span class="comments">;             advance the pointer.</span>
<span class="comments">;</span>
<span class="comments">;   NELT - optional parameter specifying the number of values to read.</span>
<span class="comments">;          If unspecified, then a scalar value is read and returned.</span>
<span class="comments">;          If specified, then a vector of NELT values is read and</span>
<span class="comments">;          returned.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   BUFFER - if set, CMSV_RRAW will ensure that BLOCK contains at</span>
<span class="comments">;            least NELT values without converting them.  The return</span>
<span class="comments">;            value should be ignored.  This keyword is ignored for</span>
<span class="comments">;            strings.</span>
<span class="comments">;</span>
<span class="comments">;   LONG - if set, the values are converted as LONG integers.</span>
<span class="comments">;</span>
<span class="comments">;   BYTE - if set, the values are converted as BYTEs.</span>
<span class="comments">;</span>
<span class="comments">;   STRING - if set, the values are converted as STRINGs.  Each string</span>
<span class="comments">;            may be of variable length.</span>
<span class="comments">;</span>
<span class="comments">;   TYPE - if none of the above keywords is set, then values of type</span>
<span class="comments">;          TYPE are read.  TYPE should be a string, one of 'BYTE',</span>
<span class="comments">;          'FIX', 'LONG', 'ULONG', 'LONG64', or 'ULONG64'.</span>
<span class="comments">;          If no type is specified then BYTEs are read.</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a file unit.  If a library routine reads to the end of</span>
<span class="comments">;          BLOCK, or if BLOCK is undefined, then this file UNIT will</span>
<span class="comments">;          be accessed for more data.  If undefined, then BLOCK must</span>
<span class="comments">;          contain the entire file in memory.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSET - the file offset of byte zero of BLOCK.  Default: 0</span>
<span class="comments">;            (OFFSET is used by this routine)</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, this keyword will contain 1 for success and</span>
<span class="comments">;            0 for failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return with a failure, this keyword will contain the</span>
<span class="comments">;            error condition as a string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 2000</span>
<span class="comments">;   Documented, 24 Jan 2001</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   NOTE: remember to modify CMSVLIB.PRO when changing library!</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsv_rraw.pro,v 1.7 2009/11/22 22:50:49 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

forward_function cmsv_rraw

<a id="cmsv_rbuf:source"></a>pro cmsv_rbuf, block, pointer, nbytes, unit=unit0, errmsg=errmsg, status=status

  if n_elements(pointer) EQ 0 then pointer = 0L

  RESTART_READ:

  <span class="comments">;; If enough bytes are already available then there is no problem,</span>
  <span class="comments">;; we simply return.  NOTE that, since we always try to read a large</span>
  <span class="comments">;; chunk of data, most of the calls to this routine return right</span>
  <span class="comments">;; here, and just insure that data is available.</span>

  if pointer+nbytes LE n_elements(block) then begin
      status = 1
      return
  endif

  <span class="comments">;; Attempt to read from the file unit.  Make sure the unit is defined</span>
  if n_elements(unit0) EQ 0 then begin
      errmsg = 'ERROR: CMSV_RRAW: end of block encountered ' + $
        'and UNIT is invalid)'
      status = 0
      return
  endif

  <span class="comments">;; Make sure the unit is open and readable.</span>
  unit = floor(unit0(0))
  fs = fstat(unit)
  on_ioerror, READ_ERROR
  if fs.open EQ 0 OR fs.read EQ 0 then begin
      READ_ERROR:
      errmsg = string(fs.name, fs.unit, $
                      format=('("ERROR: CMSV_RRAW: ",A0," (unit ",I0,'+$
                              '") is not open and readable")') )
      status = 0
      return
  endif

  <span class="comments">;; Read a larger block, but not more than the existing file size</span>
  bufsize = (pointer+nbytes-n_elements(block)) > 1024L
  bufsize = bufsize &lt<span class="comments">; (fs.size - fs.cur_ptr)</span>
  if bufsize LE 0 then begin
      errmsg = 'ERROR: CMSV_RRAW: end of file encountered'
      status = 0
      return
  endif

  <span class="comments">;; Read the unformatted raw byte data</span>
  buf = bytarr(bufsize)
  readu, unit, buf
  if n_elements(block) GT 0 then block = [temporary(block), temporary(buf)] $
  else block = [temporary(buf)]

  <span class="comments">;; Now that the block has been read, restart the read operation</span>
  goto, RESTART_READ
end

<a id="cmsv_rraw:source"></a>function cmsv_rraw, block, pointer, nelt0, unit=unit, buffer=buf, $
                    string=string, byte=byte, long=long, type=type0, $
                    status=status, errmsg=errmsg, offset=offset

  status = 0
  <span class="comments">;; Default processing</span>
  if n_elements(pointer) EQ 0 then pointer = 0L
  if n_elements(nelt0) EQ 0 then nelt = 1L else nelt = floor(nelt0(0))
  if nelt LE 0 then return, 0

  if keyword_set(string) then begin
      <span class="comments">;; STRING_DATA</span>
      <span class="comments">;;   LONG - STRLEN - string length in characters</span>
      <span class="comments">;;   BYTExSTRLEN - string characters, padded to next four-byte boundary</span>
      
      <span class="comments">;; Default processing</span>
      strings = 0 & dummy = temporary(strings)

      <span class="comments">;; Read as many strings as required</span>
      for i = 0L, nelt-1 do begin
          st = ''
          <span class="comments">;; Read string length</span>
          namelen = cmsv_rraw(/long, block, pointer, unit=unit, $
                              status=status, errmsg=errmsg)
          if status EQ 0 then return, ''
          
          <span class="comments">;; If length is zero, then it's an empty string, and no</span>
          <span class="comments">;; string data follows</span>
          
          if namelen GT 0 then begin
              nbytes = long(floor((namelen+3)/4)*4) <span class="comments">;; pad to next long</span>
              
              cmsv_rbuf, block, pointer, nbytes, unit=unit, $
                status=status, errmsg=errmsg
              if status EQ 0 then return, ''
              st = string(block(pointer:pointer+nbytes-1))
              
              pointer = pointer + nbytes            <span class="comments">;; Advance pointer</span>
          endif

          if n_elements(strings) EQ 0 then strings = st $
          else                             strings = [strings, st]
      endfor

      DONE_STRINGS:
      if n_elements(strings) EQ 0 then strings = ''
      if n_elements(nelt0) EQ 0 then strings = strings(0)

      status = 1
      return, strings
  end


  <span class="comments">;; INTEGER DATA </span>

  if keyword_set(byte) then begin
      nbytes = 1L
  endif else if keyword_set(long) then begin
      nbytes = 4L 
  endif else begin
      if n_elements(type0) EQ 0 then type = 'BYTE' $
      else                           type = strupcase(strtrim(type0(0),2))

      case type of 
          'BYTE'   : nbytes = 1L
          'FIX'    : nbytes = 2L
          'LONG'   : nbytes = 4L
          'ULONG'  : nbytes = 4L
          'LONG64' : nbytes = 8L
          'ULONG64': nbytes = 8L
          else: begin
              errmsg = 'ERROR: CMSV_RRAW: undefined integer type '+type
              status = 0
              return, 0
          end
      end
  endelse
  
  ntotbytes = nelt*nbytes
  if pointer+ntotbytes GT n_elements(block) then begin
      <span class="comments">;; Read the raw byte data from buffer</span>
      cmsv_rbuf, block, pointer, ntotbytes, unit=unit, errmsg=errmsg, $
        status=status
      if status EQ 0 then return, 0
  endif

  if keyword_set(buf) then begin
      status = 1
      return, 0
  endif

  <span class="comments">;; Convert byte data to long values</span>
  if n_elements(type0) EQ 0 then $
    value = long(block(pointer:pointer+ntotbytes-1),0,nelt) $
  else $
    value = call_function(type, block(pointer:pointer+ntotbytes-1),0,nelt)
  if n_elements(nelt0) EQ 0 then value = value(0)

  <span class="comments">;; Advance pointer</span>
  pointer = pointer + ntotbytes
  status = 1

  common cmsv_conv_common, lendian
  if n_elements(lendian) EQ 0 then begin
      <span class="comments">;; Little-endian?</span>
      lendian = (long(['01'xb,'02'xb,'03'xb,'04'xb],0,1))(0) NE '01020304'xl
  endif

  <span class="comments">;; Convert values to correct endianness</span>
  case nbytes of 
      1: dummy = 1                                    <span class="comments">; byte</span>
      2: byteorder, value, /NTOHS                     <span class="comments">; int </span>
      4: byteorder, value, /NTOHL                     <span class="comments">; long</span>
      8: if lendian then byteorder, value, /L64SWAP   <span class="comments">; long64</span>
      else:
  endcase

  return, value
end
</code>
    </div>
  </body>
</html>