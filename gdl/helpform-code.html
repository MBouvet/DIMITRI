<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:35 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>helpform.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="helpform.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   HELPFORM</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Generate a descriptive string in IDL HELP format</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   STRINGS = HELPFORM(NAME, VALUE, [/SHORTFORM,] [/SINGLE,] [WIDTH=width])</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   The HELPFORM function converts an IDL data value into a</span>
<span class="comments">;   representation very similar to the format produced by the built-in</span>
<span class="comments">;   command HELP.  Programmers can thus present data types and values</span>
<span class="comments">;   to users in a format they are familiar with.</span>
<span class="comments">;</span>
<span class="comments">;   For example, if the variable A is defined in the following manner,</span>
<span class="comments">;   and HELP is called, then the following transcript will result:</span>
<span class="comments">;</span>
<span class="comments">;     IDL> a = [1,2]</span>
<span class="comments">;     IDL> help, a</span>
<span class="comments">;     A               INT       = Array[2]</span>
<span class="comments">;</span>
<span class="comments">;   The same result can be achieved with the HELPFORM function:</span>
<span class="comments">;</span>
<span class="comments">;     IDL> print, helpform('A', a)</span>
<span class="comments">;     A               INT       = Array[2]</span>
<span class="comments">;</span>
<span class="comments">;   The benefit is that the output of HELPFORM is a string that can be</span>
<span class="comments">;   outputted or reformatted.  This capability is not available in all</span>
<span class="comments">;   versions of IDL.</span>
<span class="comments">;</span>
<span class="comments">;   HELPFORM actually produces *two* forms of output.  The above</span>
<span class="comments">;   output is considered the "long" form, as it appears in the IDL</span>
<span class="comments">;   HELP command, and is the default.  A "short" form can also be</span>
<span class="comments">;   produced, and is very similar to the information that appears in</span>
<span class="comments">;   certain terse IDL error messages.  It is activated by setting the</span>
<span class="comments">;   SHORTFORM keyword.</span>
<span class="comments">;</span>
<span class="comments">;   If the variable name is too long, the HELPFORM may be forced to be</span>
<span class="comments">;   two lines long to have consistent formatting.  In that case a</span>
<span class="comments">;   two-element string is returned.  If a single line is desired, use</span>
<span class="comments">;   the SINGLE keyword, but this comes at the expense of consistent</span>
<span class="comments">;   output formatting.</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   NAME - A scalar string containing the name of the IDL variable.</span>
<span class="comments">;          An empty string is permitted.  The name is ignored if the</span>
<span class="comments">;          SHORTFORM keyword is set.</span>
<span class="comments">;</span>
<span class="comments">;   VALUE - Any IDL value to be examined.  VALUE is optional if the</span>
<span class="comments">;           SIZE keyword is passed and uniquely describes the data.</span>
<span class="comments">;           VALUE should be passed for scalars and structures, since</span>
<span class="comments">;           the help form for these values requires additional</span>
<span class="comments">;           information beyond the SIZE.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   SIZE - the IDL SIZE descriptor for the value to be printed.</span>
<span class="comments">;          Default: information is taken from VALUE.</span>
<span class="comments">;</span>
<span class="comments">;   SINGLE - if set, then output which would normally</span>
<span class="comments">;            appear on two lines for consistent formatting, appears on</span>
<span class="comments">;            one single line instead.</span>
<span class="comments">;</span>
<span class="comments">;   FULL_STRUCT - if set, then a detailed output is printed for</span>
<span class="comments">;                 structures, similar to HELP, VALUE, /STRUCTURE.</span>
<span class="comments">;</span>

<span class="comments">;   RECURSIVE_STRUCT - if both this keyword and FULL_STRUCT are set,</span>
<span class="comments">;                      and if VALUE itself has sub-structures, then</span>
<span class="comments">;                      print the full contents of those sub-structures</span>
<span class="comments">;                      as well.  The contents will be slightly indented.</span>
<span class="comments">;</span>
<span class="comments">;   SHORTFORM - set this keyword for a shorter output format that can</span>
<span class="comments">;               be used in error messages.</span>
<span class="comments">;</span>
<span class="comments">;   WIDTH - the width of the terminal in characters (used for</span>
<span class="comments">;           formatting).</span>
<span class="comments">;           Default: 80</span>
<span class="comments">;</span>
<span class="comments">; RETURNS:</span>
<span class="comments">;</span>
<span class="comments">;   An array of strings containing the HELPFORM output, which may have</span>
<span class="comments">;   more than one element depending on the length of NAME, SHORTFORM</span>
<span class="comments">;   and SINGLE.  The helpforms of pointer- and object-typed values</span>
<span class="comments">;   does not include the sequence number, but are otherwise correct.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;     IDL> print, helpform('A', size=[1,2,1,2])</span>
<span class="comments">;     A               BYTE      = Array[2]</span>
<span class="comments">;     ;; Do not pass VALUE and instead use SIZE to specify the type</span>
<span class="comments">;</span>
<span class="comments">;     IDL> print, helpform('A', size=[1,2,1,2], /shortform)</span>
<span class="comments">;     BYTE     (Array[2])</span>
<span class="comments">;     ;; Compare to the short form, which is meant to be placed in</span>
<span class="comments">;     ;; error messages</span>
<span class="comments">;</span>
<span class="comments">;     IDL> print, helpform('fjsldkfjsldfkjslkdfjslkdfjslkdfjsldkfjk',a)</span>
<span class="comments">;     fjsldkfjsldfkjslkdfjslkdfjslkdfjsldkfjk</span>
<span class="comments">;                      INT       = Array[2]</span>
<span class="comments">;     IDL> print, helpform('fjsldkfjsldfkjslkdfjslkdfjslkdfjsldkfjk',a,/single)</span>
<span class="comments">;     fjsldkfjsldfkjslkdfjslkdfjslkdfjsldkfjk INT       = Array[2]</span>
<span class="comments">;     ;; Compare the long and short forms</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   INPUTFORM, HELP</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, CM, 13 May 2000</span>
<span class="comments">;   Documented, 04 Jul 2000</span>
<span class="comments">;   Improved output for objects, CM, 11 Jan 2001</span>
<span class="comments">;   Added support for full structure output, CM 08 Feb 2001</span>
<span class="comments">;   Added forward_function declaration for safety, CM 08 Apr 2001</span>
<span class="comments">;   Print more info about POINTER type, CM 08 Apr 2001</span>
<span class="comments">;   Add the RECURSIVE_STRUCT keyword, CM 04 Jan 2009</span>
<span class="comments">;</span>
<span class="comments">; $Id: helpform.pro,v 1.6 2009/01/04 09:18:18 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, 2009, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>
forward_function helpform
<a id="helpform:source"></a>function helpform, name0, value, size=sz, single=single, shortform=short, $
                   width=width0, structure_name=stname, tagform=tagform, $
                   full_struct=struct, recursive_struct=recstruct

  <span class="comments">;; Names of all the known IDL types, as of IDL 5.2</span>
  typenames = ['UNDEFINED', 'BYTE', 'INT', 'LONG', 'FLOAT', 'DOUBLE', $
               'COMPLEX', 'STRING', 'STRUCT', 'DCOMPLEX', 'POINTER', $
               'OBJREF', 'UINT', 'ULONG', $
               'LONG64', 'ULONG64', 'UNKNOWN']
  blanks = string(replicate(32b,80))
  if n_elements(sz) LT 3 then sz = size(value)
  tp = sz(sz(0)+1) &lt<span class="comments">; 16</span>

  if n_elements(name0) EQ 0 then name0 = ''
  name = strtrim(name0(0),2)

  nlen = 15  <span class="comments">;; Length of name</span>
  tlen = 9   <span class="comments">;; Length of type name</span>

  if n_elements(width0) EQ 0 then width0 = 80
  width = floor(width0(0))

  <span class="comments">;; ================================ STRUCTURES</span>
  if tp EQ 8 AND keyword_set(struct) then begin
      sz1 = size(value)
      if sz1(sz1(0)+1) NE 8 then goto, NOT_STRUCT
      nt = n_tags(value)
      len = n_tags(value, /length)
      tn = tag_names(value)
      sn = tag_names(value, /structure_name)
      
      if sn EQ '' then sn = '&lt;Anonymous>'

      a = string(sn, nt, len, $
             format='("** Structure ",A0,", ",I0," tags, length=",I0,":")')

      for i = 0, nt-1 do begin
         stri = helpform(tn(i), value(0).(i), /tagform)
         szi = size(value(0).(i))
         tpi = szi(szi(0)+1)

         a = [a, '   '+stri]
         <span class="comments">;; Recursive structures</span>
         if keyword_set(recstruct) AND tpi EQ 8 then begin
            stri = helpform(tn(i), value(0).(i), $
                            /full_struct, /recursive_struct)
            a = [a, '     '+stri]
         endif
      endfor

      return, a
  endif
  NOT_STRUCT:

  if NOT keyword_set(short) then begin
      <span class="comments">;; Pad the name out, or else put the name on a line by itself</span>
      if strlen(name) GT nlen then begin
          if keyword_set(single) then begin
              a1 = name+' '
          endif else begin
              a0 = name
              a1 = strmid(blanks,0,nlen)+' '
          endelse
      endif else begin
          a1 = strmid(name+blanks,0,nlen)+' '
      endelse
      
      a1 = a1 + strmid(typenames(tp)+blanks,0,tlen)
      if NOT keyword_set(tagform) then $
        a1 = a1 +' = '        
  endif else begin
      a1 = strmid(typenames(tp)+blanks,0,tlen)
  endelse

  ndims = sz(0)
  if ndims GT 0 then begin
      <span class="comments">;; It is an array, compose the dimensions</span>
      dims = sz(1:ndims)  
      v = 'Array['
      for i = 0L, ndims-1 do begin
          v = v + strtrim(dims(i),2)
          if i LT ndims-1 then v = v + ', '
      endfor
      v = v + ']'

      <span class="comments">;; If it is a structure, add the structure name (structures are</span>
      <span class="comments">;; never scalars)</span>
      if NOT keyword_set(short) AND tp EQ 8 then begin
          <span class="comments">;; Protect against empty value</span>
          if n_elements(stname) EQ 0 then begin
              if n_elements(value) GT 0 then v0 = value(0) else v0 = {dummy:0}
              sn = tag_names(v0, /structure_name)
              sn = sn(0)
          endif else begin
              sn = strtrim(stname(0),2)
          endelse
          if sn EQ '' then sn = '&lt;Anonymous>'
          v = '-> '+sn+' ' + v 
      endif
  endif else begin
      <span class="comments">;; It is a scalar</span>

      <span class="comments">;; Protect against empty or vector value</span>
      if n_elements(value) GT 0 then begin
          v0 = value(0) 
      endif else begin
          if tp NE 10 AND tp NE 11 then tp = 0
      endelse

      case tp &lt<span class="comments">; 16 of </span>
          0:  v = '&lt;Undefined>'
          1:  v = string(v0, format='(I4)')
          7:  begin
              w = (width - 35) > 5
              if strlen(v0) GT w then $
                v = "'"+strmid(v0,0,w)+"'..." $
              else $
                v = "'"+v0+"'"
          end
          10: begin
              sz = size(v0)
              if sz(sz(0)+1) EQ 10 then v = string(v0(0), /print) $
              else                      v = '&lt;PtrHeapVar>'
          end
          11: begin
              if n_elements(stname) EQ 0 then begin
                  forward_function obj_class
                  sz = size(v0)
                  if sz(sz(0)+1) EQ 11 then sn = '('+obj_class(v0)+')' $
                  else                      sn = ''
              endif else begin
                  sn = '('+strupcase(strtrim(stname(0),2))+')'
              endelse
              v = '&lt;ObjHeapVar'+sn+'>'
          end
          16: v = ''
          else: v = string(v0)
      endcase
  endelse

  if keyword_set(short) then return, a1 + '('+v+')'

  a1 = a1 + v
  if n_elements(a0) GT 0 then a1=[a0, a1]

  return, a1
end
</code>
    </div>
  </body>
</html>