<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:47 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsv_rrec.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsv_rrec.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSV_RREC</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Read SAVE-formatted record header from input block or file unit</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   CMSV_RREC, BLOCK, POINTER, DATA, UNIT=UNIT, $</span>
<span class="comments">;        BLOCK_TYPE=BLOCK_TYPE, BLOCK_NAME=BLOCK_NAME, NEXT_BLOCK=NEXT_BLOCK, $</span>
<span class="comments">;        INITIALIZE=INITIALIZE, FULL=FULL, PROMOTE64=PROMOTE64, $</span>
<span class="comments">;        OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   This procedure reads the header of an IDL SAVE record.  The header</span>
<span class="comments">;   consists of four bytes at the beginning of each record which</span>
<span class="comments">;   indentifies the type and size of the record.  This procedure also</span>
<span class="comments">;   additionally reads many full records as noted below.</span>
<span class="comments">;</span>
<span class="comments">;   Users can determine the block type by examining the values</span>
<span class="comments">;   returned in the BLOCK_TYPE and BLOCK_NAME keywords.  The following</span>
<span class="comments">;   values are supported.  Some record types contain additional data.</span>
<span class="comments">;   CMSV_RREC reads some of these record types automatically (those</span>
<span class="comments">;   entries below marked with [this procedure]).  Other records do not</span>
<span class="comments">;   contain any additional data at all (those entries marked with an</span>
<span class="comments">;   [empty]), and thus require no further processing.</span>
<span class="comments">;</span>
<span class="comments">;    BLOCK_TYPE      BLOCK_TYPE         READ RECORD DATA WITH...</span>
<span class="comments">;</span>
<span class="comments">;       0         = 'START_MARKER'      [empty]</span>
<span class="comments">;       1         = 'COMMON_BLOCK'      [this procedure]</span>
<span class="comments">;       2         = 'VARIABLE'          CMSV_RVTYPE / CMSV_RDATA</span>
<span class="comments">;       3         = 'SYSTEM_VARIABLE'   CMSV_RVTYPE / CMSV_RDATA</span>
<span class="comments">;       6         = 'END_MARKER'        [empty]</span>
<span class="comments">;       10        = 'TIMESTAMP'         [this procedure]</span>
<span class="comments">;       12        = 'COMPILED'          no published procedure</span>
<span class="comments">;       13        = 'IDENTIFICATION'    [this procedure]</span>
<span class="comments">;       14        = 'VERSION'           [this procedure]</span>
<span class="comments">;       15        = 'HEAP_INDEX'        [this procedure]</span>
<span class="comments">;       16        = 'HEAP_DATA'         CMSV_RVTYPE</span>
<span class="comments">;       17        = 'PROMOTE64'         [empty]</span>
<span class="comments">;       19        = 'NOTICE'            [this procedure]</span>
<span class="comments">;</span>
<span class="comments">;   For records that contain variable data, the external procedures</span>
<span class="comments">;   CMSV_RVTYPE and CMSV_RDATA must be used, as noted above.</span>
<span class="comments">;   Otherwise CMSV_RREC will read and convert the appropriate data</span>
<span class="comments">;   automatically and return it in the DATA positional parameter.</span>
<span class="comments">;</span>
<span class="comments">;   The offset of the next record is returned in the NEXT_BLOCK</span>
<span class="comments">;   keyword.  For file input, the command, "POINT_LUN, UNIT,</span>
<span class="comments">;   NEXT_BLOCK" will position the file pointer to the next block.</span>
<span class="comments">;</span>
<span class="comments">;   Users should be aware that the SAVE files produced by IDL version</span>
<span class="comments">;   5.4 appear to have a different header format.  The new header size</span>
<span class="comments">;   is five bytes, and is incompatible with the older format.  In</span>
<span class="comments">;   order to activate the longer header size, the PROMOTE64 keyword</span>
<span class="comments">;   must be set.</span>
<span class="comments">;</span>
<span class="comments">;   By default the entire record is not read from the file at once.</span>
<span class="comments">;   Users that wish to operate on the entire record immediately should</span>
<span class="comments">;   set the FULL keyword.</span>
<span class="comments">;</span>
<span class="comments">;   After issuing a POINT_LUN the block cache in BLOCK must be reset</span>
<span class="comments">;   using the /INITIALIZE keyword.</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; SPECIFIC RECORD TYPES</span>
<span class="comments">;</span>
<span class="comments">;   CMSV_RREC reads certain specific record types automatically and</span>
<span class="comments">;   returns the data in the positional parameter data.  Users should</span>
<span class="comments">;   pass a named variable in this parameter to retrieve the return</span>
<span class="comments">;   value.</span>
<span class="comments">;</span>
<span class="comments">;   When a record of type 'VERSION' (14) is encountered, it is read,</span>
<span class="comments">;   and returned as a structure. The returned data are of the form:</span>
<span class="comments">;</span>
<span class="comments">;         { FORMAT_VERSION: 0L, $   ; Format version number of file</span>
<span class="comments">;           ARCH: '', $             ; !VERSION.ARCH of creating host</span>
<span class="comments">;           OS: '', $               ; !VERSION.OS of creating host</span>
<span class="comments">;           RELEASE: '' }           ; !VERSION.RELEASE of creating host</span>
<span class="comments">;</span>
<span class="comments">;   When a record of type 'TIMESTAMP' (10) is encountered, it is read,</span>
<span class="comments">;   and returned as a structure. The returned data are of the form:</span>
<span class="comments">;</span>
<span class="comments">;          { SAVE_DATE: '', $  ; Date the save file was created</span>
<span class="comments">;            SAVE_USER: '', $  ; User name who  created file</span>
<span class="comments">;            SAVE_HOST: '' }   ; Host name that created file</span>
<span class="comments">;</span>
<span class="comments">;   Save files created by IDL version 4 do not contain a timestamp</span>
<span class="comments">;   record.</span>
<span class="comments">;</span>
<span class="comments">;   When a record of type 'IDENTIFICATION' (13) is encountered, it is</span>
<span class="comments">;   read, and returned as a structure.  The returned data are of the</span>
<span class="comments">;   form:</span>
<span class="comments">;</span>
<span class="comments">;          { AUTHOR: '', $  ; Author of SAVE file</span>
<span class="comments">;            TITLE:  '', $  ; Title of SAVE file</span>
<span class="comments">;            IDCODE: '' }   ; Identifying code for SAVE file</span>
<span class="comments">;</span>
<span class="comments">;   It appears that this record is not used in IDL version 5 or later.</span>
<span class="comments">;</span>
<span class="comments">;   When a record of type 'COMMON_BLOCK' (1) is encountered, it is</span>
<span class="comments">;   read and returned.  A common block descriptor consists of an array</span>
<span class="comments">;   of strings whose first element is the common block name, and whose</span>
<span class="comments">;   remaining elements are the common block variable names.  No</span>
<span class="comments">;   variable data are stored with the common block definition.</span>
<span class="comments">;</span>
<span class="comments">;   When a record of type 'HEAP_INDEX' (15) is encountered, it is read</span>
<span class="comments">;   and returned in DATA.  The heap index specifies a list of which</span>
<span class="comments">;   heap variables are stored in the current save file.  These indices</span>
<span class="comments">;   are simply numbers which identify each heap variable (i.e.,</span>
<span class="comments">;   "&lt;PtrHeapVar2>" would have an index of 2).  Users should note that</span>
<span class="comments">;   the heap index will not necessarily be sequentially increasing,</span>
<span class="comments">;   and may have gaps.</span>
<span class="comments">;</span>
<span class="comments">;   When a record of type 'NOTICE' (19) is encountered, it is read and</span>
<span class="comments">;   returned in DATA.  It is a structure with one field: {TEXT: ''},</span>
<span class="comments">;   where TEXT is the text content of the notice.</span>
<span class="comments">;</span>
<span class="comments">;   Users should consult CMSV_RDATA for instructions on how to read</span>
<span class="comments">;   heap data.</span>
<span class="comments">;   </span>
<span class="comments">;</span>
<span class="comments">; BLOCK, POINTER, OFFSET</span>
<span class="comments">;</span>
<span class="comments">;   This procedure can read data from a byte array, a file unit, or</span>
<span class="comments">;   both.  In fact, this procedure is designed to implement "lazy"</span>
<span class="comments">;   reading from a file, which is to say, it normally reads from a</span>
<span class="comments">;   byte array of data.  However, if the requested data goes beyond</span>
<span class="comments">;   the end of the byte array, more data is read from the file on</span>
<span class="comments">;   demand.  This way the user gets the benefit of fast memory access</span>
<span class="comments">;   for small reads, but guaranteed file access for large reads.</span>
<span class="comments">;</span>
<span class="comments">;   The terminology is as follows: BLOCK is a byte array which</span>
<span class="comments">;   represents a portion of, or an entire, IDL SAVE file.  The block</span>
<span class="comments">;   may be a cached portion of an on-disk file, or an entire in-memory</span>
<span class="comments">;   SAVE file.  POINTER is the current file pointer within BLOCK</span>
<span class="comments">;   (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a</span>
<span class="comments">;   POINTER value of 0 refers to the start of the block.  OFFSET is</span>
<span class="comments">;   the file offset of the 0th byte of BLOCK; thus "POINT_LUN,</span>
<span class="comments">;   OFFSET+POINTER" should point to the same byte as BLOCK[POINTER].</span>
<span class="comments">;   The following diagram shows the meanings for BLOCK, POINTER and</span>
<span class="comments">;   OFFSET schematically:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;                 0 &lt;-  OFFSET  -> |</span>
<span class="comments">;   FILE          |----------------|------*--------|---------></span>
<span class="comments">;</span>
<span class="comments">;   BLOCK                          |------*--------|</span>
<span class="comments">;                                  0      ^ POINTER</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK - a byte array, a cache of the SAVE file.  Users will</span>
<span class="comments">;           usually not access this array directly.  Users are advised</span>
<span class="comments">;           to clear BLOCK after calling POINT_LUN.</span>
<span class="comments">;</span>
<span class="comments">;   POINTER - a long integer, a pointer to the next byte to be read</span>
<span class="comments">;             from BLOCK.  CMSVLIB routines will automatically</span>
<span class="comments">;             advance the pointer.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a file unit.  If a library routine reads to the end of</span>
<span class="comments">;          BLOCK, or if BLOCK is undefined, then this file UNIT will</span>
<span class="comments">;          be accessed for more data.  If undefined, then BLOCK must</span>
<span class="comments">;          contain the entire file in memory.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSET - the file offset of byte zero of BLOCK.  Default: 0</span>
<span class="comments">;            (OFFSET is used by this routine)</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK_TYPE - upon return, the numeric record type, as described</span>
<span class="comments">;                above.</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK_NAME - upon return, a scalar string specifying the record</span>
<span class="comments">;                type, as specified above.</span>
<span class="comments">;</span>
<span class="comments">;   NEXT_BLOCK - upon return, file offset of the next record in the</span>
<span class="comments">;                file.</span>
<span class="comments">;</span>
<span class="comments">;   INITIALIZE - if set, then BLOCK and POINTER are initialized to a</span>
<span class="comments">;                pristine state.  All data in these two variables is</span>
<span class="comments">;                lost before reading the next record.</span>
<span class="comments">;</span>
<span class="comments">;   FULL - if set, then the entire record will be read into BLOCK.</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, this keyword will contain 1 for success and</span>
<span class="comments">;            0 for failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return with a failure, this keyword will contain the</span>
<span class="comments">;            error condition as a string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 2000</span>
<span class="comments">;   Documented, 24 Jan 2001</span>
<span class="comments">;   Fix typo for RHEAP call, CM, 21 Apr 2001</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   Added NOTICE record type, 09 Jun 2003, CM</span>
<span class="comments">;   Read record header as ULONG, 26 Sep 2009, CM</span>
<span class="comments">;   Bug fix to previous change, 22 Nov 2009, CM</span>
<span class="comments">;   Support for newer IDL 64-bit files which use a </span>
<span class="comments">;    "standard" record header size and a previously unused</span>
<span class="comments">;    field, 11 Jan 2010, CM</span>
<span class="comments">;   NOTE: remember to modify CMSVLIB.PRO when changing library!</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsv_rrec.pro,v 1.15 2010/01/11 08:58:13 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, 2003, 2009, 2010, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

<span class="comments">; ----------------- Read common block descriptor ----------------------</span>

<a id="cmsv_rcomm:source"></a>pro cmsv_rcomm, block, pointer, names, unit=unit, offset=offset, $
                status=status, errmsg=errmsg

  status = 0
  if n_elements(pointer) EQ 0 then pointer = 0L
  names = 0 & dummy = temporary(names)
  
  ncommon = cmsv_rraw(/long, block, pointer, unit=unit, $
                      status=status, errmsg=errmsg)
  if status EQ 0 then return
  if ncommon LE 0 then begin
      status = 0
      errmsg = 'ERROR: CMSV_RREC: invalid common record block'
      return
  endif

  names = cmsv_rraw(/string, block, pointer, ncommon+1, unit=unit, $
                    status=status, errmsg=errmsg)
  return
end


<span class="comments">; ----------------- Read heap index ---------------------------------</span>

<a id="cmsv_rheap:source"></a>pro cmsv_rheap, block, pointer, index, unit=unit, offset=offset, $
                status=status, errmsg=errmsg

  <span class="comments">;; HEAP_INDEX</span>
  <span class="comments">;;   LONG - N_HEAP - number of heap values</span>
  <span class="comments">;;   LONGxN_HEAP - heap indices</span>

  if n_elements(pointer) EQ 0 then pointer = 0L
  index = 0 & dummy = temporary(index)

  n_heap = cmsv_rraw(/long, block, pointer, unit=unit, $
                     status=status, errmsg=errmsg)
  if status then $
    index = cmsv_rraw(/long, block, pointer, n_heap, unit=unit, $
                      status=status, errmsg=errmsg)

  return
end

<span class="comments">; ------------------------ Read time stamp record -----------------------</span>

<a id="cmsv_rstamp:source"></a>pro cmsv_rstamp, block, pointer, tstamp, unit=unit, offset=offset, $
                 status=status, errmsg=errmsg

  <span class="comments">;; TIMESTAMP</span>
  <span class="comments">;;   BYTEx400 - empty (?) legacy area</span>
  <span class="comments">;;   STRING - save date (as a string)</span>
  <span class="comments">;;   STRING - user name</span>
  <span class="comments">;;   STRING - hostname</span>
  status = 0
  if n_elements(pointer) EQ 0 then pointer = 0L
  pointer = pointer + '400'xl
  tstamp = 0 & dummy = temporary(tstamp)

  strings = cmsv_rraw(/string, block, pointer, 3, unit=unit, $
                      status=status, errmsg=errmsg)
  if status EQ 0 then return

  tstamp = {save_date: strings(0), save_user: strings(1), save_host:strings(2)}
  return
end


<span class="comments">; ---------------------- Read Version Info ---------------------------</span>

<a id="cmsv_rversion:source"></a>pro cmsv_rversion, block, pointer, vers, unit=unit, offset=offset, $
                   status=status, errmsg=errmsg
  <span class="comments">;; VERSION_STAMP</span>
  <span class="comments">;;   LONG - Major version number</span>
  <span class="comments">;;   STRING_DATA - Host architecture ( = !version.arch )</span>
  <span class="comments">;;   STRING_DATA - Host OS ( = !version.os )</span>
  <span class="comments">;;   STRING_DATA - IDL release ( = !version.release )</span>

  if n_elements(pointer) EQ 0 then pointer = 0L
  major_release = 5
  vers = 0 & dummy = temporary(vers)

  arch = '' & os = '' & release = ''
  major_release = cmsv_rraw(/long, block, pointer, unit=unit, $
                            status=status, errmsg=errmsg)
  if status EQ 0 then return

  strings = cmsv_rraw(/string, block, pointer, 3L, status=status, $
                      unit=unit, errmsg=errmsg)
  if status EQ 0 then return
  status = 1
  
  vers = {format_version: major_release, arch: strings(0), $
          os: strings(1), release: strings(2)}
  return
end

<span class="comments">; --------------------------- Read Identification --------------------</span>

<a id="cmsv_rident:source"></a>pro cmsv_rident, block, pointer, ident, unit=unit, offset=offset, $
                 status=status, errmsg=errmsg

  <span class="comments">;; IDENT</span>
  <span class="comments">;;   STRING - author</span>
  <span class="comments">;;   STRING - title</span>
  <span class="comments">;;   STRING - idcode</span>

  strings = cmsv_rraw(/string, block, pointer, 3, unit=unit, $
                      status=status, errmsg=errmsg)
  if status EQ 0 then return

  ident = {author: strings(0), title: strings(1), idcode:strings(2)}
  return
end

<span class="comments">; --------------------------- Read Notice --------------------</span>

<a id="cmsv_rnotice:source"></a>pro cmsv_rnotice, block, pointer, notice, unit=unit, offset=offset, $
                  status=status, errmsg=errmsg

  <span class="comments">;; NOTICE</span>
  <span class="comments">;;   STRING - notice text</span>

  string = cmsv_rraw(/string, block, pointer, 1, unit=unit, $
                      status=status, errmsg=errmsg)
  if status EQ 0 then return

  notice = {text: string}
  return
end


<span class="comments">; ---------------------------- Main Read Routine ---------------------</span>

<a id="cmsv_rrec:source"></a>pro cmsv_rrec, block, pointer, data, unit=unit, offset=offset, $
               status=status, errmsg=errmsg, compressed=compressed, $
               block_type=blocktype, block_name=blockname, next_block=np, $
               initialize=init, full=full, promote64=prom, $
               qblocknames=qblock

  common cmsave_block_names, block_ntypenames, block_typenames
  if n_elements(block_ntypenames) EQ 0 then begin
      block_ntypenames    = 20
      block_typenames     = strarr(block_ntypenames+1)+'UNKNOWN'
      block_typenames(0)  = 'START_MARKER'
      block_typenames(1)  = 'COMMON_BLOCK'
      block_typenames(2)  = 'VARIABLE'
      block_typenames(3)  = 'SYSTEM_VARIABLE'
      block_typenames(6)  = 'END_MARKER'
      block_typenames(10) = 'TIMESTAMP'
      block_typenames(12) = 'COMPILED'
      block_typenames(13) = 'IDENTIFICATION'
      block_typenames(14) = 'VERSION'
      block_typenames(15) = 'HEAP_INDEX'
      block_typenames(16) = 'HEAP_DATA'
      block_typenames(17) = 'PROMOTE64'
      block_typenames(19) = 'NOTICE'
  endif

  if keyword_set(qblock) then begin
      data = block_typenames
      return
  end

  status = 0
  errmsg = ''

  if n_elements(pointer) EQ 0 then pointer = 0L
  pointer = floor(pointer(0))
  if keyword_set(init) then begin
      block = 0 & dummy = temporary(block)
      pointer = 0L
  endif

  pointer0 = pointer
  op = pointer0  <span class="comments">;; "OP" = old pointer - points to curr record</span>
  if n_elements(offset) GT 0 then op = op + offset(0)

  nlongs = 4L
  if keyword_set(prom) then nlongs = 5 <span class="comments">;; Special case of PROMOTE64</span>
  rechead = cmsv_rraw(block, pointer, nlongs, unit=unit(0), $
                      status=status, errmsg=errmsg, type='ULONG')
  if status EQ 0 then return
  
  blocktype = rechead(0)
  blockname = block_typenames(blocktype &lt<span class="comments">; block_ntypenames)</span>

  <span class="comments">;; "NP" = next pointer - points to next record</span>
  np = rechead(1)

  <span class="comments">;; We assume this is a 64-bit pointer for two possibilities:</span>
  <span class="comments">;;    1. the next pointer (32-bit) is less than "old pointer"</span>
  <span class="comments">;;    2. PROMOTE64 has been set</span>
  if (np LT op) OR keyword_set(prom) then begin
     <span class="comments">;; Compute new offset by combining two long values</span>
     np = rechead(1) + rechead(2)*'100000000'XULL
     <span class="comments">;; Promote OFFSET</span>
     if n_elements(offset) NE 0 then offset = ulong64(offset)

     <span class="comments">;; Sanity check on PROMOTE64-style headers</span>
     if keyword_set(prom) then if rechead(4) NE 0 then begin
          errmsg = 'ERROR: CMSV_RREC: inconsistent 64-bit header'
          status = 0
          return
     endif
  endif


  if keyword_set(doprom) then begin
      <span class="comments">;; If file offset is to be promoted to 64-bit then we compute it</span>
      <span class="comments">;; here.  The additional logic is to preserve 32-bit offsets in</span>
      <span class="comments">;; most cases, and promote only if absolutely needed.  Signal an</span>
      <span class="comments">;; error in earlier versions of IDL that don't support 64-bit</span>
      <span class="comments">;; numbers.</span>
      np = rechead(2) + rechead(1)
      if rechead(1) NE 0 AND rechead(2) NE 0 then begin
          if double(!version.release) LT 5.2D then begin
              errmsg = ('ERROR: CMSV_RREC: file contains a 64-bit file '+ $
                        'offset which is unstorable by this version of IDL')
              status = 0
              return
          endif
          np = cmsv_rraw(/long, block, pointer-3L*4L, type='ULONG64', $
                         status=status, errmsg=errmsg)
          if status EQ 0 then return
      endif

      <span class="comments">;; A 64-bit header has an extra long in it.  Read that now.</span>
      <span class="comments">;; It should be zero.</span>
      val0 = cmsv_rraw(/long, block, pointer, status=status, errmsg=errmsg)
      if status EQ 0 then return
      if val0 NE 0 then begin
          errmsg = 'ERROR: CMSV_RREC: inconsistent 64-bit header'
          status = 0
          return
      endif

  endif

  <span class="comments">;; Activate 64-bit promotion.  Blocks after this current one will</span>
  <span class="comments">;; have 64-bit file offsets rather than 32-bit ones.</span>
  if blocktype EQ 17 then prom = 1

  if keyword_set(full) then begin
      if n_elements(offset) EQ 0 then offset = 0L
      nbytes = np - (pointer0 + floor(offset(0)))
      if nbytes GT 0 then begin
          dummy = cmsv_rraw(block, 0L, nbytes, /byte, /buffer, unit=unit, $
                            status=status, errmsg=errmsg)
          if status EQ 0 then return
          block = block(0:nbytes-1)
      endif
  endif

  <span class="comments">;; Can't read compressed data for the moment</span>
  if keyword_set(compressed) then begin
      status = 1
      return
  endif

  case blockname of 
      'COMMON_BLOCK': cmsv_rcomm, block, pointer, data, unit=unit, $
        status=status, errmsg=errmsg
      'HEAP_INDEX': cmsv_rheap, block, pointer, data, unit=unit, $
        status=status, errmsg=errmsg
      'VERSION': cmsv_rversion, block, pointer, data, unit=unit, $
        status=status, errmsg=errmsg
      'TIMESTAMP': cmsv_rstamp, block, pointer, data, unit=unit, $
        status=status, errmsg=errmsg
      'IDENTIFICATION': cmsv_rident, block, pointer, data, unit=unit, $
        status=status, errmsg=errmsg
      'NOTICE': cmsv_rnotice, block, pointer, data, unit=unit, $
        status=status, errmsg=errmsg
      ELSE: status = 1
  end

  return
end
</code>
    </div>
  </body>
</html>