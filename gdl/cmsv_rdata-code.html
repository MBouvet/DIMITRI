<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:32 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsv_rdata.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsv_rdata.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSV_RDATA</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Read SAVE-formatted data variable record from input block or file unit</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   CMSV_RDATA, BLOCK, POINTER, SIZE, DATA, UNIT=UNIT, $</span>
<span class="comments">;          TEMPLATE=TEMPLATE, /TEMPORARY, PTR_INDEX=PTR_INDEX, $</span>
<span class="comments">;          PTR_CALLBACK=PTR_CALLBACK, PTR_OFFSETS=PTR_OFFSETS, $</span>
<span class="comments">;          OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   CMSV_RDATA reads the data portion of an IDL SAVE variable record.</span>
<span class="comments">;   An IDL variable is stored in two components: the type descriptor</span>
<span class="comments">;   which describes the name, type, and dimensions of the variable;</span>
<span class="comments">;   and the data record, which contains the raw data of the variable.</span>
<span class="comments">;   This procedure reads the raw data and returns it to the user.  The</span>
<span class="comments">;   initial type portion of the record must have already been read</span>
<span class="comments">;   using the CMSV_RVTYPE procedure.</span>
<span class="comments">;</span>
<span class="comments">;   CMSV_RDATA supports the following variable types:</span>
<span class="comments">;</span>
<span class="comments">;     BYTE(1),INT(2),LONG(3) - integer types</span>
<span class="comments">;     UINT(12),ULONG(13),LONG64(14),ULONG64(15) - integer types (IDL >5.2 only)</span>
<span class="comments">;     FLOAT(4),DOUBLE(5),COMPLEX(6),DCOMPLEX(9) - float types</span>
<span class="comments">;     STRING(7) - string type</span>
<span class="comments">;     STRUCT(8) - structure type</span>
<span class="comments">;     POINTER(10) - pointer type - SEE BELOW</span>
<span class="comments">;     NOT SUPPORTED - OBJ(11) - object reference type - NOT SUPPORTED</span>
<span class="comments">;</span>
<span class="comments">;   Arrays and structures containing any of the supported types are</span>
<span class="comments">;   supported (including structures within structures).</span>
<span class="comments">;</span>
<span class="comments">;   For scalars and arrays of numeric or string types, the caller must</span>
<span class="comments">;   only supply the SIZE parameter, which specifies the type and</span>
<span class="comments">;   dimensions of the variable to be read.  This information can be</span>
<span class="comments">;   obtained from the CMSV_RVTYPE routine. The data is returned in the</span>
<span class="comments">;   output parameter DATA.</span>
<span class="comments">;</span>
<span class="comments">;   For structure data, in addition to specifying the SIZE array, the</span>
<span class="comments">;   user must also supply a "template" describing the structure into</span>
<span class="comments">;   which the data will be read.  This template is simply a "blank"</span>
<span class="comments">;   form of the data structure, and is returned by CMSV_RVTYPE.</span>
<span class="comments">;</span>
<span class="comments">;   Thus, a simple way to read structure, numeric or string data is</span>
<span class="comments">;   the following code (with error checking removed)</span>
<span class="comments">;</span>
<span class="comments">;     CMSV_RVTYPE, block, pointer, name, size, template=template, unit=unit</span>
<span class="comments">;     CMSV_RDATA, block, pointer, size, data, template=template, unit=unit</span>
<span class="comments">;</span>
<span class="comments">;   [ This code assumes the record header has been read with</span>
<span class="comments">;   CMSV_RREC. ]</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; POINTER DATA</span>
<span class="comments">;</span>
<span class="comments">;   Pointer data stored in IDL SAVE files are particularly difficult</span>
<span class="comments">;   to manage, because the actual heap variables are stored in</span>
<span class="comments">;   separate records which *precede* the record of interest.  Thus, if</span>
<span class="comments">;   your application requires the reading of pointer data, you must</span>
<span class="comments">;   perform special processing in your own code in order to support</span>
<span class="comments">;   it.  In essence, you must maintain an inventory of heap variables</span>
<span class="comments">;   as they are encountered in the file.</span>
<span class="comments">;</span>
<span class="comments">;   If these procedures are not followed then pointer data will not be</span>
<span class="comments">;   read, and a LONG integer value appears in the pointers' places.</span>
<span class="comments">;   Under IDL 4, pointer data can never be read.</span>
<span class="comments">;</span>
<span class="comments">;   This is accomplished by placing some additional logic in your file</span>
<span class="comments">;   processing loop.  There are four separate components to this: (1)</span>
<span class="comments">;   loop initialization; (2) reading a HEAP_INDEX record; (3) parsing</span>
<span class="comments">;   a HEAP_DATA record; and (4) passing extra arguments to CMSV_RDATA.</span>
<span class="comments">;   The additional state information is maintained in two variables</span>
<span class="comments">;   named PTR_INDEX, which keeps track of the heap variable numbers,</span>
<span class="comments">;   and PTR_OFFSETS, which stores the file location of each variable.</span>
<span class="comments">;</span>
<span class="comments">;   (1) Loop initialization: is quite simple, use the following code:</span>
<span class="comments">;       ptr_index   = [0L]</span>
<span class="comments">;       ptr_offsets = [0L]</span>
<span class="comments">;       ptr_data    = [ptr_new()]</span>
<span class="comments">;</span>
<span class="comments">;   (2) Reading HEAP_INDEX, which is an array of values indicating</span>
<span class="comments">;       the heap variable numbers of each heap variables.  These</span>
<span class="comments">;       values are stored in PTR_INDEX:</span>
<span class="comments">;</span>
<span class="comments">;          CMSV_RHEAP, block, pointer, index, unit=unit</span>
<span class="comments">;          ptr_index   = [ptr_index, index]</span>
<span class="comments">;          ptr_offsets = [ptr_offsets, lonarr(n_elements(index))]</span>
<span class="comments">;          ptr_data    = [ptr_data, ptrarr(n_elements(index))]</span>
<span class="comments">;</span>
<span class="comments">;   (3) Parse the HEAP_DATA record.  Here were are interested in the</span>
<span class="comments">;       heap variable number, and the file offset.</span>
<span class="comments">;       </span>
<span class="comments">;       opointer = pointer</span>
<span class="comments">;       CMSV_RVTYPE, block, pointer, vindex, /heap, unit=unit</span>
<span class="comments">;       </span>
<span class="comments">;       vindex = floor(vindex(0))</span>
<span class="comments">;       wh = where(ptr_index EQ vindex)</span>
<span class="comments">;       ptr_offsets(wh(0)) = offset + opointer</span>
<span class="comments">;</span>
<span class="comments">;       Keep in mind that the file offset is OFFSET+POINTER.</span>
<span class="comments">;</span>
<span class="comments">;   (4) Pass extra parameters to CMSV_RDATA.  The user simply passes</span>
<span class="comments">;       these extra variables to the CMSV_RDATA procedure, which</span>
<span class="comments">;       automatically recognizes heap data and reads it from the</span>
<span class="comments">;       appropriate location.</span>
<span class="comments">;</span>
<span class="comments">;       CMSV_RVTYPE, block, pointer, name, size, unit=unit, template=tp</span>
<span class="comments">;       CMSV_RDATA, block, pointer, size, data, template=tp, $</span>
<span class="comments">;         unit=unit, ptr_offsets=ptr_offsets, $</span>
<span class="comments">;         ptr_index=ptr_index, ptr_data=ptr_data</span>
<span class="comments">;</span>
<span class="comments">;   If this technique is used properly, only those heap variables</span>
<span class="comments">;   which are needed are read.  Thus, there are never any lost or</span>
<span class="comments">;   dangling pointers.  Since each bit of heap data is stored in a</span>
<span class="comments">;   variable returned to the user, it is not necessary to</span>
<span class="comments">;   PTR_FREE(ptr_data); in fact, doing so would corrupt the input</span>
<span class="comments">;   data.</span>
<span class="comments">;</span>
<span class="comments">; BLOCK, POINTER, OFFSET</span>
<span class="comments">;</span>
<span class="comments">;   This procedure can read data from a byte array, a file unit, or</span>
<span class="comments">;   both.  In fact, this procedure is designed to implement "lazy"</span>
<span class="comments">;   reading from a file, which is to say, it normally reads from a</span>
<span class="comments">;   byte array of data.  However, if the requested data goes beyond</span>
<span class="comments">;   the end of the byte array, more data is read from the file on</span>
<span class="comments">;   demand.  This way the user gets the benefit of fast memory access</span>
<span class="comments">;   for small reads, but guaranteed file access for large reads.</span>
<span class="comments">;</span>
<span class="comments">;   The terminology is as follows: BLOCK is a byte array which</span>
<span class="comments">;   represents a portion of, or an entire, IDL SAVE file.  The block</span>
<span class="comments">;   may be a cached portion of an on-disk file, or an entire in-memory</span>
<span class="comments">;   SAVE file.  POINTER is the current file pointer within BLOCK</span>
<span class="comments">;   (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a</span>
<span class="comments">;   POINTER value of 0 refers to the start of the block.  OFFSET is</span>
<span class="comments">;   the file offset of the 0th byte of BLOCK; thus "POINT_LUN,</span>
<span class="comments">;   OFFSET+POINTER" should point to the same byte as BLOCK[POINTER].</span>
<span class="comments">;   The following diagram shows the meanings for BLOCK, POINTER and</span>
<span class="comments">;   OFFSET schematically:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;                 0 &lt;-  OFFSET  -> |</span>
<span class="comments">;   FILE          |----------------|------*--------|---------></span>
<span class="comments">;</span>
<span class="comments">;   BLOCK                          |------*--------|</span>
<span class="comments">;                                  0      ^ POINTER</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK - a byte array, a cache of the SAVE file.  Users will</span>
<span class="comments">;           usually not access this array directly.  Users are advised</span>
<span class="comments">;           to clear BLOCK after calling POINT_LUN.</span>
<span class="comments">;</span>
<span class="comments">;   POINTER - a long integer, a pointer to the next byte to be read</span>
<span class="comments">;             from BLOCK.  CMSVLIB routines will automatically</span>
<span class="comments">;             advance the pointer.</span>
<span class="comments">;</span>
<span class="comments">;   SIZE - an array of integers describing the type and dimensions of</span>
<span class="comments">;          the variable to be read, in the format returned by the</span>
<span class="comments">;          SIZE() routine.  This parameter is required.</span>
<span class="comments">;</span>
<span class="comments">;   DATA - upon output, the data variable.  If any heap data is read,</span>
<span class="comments">;          the user is ultimately responsible for freeing it.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a file unit.  If a library routine reads to the end of</span>
<span class="comments">;          BLOCK, or if BLOCK is undefined, then this file UNIT will</span>
<span class="comments">;          be accessed for more data.  If undefined, then BLOCK must</span>
<span class="comments">;          contain the entire file in memory.</span>
<span class="comments">;</span>
<span class="comments">;   TEMPLATE - for structure data (data type 8), a "blank" structure</span>
<span class="comments">;              containing the fields and data values to be read in.</span>
<span class="comments">;              This structure is returned by CMSV_RVTYPE.</span>
<span class="comments">;              This keyword is mandatory for structure data.</span>
<span class="comments">;</span>
<span class="comments">;   TEMPORARY - if set, BLOCK becomes undefined upon return.</span>
<span class="comments">;</span>
<span class="comments">;   PTR_OFFSETS - array of file offsets, as described above.  Default:</span>
<span class="comments">;                 pointer data is converted to an integer.</span>
<span class="comments">;</span>
<span class="comments">;   PTR_INDEX - array of heap variable indices, as described above.</span>
<span class="comments">;               Default:  pointer data is converted to an integer.</span>
<span class="comments">;</span>
<span class="comments">;   PTR_DATA - array of pointers, as described above.  </span>
<span class="comments">;               Default:  pointer data is converted to an integer.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSET - the file offset of byte zero of BLOCK.  Default: 0</span>
<span class="comments">;            (OFFSET is used by this routine)</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, this keyword will contain 1 for success and</span>
<span class="comments">;            0 for failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return with a failure, this keyword will contain the</span>
<span class="comments">;            error condition as a string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 2000</span>
<span class="comments">;   Documented, 24 Jan 2001</span>
<span class="comments">;   Added UNDEFINED data type for IDL >5.3, CM, 21 Apr 2001</span>
<span class="comments">;   Fixed bug for pointers within structures, CM, 21 Apr 2001</span>
<span class="comments">;   Add support for IDL 4 byte-compiled strings, CM, 22 Apr 2001</span>
<span class="comments">;   Make version checks with correct precision, 19 Jul 2001, CM</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   Clarify and speed some of the code, 22 Nov 2009, CM</span>
<span class="comments">;   NOTE: remember to modify CMSVLIB.PRO when changing library!</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsv_rdata.pro,v 1.11 2009/11/22 23:04:43 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, 2009, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>
forward_function cmsv_rraw

<span class="comments">; ---------------- Convert from network to host order ------------------</span>
<a id="cmsv_rconv:source"></a>pro cmsv_rconv, data

  <span class="comments">;; Inspired by IDL Astronomy Library routine IEEE_TO_HOST</span>
  common cmsv_conv_common, lendian
  if n_elements(lendian) EQ 0 then begin
      <span class="comments">;; Little-endian?</span>
      lendian = (long(['01'xb,'02'xb,'03'xb,'04'xb],0,1))(0) NE '01020304'xl
  endif

  sz = size(data)
  case sz(sz(0)+1) of 
      1:  return                    <span class="comments">;; Byte</span>
      2:  byteorder, data, /NTOHS   <span class="comments">;; Integer</span>
      3:  byteorder, data, /NTOHL   <span class="comments">;; Long</span>
      4:  byteorder, data, /XDRTOF  <span class="comments">;; Float</span>
      5:  byteorder, data, /XDRTOD  <span class="comments">;; Double</span>
      6:  byteorder, data, /XDRTOF  <span class="comments">;; Complex</span>
      9:  byteorder, data, /XDRTOD  <span class="comments">;; DComplex</span>
      12: byteorder, data, /NTOHS   <span class="comments">;; UInt</span>
      13: byteorder, data, /NTOHL   <span class="comments">;; ULong</span>
      14: if lendian EQ 1 then byteorder, data, /L64SWAP <span class="comments">;; LONG64</span>
      15: if lendian EQ 1 then byteorder, data, /L64SWAP <span class="comments">;; ULONG64</span>
      ELSE: 
  endcase

end

<span class="comments">; ---------------- Read heap data variable ---------------------------</span>
<a id="cmsv_rhdata:source"></a>pro cmsv_rhdata, block, pointer, data, index, offsets, pdata, unit=unit0, $
                 offset=offset0, status=status, errmsg=errmsg

  status = 0
  errmsg = ''
  if n_elements(offset0) EQ 0 then offset = 0L $
  else                             offset = floor(offset0(0))

  if n_elements(offsets) EQ 0 OR n_elements(index) EQ 0 then begin
      errmsg = 'ERROR: CMSV_RDATA: must specify INDEX and OFFSETS data'
      return
  endif

  if n_elements(offsets) NE n_elements(index) then begin
      errmsg = 'ERROR: CMSV_RDATA: dimensions of OFFSETS and '+ $
        'INDEX do not match'
      return
  endif
  
  if n_elements(unit0) EQ 0 then begin
      errmsg = 'ERROR: CMSV_RDATA: Must specify UNIT when reading heap data'
      return
  endif
  unit = floor(unit0(0))

  sz = size(data)
  odata = temporary(data)

  <span class="comments">;; Create the properly sized array.  Don't worry about getting the</span>
  <span class="comments">;; dimensions right since it will be reformed.</span>
  if sz(0) GT 0 then begin
      data = ptrarr(sz(sz(0)+2))
  endif else begin
      data = ptr_new()
  endelse

  blimits = offset + [0,n_elements(block)-1]

  point_lun, -unit, opos
  null = ptr_new()
  
  for i = 0, n_elements(odata)-1 do begin
      if odata(i) EQ 0 then goto, NEXT_HEAP

      wh = (where(odata(i) EQ index, ct))(0)
      if ct EQ 0 then goto, NEXT_HEAP

      if n_elements(pdata) GT wh then begin
          if pdata(wh) NE null then begin
              data(i) = pdata(wh)
              goto, NEXT_HEAP
          endif
      endif

      point_lun, unit, offsets(wh)

      block1 = 0 & dummy = temporary(block1)
      p1 = 0L
      cmsv_rvtype, block1, p1, varname, sz1, status=status, template=tp1, $
        unit=unit, errmsg=errmsg, structure_name=stname, /heap
      if status EQ 0 then return

      if floor(varname) NE odata(i) then begin
          errmsg = 'ERROR: CMSV_RDATA: heap index mismatch'
          status = 0
          return
      endif

      val = 0 & dummy = temporary(val)
      cmsv_rdata, block1, p1, sz1, val, template=tp1, status=st1, $
        ptr_offsets=offsets, ptr_index=index, ptr_data=pdata, $
        ptr_callback='DEFAULT', unit=unit, errmsg=errmsg
      if status EQ 0 then return

      <span class="comments">;; Deal with case of undefined heap var</span>
      if n_elements(val) GT 0 then data(i) = ptr_new(temporary(val)) $
      else                         data(i) = ptr_new(/allocate_heap)
      if n_elements(pdata) GT wh then pdata(wh) = data(i)
      NEXT_HEAP:
  endfor

  point_lun, unit, opos
  status = 1
  return
end

<span class="comments">; --------------------------- Main procedure ------------------------------</span>
<a id="cmsv_rdata:source"></a>pro cmsv_rdata, block, pointer, sz, data, offset=offset, unit=unit, $
                template=template1, status=status, errmsg=errmsg, $
                start=start, temporary=temp, $
                bytelong=bytelong, bcstring40=bcstring, $
                ptr_offsets=pprivate, ptr_callback=callback0, $
                ptr_index=pindex, ptr_data=pdata

  <span class="comments">;; VAR_DATA</span>
  <span class="comments">;;   LONG - START_DATA TOKEN - value 7</span>
  <span class="comments">;;   for bytes - consecutive bytes</span>
  <span class="comments">;;   for (u)ints - upcast to type long </span>
  <span class="comments">;;   for (u)longs - consecutive longs</span>
  <span class="comments">;;   for pointers - consecutive longs, indices into saved heap data</span>
  <span class="comments">;;   for strings - consecutive STRING's</span>
  <span class="comments">;;   for structs - compacted versions of above</span>
  forward_function fix, uint, complex, dcomplex, make_array

  data = 0 & dummy = temporary(data)
  if n_elements(start) EQ 0 then start = 1
  if n_elements(pointer) EQ 0 then pointer = 0L

  tp0 = sz(sz(0)+1)
  tp = tp0

  <span class="comments">;; =====================================</span>
  if tp EQ 0 then begin     <span class="comments">;; UNDEFINED type</span>
      data = 0
      dummy = temporary(data)
      return
  endif
  <span class="comments">;; =====================================</span>
  if (tp EQ 11) then begin  <span class="comments">;; OBJECT type</span>
      status = 0
      errmsg = 'ERROR: CMSV_RDATA: cannot read object data'
      return
  endif

  if keyword_set(start) then begin
      start_token = cmsv_rraw(/long, block, pointer, status=status, $
                               unit=unit, errmsg=errmsg)
      if start_token NE 7 then begin
          errmsg = 'ERROR: CMSV_RDATA: invalid or corrupted data'
          status = 0
      endif
      if status EQ 0 then return
  endif

  nelt = sz(sz(0)+2)
  <span class="comments">;; =====================================</span>
  if (tp EQ 10) then tp = 3 <span class="comments">;; Pointer type -> LONG</span>

  <span class="comments">;; =====================================</span>
  if (tp EQ 8) then begin   <span class="comments">;; Structure type</span>
      if n_elements(template1) EQ 0 then begin
          errmsg = 'ERROR: CMSV_RDATA: TEMPLATE must be passed for structures'
          status = 0
          return
      endif
      data = reform(replicate(template1(0), nelt), sz(1:sz(0)), /overwrite)
      tp1 = data(0)
      tn = tag_names(data(0)) & nt = n_elements(tn)
      ssz = lonarr(12, nt)
      for j = 0L, nt-1 do begin
          ssz(0, j) = size(data(0).(j))
      endfor
      for i = 0L, nelt-1 do begin
          for j = 0L, nt-1 do begin
              cmsv_rdata, block, pointer, ssz(*,j), dataij, start=0, $
                template=(tp1.(j))(0), $
                ptr_offsets=pprivate, ptr_index=pindex, ptr_data=pdata, $
                ptr_callback=callback0, $
                unit=unit, status=status, errmsg=errmsg
              data(i).(j) = dataij
              
              if status EQ 0 then return
          endfor
      endfor
      return
  endif

  <span class="comments">;; =====================================</span>
  if tp EQ 7 then begin     <span class="comments">;; String type</span>
      if sz(0) EQ 0 then data = '' $
      else data = reform(strarr(sz(sz(0)+2)), sz(1:sz(0)), /overwrite)
      for i = 0L, nelt-1 do begin
          len = cmsv_rraw(/long, block, pointer, status=status, $
                             unit=unit, errmsg=errmsg)
          if status EQ 0 then return
          if len GT 0 OR keyword_set(bcstring) then $
            data(i) = cmsv_rraw(/string, block, pointer, unit=unit, $
                                status=status, errmsg=errmsg)
          if status EQ 0 then return
      endfor
      if sz(0) EQ 0 then data = data(0)
      return
  endif
  
  <span class="comments">;; Sometimes the input data is stored as a different type</span>
  common cmsv_datatypes, stype, sbyte, nbyte, selts
  if n_elements(stype) EQ 0 then begin
      <span class="comments">;;      0      1       2       3        4        5         6    7   8</span>
      <span class="comments">;;          byte     int    long    float    double   complex str struct</span>
      stype =['','BYTE', 'LONG', 'LONG', 'FLOAT', 'DOUBLE', 'FLOAT', '', '' ]
      sbyte =[0,     1,      4,      4,       4,        8,       4,   0,  0 ]
      selts =[0,     1,      1,      1,       1,        1,       2,   0,  0 ]

      <span class="comments">;;                  9     10   11     12       13        14</span>
      <span class="comments">;;            dcomplex   ptr   obj   uint     ulong    long64   ulong64</span>
      stype =[stype,'DOUBLE', 'LONG', '', 'ULONG', 'ULONG', 'LONG64','ULONG64']
      sbyte =[sbyte,      8,     4,   0,     4,       4,        8,        8, 0]
      selts =[selts,      2,     1,   0,     1,       1,        1,        1, 0]
  endif

  status = 0
  nb = sbyte(tp&lt<span class="comments">;16)</span>
  if nb EQ 0 then begin
      errmsg = ('ERROR: CMSV_RDATA: cannot read specified type ('+ $
                strtrim(tp,2)+')')
      return
  endif
  nelt1 = nelt*selts(tp&lt<span class="comments">;16)     ;; Account for complex type</span>
  nb  = nb*nelt1                <span class="comments">;; Number of total bytes</span>
  nb1 = long(floor((nb+3)/4)*4) <span class="comments">;; Number of bytes, rounded to next long</span>
  rt  = stype(tp&lt<span class="comments">;16)            ;; Read type, as opposed to output type</span>

  <span class="comments">;; Error handler returns zero and error condition</span>
  on_ioerror, READ_ERROR
  if 0 then begin
      READ_ERROR: CMSV_RDATA:
      errmsg = 'ERROR: CMSV_RDATA: a read error occurred'
      return
  end

  <span class="comments">;; =====================================</span>
  <span class="comments">;; Byte values handled specially....    argghhh!</span>
  if tp EQ 1 then begin
     if NOT keyword_set(bytelong) then begin
        <span class="comments">;; BYTELONG is NOT set</span>
        nb1 = cmsv_rraw(/long, block, pointer, unit=unit, $
                        errmsg=errmsg, status=status)
        if status EQ 0 then return
        if nb1 NE nb then begin
           errmsg = 'ERROR: CMSV_RDATA: byte count and array size do not agree'
           status = 0
           return
        endif
        <span class="comments">;; Round up to the nearest 4-byte boundary</span>
        nb1 = long(floor((nb+3)/4)*4)
     endif else begin
        <span class="comments">;; BYTELONG is set</span>
        
        <span class="comments">;; Input data will be read as long... required when decoding</span>
        <span class="comments">;; values in code blocks</span>
        nb    = sbyte(3)
        nelt1 = nelt*selts(3)
        nb    = nb*nelt1
        nb1   = nb
        rt    = stype(3)
     endelse
  endif

  <span class="comments">;; =====================================</span>
  <span class="comments">;; Perform default type conversions on the data</span>
  pp = pointer
  if n_elements(block) GT 0 then begin
      if pointer+nb GT n_elements(block) then begin
          dummy = cmsv_rraw(block, pointer, nb, /byte, /buffer, unit=unit, $
                            status=status, errmsg=errmsg)
          if status EQ 0 then return
      endif

      if keyword_set(temp) then $
        data = call_function(rt, (temporary(block))(pp:pp+nb-1), 0, nelt1) $
      else $
        data = call_function(rt, block(pp:pp+nb-1), 0, nelt1)
  endif else begin
      sz1 = size(call_function(rt,0))
      data = make_array(type=sz1(sz1(0)+1), nelt1, /nozero)
      readu, unit(0), data
  endelse
  pointer = pointer + nb1
  cmsv_rconv, data

  <span class="comments">;; =====================================</span>
  <span class="comments">;; Special conversions on certain data types</span>
  case tp of
     2:  data = fix(temporary(data))              <span class="comments">;; 2 - int</span>
     12: data = uint(temporary(data))             <span class="comments">;; 12 - uint</span>
     6:  data = complex(temporary(data), 0, nelt) <span class="comments">;; 6 - complex (float)</span>
     9:  data = dcomplex(temporary(data), 0, nelt)<span class="comments">;; 9 - dcomplex (double)</span>
     else:
  endcase

  <span class="comments">;; Reset error handler</span>
  on_ioerror, NULL

  <span class="comments">;; =====================================</span>
  <span class="comments">;; Convert to pointer type</span>
  if tp0 EQ 10 then if double(!version.release) GE 5D $
    AND n_elements(pprivate) GT 0 AND n_elements(pindex) GT 0 then begin

      <span class="comments">;; The data we have read is actually just an index number into</span>
      <span class="comments">;; the heap.  We must read each heap variable separately.</span>
      if n_elements(callback0) GT 0 then callback = strtrim(callback0(0),2) $
      else                               callback = 'DEFAULT'
      if callback EQ 'DEFAULT' then      callback = 'CMSV_RHDATA'

      if callback NE '' then begin
          call_procedure, callback, block, pointer, data, $
            pindex, pprivate, pdata,$
            unit=unit, offset=offset, status=status, errmsg=errmsg
          if status EQ 0 then return
      endif
  endif
      
  <span class="comments">;; =====================================</span>
  <span class="comments">;; Make sure that the output array has the right dimensions</span>
  if sz(0) GT 0 then data = reform(data, sz(1:sz(0)), /overwrite) $
  else data = data(0)

  status = 1
  return
end
</code>
    </div>
  </body>
</html>