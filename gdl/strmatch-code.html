<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:36 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>strmatch.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="strmatch.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; part of GDL - GNU Data Language (GPL)</span>
<span class="comments">; by Sylwester Arabas &lt;slayoo@igf.fuw.edu.pl></span>
<span class="comments">;</span>
<span class="comments">; search & replace helper for strmatch()</span>
<span class="comments">;</span>
<span class="comments">; 14-Aug-2012 : Now GDL enforces scalar type in FOR loop ... take care</span>
<span class="comments">; of STRLEN ! We ensure to work on pure STRING = '' , not STRING = Array[1]</span>
<span class="comments">; </span>
<a id="STRMATCH_STRREPLACE:source"></a>function STRMATCH_STRREPLACE, str, a, b
pos = STRPOS(str, a)
if (pos eq -1) then return, str
ret = STRMID(str,0,pos)
la = STRLEN(a[0])
last = pos 
for i = pos, STRLEN(str[0]) - 1 do begin
   if STRMID(str,i,la) eq a && (i eq 0 || STRMID(str,i-1,1) ne '\') then begin
      ret += STRMID(str,last,i-last) + b 
      last = i + la
   endif
endfor
ret += STRMID(str,last)
return, ret
end

<span class="comments">; quick & dirty STRMATCH() implementation using STREGEX()</span>
<span class="comments">;</span>
<a id="STRMATCH:source"></a>function STRMATCH, mstr, sstr, fold_case=fold_case
<span class="comments">;</span>
on_error, 2
if (SIZE(sstr))[0] ne 0 then MESSAGE, 'second argument must be a scalar string'
<span class="comments">;</span>
tmp = sstr
<span class="comments">;; . -> \. (but not \.)</span>
tmp = STRMATCH_STRREPLACE(tmp, '.', '\.')
<span class="comments">;; ( -> \( (but not \()</span>
tmp = STRMATCH_STRREPLACE(tmp, '(', '\(')
<span class="comments">; ) -> \) (but not \))</span>
tmp = STRMATCH_STRREPLACE(tmp, ')', '\)')
<span class="comments">; + -> \+ (but not \+)</span>
tmp = STRMATCH_STRREPLACE(tmp, '+', '\+')
<span class="comments">; { -> \{ (but not \{)</span>
tmp = STRMATCH_STRREPLACE(tmp, '{', '\{')
<span class="comments">; } -> \} (but not \})</span>
tmp = STRMATCH_STRREPLACE(tmp, '}', '\}')
<span class="comments">; | -> \| (but not \|)</span>
tmp = STRMATCH_STRREPLACE(tmp, '|', '\|')
<span class="comments">; ^ -> \^ (but not \^)</span>
tmp = STRMATCH_STRREPLACE(tmp, '^', '\^')
<span class="comments">; $ -> \$ (but not \$)</span>
tmp = STRMATCH_STRREPLACE(tmp, '$', '\$')
<span class="comments">; * -> .* (but not \*)</span>
tmp = STRMATCH_STRREPLACE(tmp, '*', '.*')
<span class="comments">; ? -> . (but not \?)</span>
tmp = STRMATCH_STRREPLACE(tmp, '?', '.')
<span class="comments">; [!...] -> [^...] (but not \[!...)</span>
tmp = STRMATCH_STRREPLACE(tmp, '[!', '[^')
<span class="comments">; the leading a trailing markers</span>
tmp = '^' + tmp + '$'
return, STREGEX(mstr, tmp, /boolean, fold_case=fold_case)
end
</code>
    </div>
  </body>
</html>