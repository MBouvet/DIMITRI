<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:48 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsv_wrec.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsv_wrec.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSV_WREC</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Write SAVE-formatted record header to output block or file</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   CMSV_WDATA, BLOCK, POINTER, DATA, IDENT, UNIT=UNIT, $</span>
<span class="comments">;               INITIALIZE=INITIALIZE, NO_DATA=NO_DATA, $</span>
<span class="comments">;               NO_TYPE=NO_TYPE, COMPATIBILITY=COMPAT, $</span>
<span class="comments">;               BLOCK_TYPE=BLOCK_TYPE, BLOCK_NAME=BLOCK_NAME,</span>
<span class="comments">;               NEXT_BLOCK=NEXT_BLOCK, $</span>
<span class="comments">;               [ ... EXTRA KEYWORDS ... ]</span>
<span class="comments">;               OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   This procedure writes most types of IDL SAVE record, including the</span>
<span class="comments">;   header and contents.  The header consists of four bytes at the</span>
<span class="comments">;   beginning of each record which indentifies the type and size of</span>
<span class="comments">;   the record.  This procedure also writes the contents of certain</span>
<span class="comments">;   records, as noted below.</span>
<span class="comments">;</span>
<span class="comments">;   Users can specify the block type by passing the BLOCK_TYPE or</span>
<span class="comments">;   BLOCK_NAME keywords.  The values listed in the following table are</span>
<span class="comments">;   supported.  CMSV_WREC writes the contents of essentially all</span>
<span class="comments">;   record types as well.  Some records do not contain any contents at</span>
<span class="comments">;   all (those entries marked with an [empty]) and thus require no</span>
<span class="comments">;   further processing.</span>
<span class="comments">;</span>
<span class="comments">;    BLOCK_TYPE      BLOCK_TYPE         WRITE RECORD CONTENTS WITH...</span>
<span class="comments">;</span>
<span class="comments">;       0         = 'START_MARKER'      [empty]</span>
<span class="comments">;       1         = 'COMMON_BLOCK'      [this procedure]</span>
<span class="comments">;       2         = 'VARIABLE'          [this procedure]</span>
<span class="comments">;       3         = 'SYSTEM_VARIABLE'   [this procedure]</span>
<span class="comments">;       6         = 'END_MARKER'        [empty]</span>
<span class="comments">;       10        = 'TIMESTAMP'         [this procedure]</span>
<span class="comments">;       12        = 'COMPILED'          no published procedure</span>
<span class="comments">;       13        = 'IDENTIFICATION'    [this procedure]</span>
<span class="comments">;       14        = 'VERSION'           [this procedure]</span>
<span class="comments">;       15        = 'HEAP_INDEX'        [this procedure]</span>
<span class="comments">;       16        = 'HEAP_DATA'         [this procedure]</span>
<span class="comments">;       17        = 'PROMOTE64'         [empty]</span>
<span class="comments">;       19        = 'NOTICE'            [this procedure]</span>
<span class="comments">;</span>
<span class="comments">;   For records that contain variable data, the external procedures</span>
<span class="comments">;   CMSV_WVTYPE and/or CMSV_WDATA may be used, however it is not</span>
<span class="comments">;   recommended, since the record header must finally be re-written by</span>
<span class="comments">;   the user.  Users can write the entire record with this procedure.</span>
<span class="comments">;</span>
<span class="comments">;   After issuing a POINT_LUN, or after writing the BLOCK to disk, the</span>
<span class="comments">;   block cache in BLOCK must be reset using the /INITIALIZE keyword.</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; SPECIFIC RECORD TYPES</span>
<span class="comments">;</span>
<span class="comments">;   CMSV_WREC reads certain specific record types automatically based</span>
<span class="comments">;   on data passed in the DATA parameter.  </span>
<span class="comments">;</span>
<span class="comments">;   Records of type 'VARIABLE' (2), 'SYSTEM_VARIABLE' (3) and</span>
<span class="comments">;   'HEAP_DATA' (16) require both the DATA and IDENT parameters.  For</span>
<span class="comments">;   the first two record types, the IDENT parameter is the name of the</span>
<span class="comments">;   variable, as a scalar string.  Variable names should be valid IDL</span>
<span class="comments">;   variable names, uppercase, and have no embedded spaces.  For the</span>
<span class="comments">;   'HEAP_DATA' record type, the IDENT parameter is the heap index</span>
<span class="comments">;   value, as described below.  The DATA itself can be any supported</span>
<span class="comments">;   IDL variable type (as described in CMSV_WVTYPE).</span>
<span class="comments">;</span>
<span class="comments">;   For records that accept data in the form of a structure, as listed</span>
<span class="comments">;   below, the listed structure tag entries are optional.  If the user</span>
<span class="comments">;   does not provide a value, then a suitable default will be computed</span>
<span class="comments">;   by this procedure (listed in parentheses).</span>
<span class="comments">;</span>
<span class="comments">;   A record of type 'VERSION' (14) has the following structure:</span>
<span class="comments">;</span>
<span class="comments">;         { FORMAT_VERSION: 0L, $   ; Format version number of file (5)</span>
<span class="comments">;           ARCH: '', $             ; !VERSION.ARCH of creating host</span>
<span class="comments">;           OS: '', $               ; !VERSION.OS of creating host</span>
<span class="comments">;           RELEASE: '' }           ; !VERSION.RELEASE of creating host</span>
<span class="comments">;</span>
<span class="comments">;   A record of type 'TIMESTAMP' (10) has the following structure:</span>
<span class="comments">;</span>
<span class="comments">;          { SAVE_DATE: '', $  ; Date the save file was created (SYSTIME(0))</span>
<span class="comments">;            SAVE_USER: '', $  ; User name who  created file ('UNKNOWN')</span>
<span class="comments">;            SAVE_HOST: '' }   ; Host name that created file ('UNKNOWN')</span>
<span class="comments">;</span>
<span class="comments">;   Save files created by IDL version 4 do not contain a timestamp</span>
<span class="comments">;   record.  Under Unix this procedure will attempt to discover the</span>
<span class="comments">;   user and host names automatically.</span>
<span class="comments">;</span>
<span class="comments">;   A record of type 'IDENTIFICATION' (13) has the following</span>
<span class="comments">;   structure:</span>
<span class="comments">;</span>
<span class="comments">;          { AUTHOR: '', $  ; Author of SAVE file ('')</span>
<span class="comments">;            TITLE:  '', $  ; Title of SAVE file  ('')</span>
<span class="comments">;            IDCODE: '' }   ; Identifying code for SAVE file ('')</span>
<span class="comments">;</span>
<span class="comments">;   It appears that this record is not used in IDL version 5 or later.</span>
<span class="comments">;</span>
<span class="comments">;   A record of type 'COMMON_BLOCK' (1) defines a named common block</span>
<span class="comments">;   and its variables.  A common block descriptor consists of an array</span>
<span class="comments">;   of strings whose first element is the common block name, and whose</span>
<span class="comments">;   remaining elements are the common block variable names.  Thus, a</span>
<span class="comments">;   common block descriptor must have at least two elements.  No</span>
<span class="comments">;   variable data are stored with the common block definition.</span>
<span class="comments">;</span>
<span class="comments">;   When a record of type 'NOTICE' (19) defines a notice to be</span>
<span class="comments">;   included in the save file.  It is a structure with one field:</span>
<span class="comments">;   {TEXT: ''}, where TEXT is the text content of the notice.</span>
<span class="comments">;</span>
<span class="comments">;   A record of type 'HEAP_INDEX' (15) defines the heap index in a</span>
<span class="comments">;   SAVE file.  The heap index specifies a list of which heap</span>
<span class="comments">;   variables are stored in the current save file.  These indices are</span>
<span class="comments">;   simply numbers which identify each heap variable (i.e.,</span>
<span class="comments">;   "&lt;PtrHeapVar2>" would have an index of 2).  The heap index can use</span>
<span class="comments">;   any numbers to identify the heap data; however it is required that</span>
<span class="comments">;   all index entries have corresponding heap data values.</span>
<span class="comments">;</span>
<span class="comments">; WRITING HEAP DATA</span>
<span class="comments">;</span>
<span class="comments">;   If your data contains heap data and/or pointers, then users must</span>
<span class="comments">;   take special care in writing their data.  Writing heap data is</span>
<span class="comments">;   actually more straightforward than reading it.  There are several</span>
<span class="comments">;   steps involved which can be summarized as followed: (1) take</span>
<span class="comments">;   inventory of HEAP data; (2) write HEAP_INDEX record; (3) write one</span>
<span class="comments">;   HEAP_DATA record for each heap variable; and (4) write any other</span>
<span class="comments">;   variables using the heap index.</span>
<span class="comments">;</span>
<span class="comments">;   (1) Take inventory of heap data.  Before writing any data to the</span>
<span class="comments">;       SAVE file, use the CMSV_PTRSUM procedure to discover all</span>
<span class="comments">;       pointer variables in the data set, like so:</span>
<span class="comments">;</span>
<span class="comments">;          cmsv_ptrsum, var, ptrlist</span>
<span class="comments">;</span>
<span class="comments">;       PTRLIST contains an array of any heap variables pointed to by</span>
<span class="comments">;       VAR (including structures or pointed-to variables).  If</span>
<span class="comments">;       multiple variables are to be written, then the inventory must</span>
<span class="comments">;       contain the union of all heap variables.</span>
<span class="comments">;</span>
<span class="comments">;   (2) Write a HEAP_INDEX record.  The heap index is an array of long</span>
<span class="comments">;       integers which identify the heap variables.  In principle it</span>
<span class="comments">;       doesn't matter which integers are used, however there must be</span>
<span class="comments">;       a one-to-one correspondence between the entries in the heap</span>
<span class="comments">;       index and the heap identifiers used in the next step.  In this</span>
<span class="comments">;       example a simple LINDGEN is used:</span>
<span class="comments">;</span>
<span class="comments">;           index = lindgen(n_elements(ptrlist))</span>
<span class="comments">;           cmsv_wrec, block, pointer, index, block_name='HEAP_INDEX', $</span>
<span class="comments">;             offset=offset</span>
<span class="comments">;</span>
<span class="comments">;   (3) Write one HEAP_DATA record for each heap variable.  Issue one</span>
<span class="comments">;       CMSV_WREC call for each entry in PTRLIST, as follows for the</span>
<span class="comments">;       ith heap variable:</span>
<span class="comments">;</span>
<span class="comments">;           cmsv_wrec, block, pointer, ptrlist(i), block_name='HEAP_DATA', $</span>
<span class="comments">;             ptr_index=index, ptr_data=ptrlist, offset=offset</span>
<span class="comments">;</span>
<span class="comments">;       Note that the PTR_INDEX and PTR_DATA keywords are required</span>
<span class="comments">;       because heap data may itself contain pointers.  The PTR_INDEX</span>
<span class="comments">;       and PTR_DATA keywords enable the CMSV_WREC procedure to write</span>
<span class="comments">;       appropriate descriptors when it encounters pointers.</span>
<span class="comments">;</span>
<span class="comments">;   (4) Write remaining data.  For the ith variable, use:</span>
<span class="comments">;</span>
<span class="comments">;          cmsv_wrec, block, pointer, var(i), name(i), block_name='VARIABLE',$</span>
<span class="comments">;             ptr_index=index, ptr_data=ptrlist, offset=offset</span>
<span class="comments">;</span>
<span class="comments">;       As above, using the PTR_INDEX and PTR_DATA keywords will allow</span>
<span class="comments">;       the CMSV_WREC procedure to write the appropriate data.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; BLOCK, POINTER, OFFSET</span>
<span class="comments">;</span>
<span class="comments">;   This procedure writes data to a byte array or a file.  If the UNIT</span>
<span class="comments">;   keyword is specified then file is sent to the specified unit</span>
<span class="comments">;   number rather than to the buffer BLOCK.  However, the intent is</span>
<span class="comments">;   for users to accumulate a significant amount of data in a BLOCK</span>
<span class="comments">;   and then write it out with a single call to WRITEU.  Users should</span>
<span class="comments">;   be aware that the block can be larger than the buffered data, so</span>
<span class="comments">;   they should use something like the following:</span>
<span class="comments">;</span>
<span class="comments">;          WRITEU, UNIT, BLOCK(0:POINTER-1)</span>
<span class="comments">;</span>
<span class="comments">;   When library routines do indeed write buffered BLOCK data to disk,</span>
<span class="comments">;   they will appropriately reset the BLOCK and POINTER.  Namely,</span>
<span class="comments">;   BLOCK will be reset to empty, and POINTER will be reset to zero.</span>
<span class="comments">;   OFFSET will be advanced the according number of bytes.</span>
<span class="comments">;</span>
<span class="comments">;   The terminology is as follows: BLOCK is a byte array which</span>
<span class="comments">;   represents a portion of, or an entire, IDL SAVE file.  The block</span>
<span class="comments">;   may be a cached portion of an on-disk file, or an entire in-memory</span>
<span class="comments">;   SAVE file.  POINTER is the current file pointer within BLOCK</span>
<span class="comments">;   (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a</span>
<span class="comments">;   POINTER value of 0 refers to the start of the block.  OFFSET is</span>
<span class="comments">;   the file offset of the 0th byte of BLOCK; thus "POINT_LUN,</span>
<span class="comments">;   OFFSET+POINTER" should point to the same byte as BLOCK[POINTER].</span>
<span class="comments">;   The following diagram shows the meanings for BLOCK, POINTER and</span>
<span class="comments">;   OFFSET schematically:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;                 0 &lt;-  OFFSET  -> |</span>
<span class="comments">;   FILE          |----------------|------*--------|---------></span>
<span class="comments">;</span>
<span class="comments">;   BLOCK                          |------*--------|</span>
<span class="comments">;                                  0      ^ POINTER</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK - a byte array, a cache of the SAVE file.  Users will</span>
<span class="comments">;           usually not access this array directly.  Users are advised</span>
<span class="comments">;           to clear BLOCK after calling POINT_LUN or writing the</span>
<span class="comments">;           block to disk.</span>
<span class="comments">;</span>
<span class="comments">;   POINTER - a long integer, a pointer to the next byte to be read</span>
<span class="comments">;             from BLOCK.  CMSVLIB routines will automatically</span>
<span class="comments">;             advance the pointer.</span>
<span class="comments">;</span>
<span class="comments">;   DATA - the record contents to be written, as describe above.</span>
<span class="comments">;</span>
<span class="comments">;   IDENT - for record types 'VARIABLE' (2) and 'SYSTEM_VARIABLE' (3),</span>
<span class="comments">;           the name of the variable as a scalar string.  For record</span>
<span class="comments">;           type 'HEAP_DATA' (16), the heap index identifier as a</span>
<span class="comments">;           scalar long integer.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK_NAME - a scalar string specifying the record type, as</span>
<span class="comments">;                described above.  The BLOCK_TYPE keyword takes</span>
<span class="comments">;                precedence over BLOCK_NAME.</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK_TYPE - a scalar integer specifying the record type, as</span>
<span class="comments">;                described above.</span>
<span class="comments">;</span>
<span class="comments">;   NEXT_BLOCK - if specified, the file offset of the next record</span>
<span class="comments">;                location.</span>
<span class="comments">;                Default: the offset will be computed automatically.</span>
<span class="comments">;</span>
<span class="comments">;   INITIALIZE - if the keyword is set, then the BLOCK is emptied and</span>
<span class="comments">;                the POINTER is reset before any new data is written.</span>
<span class="comments">;</span>
<span class="comments">;   NO_TYPE - if set, no type descriptor or data are written for</span>
<span class="comments">;             variable records.</span>
<span class="comments">;</span>
<span class="comments">;   NO_DATA - if set, no data are written for variable records.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;   TEMPORARY - if set, then the input DATA are discarded after being</span>
<span class="comments">;               written, as a memory economy provision.</span>
<span class="comments">;</span>
<span class="comments">;   PTR_INDEX - a heap index array for the data being written, if any</span>
<span class="comments">;               heap data records have been written.</span>
<span class="comments">;               Default: no pointers are written</span>
<span class="comments">;</span>
<span class="comments">;   PTR_DATA - an array of pointers, pointing to the heap values being</span>
<span class="comments">;              written.</span>
<span class="comments">;              Default: no pointers are written</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a file unit.  If specified then data are directed to the</span>
<span class="comments">;          file unit rather than to the buffer BLOCK.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSET - the file offset of byte zero of BLOCK.  </span>
<span class="comments">;            Upon output, if the file pointer is advanced, OFFSET will</span>
<span class="comments">;            also be changed.</span>
<span class="comments">;            (OFFSET is not currently used by this routine)</span>
<span class="comments">;            Default: 0</span>
<span class="comments">;</span>
<span class="comments">;   COMPATIBILITY - a string, which describes the format to be used in</span>
<span class="comments">;          the output file.  Possible values are:</span>
<span class="comments">;</span>
<span class="comments">;                  'IDL4' - format of IDL version 4;</span>
<span class="comments">;                  'IDL5' - format of IDL versions 5.0-5.3;</span>
<span class="comments">;                  'IDL6' - not supported yet, for versions 5.4-above;</span>
<span class="comments">;                  'RIVAL1' - same as 'IDL5', plus a directory entry is</span>
<span class="comments">;                            written to the file.</span>
<span class="comments">;           Note that files written in IDL5 format may still be</span>
<span class="comments">;           readable by IDL v.4.</span>
<span class="comments">;           Default: 'IDL5'</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, this keyword will contain 1 for success and</span>
<span class="comments">;            0 for failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return with a failure, this keyword will contain the</span>
<span class="comments">;            error condition as a string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 2000</span>
<span class="comments">;   Documented, 24 Jan 2001</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   Added NOTICE record type, 09 Jun 2003, CM</span>
<span class="comments">;   NOTE: remember to modify CMSVLIB.PRO when changing library!</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsv_wrec.pro,v 1.10 2009/11/22 22:50:49 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, 2003, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

<a id="cmsv_wcomm:source"></a>pro cmsv_wcomm, block, pointer, names, $
                status=status, errmsg=errmsg

  status = 0
  sz = size(names)
  if sz(sz(0)+1) NE 7 then begin
      errmsg = 'ERROR: CMSV_WCOMM: DATA must contain an array of strings'
      return
  endif
  ncommon = n_elements(names)
  if ncommon LT 2 then begin
      errmsg = 'ERROR: CMSV_WCOMM: DATA must contain at least two elements'
      return
  endif

  cmsv_wraw, /long, block, pointer, ncommon, $
    status=status, errmsg=errmsg
  if status EQ 0 then return

  cmsv_wraw, /string, block, pointer, names, $
    status=status, errmsg=errmsg

  return
end

<a id="cmsv_wheap:source"></a>pro cmsv_wheap, block, pointer, indices, $
                status=status, errmsg=errmsg

  <span class="comments">;; HEAP_INDEX</span>
  <span class="comments">;;   LONG - N_HEAP - number of heap values</span>
  <span class="comments">;;   LONGxN_HEAP - heap indices</span>

  n_heap = n_elements(indices)
  if n_heap LE 0 then return

  cmsv_wraw, /long, block, pointer, [n_heap, indices], $
    status=status, errmsg=errmsg

  return
end

<a id="cmsv_wstamp:source"></a>pro cmsv_wstamp, block, pointer, offset=offset, $
                 status=status, errmsg=errmsg, $
                 save_date=save_date, save_user=save_user, $
                 save_host=save_host, _extra=extra

  common cmsv_wstamp_state, username, hostname

  status = 1

  <span class="comments">;; Retrieve the username -- we need some Windows help here!</span>
  if n_elements(save_user) EQ 0 then begin
      if n_elements(username) NE 1 then begin
          xusername = (getenv('USER'))(0)
          if xusername EQ '' then begin
              xusername = (getenv('LOGNAME'))(0)
              if xusername EQ '' then begin
                  if !version.os_family EQ 'unix' then $
                    spawn, 'whoami', xusername
                  if xusername(0) EQ '' then $
                    xusername = 'UNKNOWN'
              endif
          endif
          username = xusername(0)
      endif
      save_user = username
  endif

  <span class="comments">;; Retrieve the hostname -- we need some Windows help here!</span>
  if n_elements(save_host) EQ 0 then begin
      if n_elements(hostname) NE 1 then begin
          xhostname = (getenv('HOST'))(0)
          if xhostname EQ '' then begin
              if !version.os_family EQ 'unix' then $
                spawn, 'hostname', xhostname
              if xhostname(0) EQ '' then $
                xhostname = 'UNKNOWN'
          endif
          hostname = xhostname(0)
      endif
      save_host = hostname
  endif

  if n_elements(save_date) EQ 0 then save_date = systime(0)

  <span class="comments">;; TIMESTAMP</span>
  <span class="comments">;;   BYTEx400 - empty (?) legacy area</span>
  <span class="comments">;;   STRING - save date (as a string)</span>
  <span class="comments">;;   STRING - user name</span>
  <span class="comments">;;   STRING - hostname</span>

  pointer = pointer + '400'xl  <span class="comments">;; Advance over 400 byte blank space</span>
  cmsv_wraw, /string, block, pointer, $
    strtrim([save_date(0), save_user(0), save_host(0)],2), $
    status=status, errmsg=errmsg

end

<a id="cmsv_wversion:source"></a>pro cmsv_wversion, block, pointer, status=status, errmsg=errmsg, $
                   format_version=major_release, arch=arch, os=os, $
                   release=release, compatible=compat0, _extra=extra

  if n_elements(major_release) EQ 0 then major_release = 5L
  if n_elements(arch) EQ 0 then arch = !version.arch
  if n_elements(os) EQ 0 then os = !version.os
  if n_elements(release) EQ 0 then release = !version.release

  if n_elements(compat0) GT 0 then begin
      compat = strupcase(strtrim(compat0(0),2))
      case compat of 
          'IDL4': major_release = 4L
          'IDL5': major_release = 5L
          'IDL6': major_release = 6L
          'RIVAL1': major_release = 5L
          ELSE:   begin
              errmsg = 'ERROR: CMSV_WREC: unrecognized COMPAT value'
              status = 0
              return
          end
      endcase
  endif

  <span class="comments">;; VERSION_STAMP</span>
  <span class="comments">;;   LONG - Major version number</span>
  <span class="comments">;;   STRING_DATA - Host architecture ( = !version.arch )</span>
  <span class="comments">;;   STRING_DATA - Host OS ( = !version.os )</span>
  <span class="comments">;;   STRING_DATA - IDL release ( = !version.release )</span>

  cmsv_wraw, /long, block, pointer, floor(major_release(0)), $
    status=status, errmsg=errmsg
  if status EQ 0 then return
  cmsv_wraw, /string, block, pointer, $
    strtrim([arch(0), os(0), release(0)],2), $
    status=status, errmsg=errmsg

  return
end

<a id="cmsv_wident:source"></a>pro cmsv_wident, block, pointer, status=status, errmsg=errmsg, $
                 author=author, title=title, idcode=idcode, $
                 _EXTRA=extra

  if n_elements(author) EQ 0 then author = ''
  if n_elements(title) EQ 0 then title = ''
  if n_elements(idcode) EQ 0 then idcode = ''

  cmsv_wraw, /string, block, pointer, $
    strtrim([author(0), title(0), idcode(0)],2), $
    status=status, errmsg=errmsg

  return
end

<span class="comments">; --------------------------- Read Notice --------------------</span>

<a id="cmsv_wnotice:source"></a>pro cmsv_wnotice, block, pointer, status=status, errmsg=errmsg, $
                  text=text, _EXTRA=extra

  <span class="comments">;; NOTICE</span>
  <span class="comments">;;   STRING - notice text</span>

  if n_elements(text) EQ 0 then text = ''

  cmsv_wraw, /string, block, pointer, strtrim(text,2), $
    status=status, errmsg=errmsg

  return
end


<a id="cmsv_wrec:source"></a>pro cmsv_wrec, block, pointer, data, name, unit=unit, offset=offset0, $
               initialize=init, finish=finish, no_data=nodata, no_type=notype,$
               block_type=blocktype, block_name=blockname, next_block=np, $
               compatibility=compat, $
               status=status, errmsg=errmsg, _EXTRA=extra

  common cmsave_block_names, block_ntypenames, block_typenames
  if n_elements(block_ntypenames) EQ 0 then begin
      cmsv_rrec, /qblocknames
  endif

  if keyword_set(init) then begin
      pointer = 0L
      block = 0 & dummy = temporary(block)
  endif
  if n_elements(pointer) EQ 0 then pointer = 0L
  
  if n_elements(blocktype) EQ 0 then begin
      wh = where(strupcase(blockname(0)) EQ block_typenames, ct)
      if ct EQ 0 then begin
          errmsg = 'ERROR: CMSV_WREC: block type '+blockname(0)+' is unknown'
          status = 0
          return
      endif
      blocktype = wh(0)
  endif

  <span class="comments">;; Store position of file pointer at beginning of record</span>
  p0 = pointer
  
  rechead = lonarr(4)
  rechead(0) = long(floor(blocktype(0)))
  if n_elements(offset0) EQ 0 then offset = 0L $
  else                             offset = floor(offset0(0))

  <span class="comments">;; Default pointer to next block assumes no data in record</span>
  if n_elements(np) GT 0 then rechead(1) = floor(np(0)) $
  else                        rechead(1) = offset + p0 + 4*4

  cmsv_wraw, /long, block, pointer, rechead, $
    status=status, errmsg=errmsg

  if status EQ 0 OR keyword_set(finish) then return

  p1 = pointer

  blockname = block_typenames(blocktype(0) &lt<span class="comments">; block_ntypenames)</span>

  vdata = (blockname EQ 'VARIABLE' OR blockname EQ 'SYSTEM_VARIABLE' OR $
           blockname EQ 'HEAP_DATA')

  if vdata AND keyword_set(notype) then return

  case blockname of
      'COMMON_BLOCK': cmsv_wcomm, block, pointer, data, $
        status=status, errmsg
      'TIMESTAMP': cmsv_wstamp, block, pointer, $
        status=status, errmsg=errmsg, _EXTRA=data
      'VERSION': cmsv_wversion, block, pointer, compatible=compat, $
        status=status, errmsg=errmsg, _EXTRA=data
      'IDENTIFICATION': cmsv_wident, block, pointer, $
        status=status, errmsg=errmsg, _EXTRA=data
      'HEAP_INDEX': cmsv_wheap, block, pointer, data, $
        status=status, errmsg=errmsg
      'VARIABLE': cmsv_wvtype, block, pointer, data, name, $
        status=status, errmsg=errmsg
      'SYSTEM_VARIABLE': cmsv_wvtype, block, pointer, data, name, $
        status=status, errmsg=errmsg, /system
      'HEAP_DATA': cmsv_wvtype, block, pointer, data, name, $
        status=status, errmsg=errmsg, /heap
      ELSE: dummy = 1
  endcase        

  if status EQ 0 then return
  
  <span class="comments">;; If UNIT is specified then we write out the accumulated BLOCK data</span>
  <span class="comments">;; up to this point.  CMSV_WDATA will write out its own data.</span>
  if n_elements(unit) GT 0 AND pointer GT 0 then begin
      offset1 = offset
      unit1 = floor(unit(0))

      writeu, unit1, block(0:pointer-1)

      <span class="comments">;; Reinitialize state</span>
      if n_elements(block) GT 65536L then begin
          <span class="comments">;; Clear the block if it is too large</span>
          block = 0 & dummy = temporary(block)
          if n_elements(block) GT 0 then block(*) = 0
      endif
      offset = offset + pointer
      pointer = 0L
  endif

  <span class="comments">;; Write the variable data if it exists</span>
  if vdata AND NOT keyword_set(nodata) AND n_elements(data) GT 0 then begin
      cmsv_wdata, block, pointer, data, unit=unit, $
        status=status, errmsg=errmsg, _EXTRA=extra
      if status EQ 0 then return
      if n_elements(unit1) GT 0 then $
        point_lun, -unit1, offset
  endif

  <span class="comments">;; Rewrite the record header using the new header.</span>
  if pointer NE p1 AND n_elements(np) EQ 0 then begin
      rechead(1) = offset + pointer

      if n_elements(unit1) GT 0 then begin
          <span class="comments">;; Be careful: we have already written the record header to</span>
          <span class="comments">;; disk, so we need to seek backwards, write the new header,</span>
          <span class="comments">;; and then seek forwards again.</span>
          point_lun, -unit1, offset2
          cmsv_wraw, /long, block1, 0L, rechead, $
            status=status, errmsg=errmsg
          if status EQ 0 then return
          point_lun, unit1, offset1+p0
          writeu, unit1, block1(0:15)
          point_lun, unit1, offset2

      endif else begin
          <span class="comments">;; It's easy if the data has not been written yet</span>
          cmsv_wraw, /long, block, (p0+0), rechead, $
            status=status, errmsg=errmsg
          if status EQ 0 then return
      endelse
  endif

  status = 1
  return
end
</code>
    </div>
  </body>
</html>