<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:32 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsavedir.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsavedir.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSAVEDIR</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Display a directory of the variables in an IDL SAVE file.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   CMSAVEDIR, filename [, /VERBOSE, /QUIET, ... ]</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   CMSAVEDIR will display a listing of the variables and other</span>
<span class="comments">;   objects stored in an IDL SAVE file.</span>
<span class="comments">;</span>
<span class="comments">;   For command-line users the primary function of CMSAVEDIR will be</span>
<span class="comments">;   to find out what data is stored in a file and when it was saved.</span>
<span class="comments">;   For that, they simply need to type: CMSAVEDIR, 'myfile.sav'</span>
<span class="comments">;</span>
<span class="comments">;   CMSAVEDIR also offers a number of features for programmers.</span>
<span class="comments">;   CMSAVEDIR essentially interrogates the save file and discovers the</span>
<span class="comments">;   numbers, names and types of each of the variables stored in the</span>
<span class="comments">;   file.  Programmers can use that information to decide whether or</span>
<span class="comments">;   how to open a file using the other routines in the CMSVLIB.</span>
<span class="comments">;   Various keyword parameters are used return this information, as</span>
<span class="comments">;   documented below.</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; COMPATIBILITY:</span>
<span class="comments">;</span>
<span class="comments">;   -- File Format --</span>
<span class="comments">;</span>
<span class="comments">;   CMSAVEDIR cannot examine compressed save files, or files larger</span>
<span class="comments">;   than 2 gigabytes.</span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   FILENAME - a scalar string, the name of the file to be examined.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   VERBOSE - if set, print more detailed information about the input file.</span>
<span class="comments">;</span>
<span class="comments">;   QUIET - if set, then do not print any output.  Programmers can use</span>
<span class="comments">;           this keyword to allow CMSAVEDIR to return information</span>
<span class="comments">;           about the file silently.</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon output, 1 for success, otherwise to indicate</span>
<span class="comments">;            failure.</span>
<span class="comments">;   ERRMSG - upon output, if a failure occurs, a message describing</span>
<span class="comments">;            the error condition.</span>
<span class="comments">;  </span>
<span class="comments">;   N_VARIABLES - upon output, the number of variables in the file.</span>
<span class="comments">;   VAR_NAMES - upon output, contains a string array of the names of</span>
<span class="comments">;               the variables stored in the file.</span>
<span class="comments">;   TYPES - upon output, an 11xN_VARIABLES array containing the SIZE</span>
<span class="comments">;           information of each variable in the file.</span>
<span class="comments">;</span>
<span class="comments">;   N_PRO - upon output, the number of procedures stored in the file.</span>
<span class="comments">;   PRO_NAMES - upon output, the names of the procedures stored in the</span>
<span class="comments">;               file, as a string array.</span>
<span class="comments">;</span>
<span class="comments">;   N_FUNCTION - upon output, the number of functions stored in the</span>
<span class="comments">;                 file.</span>
<span class="comments">;   FUNC_NAMES - upon output, the names of the functions stored in the</span>
<span class="comments">;                file, as a string array.</span>
<span class="comments">;</span>
<span class="comments">;   NAMED_STRUCTS - upon output, a string array listing any named</span>
<span class="comments">;                   structures which appear in the SAVE file.</span>
<span class="comments">;   NAMED_CLASSES - upon output, a string array listing any named</span>
<span class="comments">;                   class structures which appear in the SAVE file.</span>
<span class="comments">;</span>
<span class="comments">;   TIMESTAMP - upon output, contains the timestamp record information</span>
<span class="comments">;               in a structure.  The fields of the structure are:</span>
<span class="comments">;                    SAVE_DATE - string - date saved</span>
<span class="comments">;                    SAVE_USER - string - user who saved file</span>
<span class="comments">;                    SAVE_HOST - string - host name on which file</span>
<span class="comments">;                                         saved</span>
<span class="comments">;</span>
<span class="comments">;   VERSION - upon output, contains the version record information in</span>
<span class="comments">;             a structure.  The fields of the structure are:</span>
<span class="comments">;                    FORMAT_VERSION - integer - major format version</span>
<span class="comments">;                    ARCH    - string - saving host's !VERSION.ARCH</span>
<span class="comments">;                    OS      - string - saving host's !VERSION.OS</span>
<span class="comments">;                    RELEASE - string - saving host's !VERSION.RELEASE</span>
<span class="comments">;</span>
<span class="comments">;   NOTICE - upon output, contains any textual notice included within</span>
<span class="comments">;            the file.  The fields of the structure are:</span>
<span class="comments">;                    TEXT - string - text of the notice</span>
<span class="comments">;</span>
<span class="comments">;   FORCE - if set, will force CMSAVEDIR to open the file even if it</span>
<span class="comments">;           detects a potential incompatibility.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   IDL> cmsavedir, 'int_str_intarr.sav'</span>
<span class="comments">;   ** int_str_intarr.sav</span>
<span class="comments">;   ** Sun Apr  9 20:28:25 2000 (craigm@beach.gsfc.nasa.gov)</span>
<span class="comments">;   ** IDL v5.2 (linux)</span>
<span class="comments">;     A               INT       =        0</span>
<span class="comments">;     B               STRING    = 'hello'</span>
<span class="comments">;     C               INT       = Array[3]</span>
<span class="comments">;   ** 3 variable(s), 0 heap value(s) and 0 procedure(s) in 1376 bytes</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, CMSAVE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Documented, 12 Jan 2001, CM</span>
<span class="comments">;   Added USAGE message, 09 Jun 2001, CM</span>
<span class="comments">;   Fixed bug in printing common variables, 17 Mar 2002, CM</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   Added NOTICE record type, 09 Jun 2003, CM</span>
<span class="comments">;   </span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsavedir.pro,v 1.17 2003/06/28 22:21:07 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2002, 2003, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

<a id="cmsavedir:source"></a>pro cmsavedir, filename, types=vtypes, force=force, status=status, $
               var_names=vnames, pro_names=pronames, func_names=funnames, $
               n_variables=nvar, n_pro=npro, n_function=nfunc, $
               errmsg=errmsg, verbose=all, read_heap=rheap, raw=raw, $
               timestamp=stamp, version=vers, quiet=quiet, $
               named_structs=structs, named_classes=classes, $
               notice=notice

  forward_function cmsv_rraw

  status = 0
  errmsg = ''

  if n_params() EQ 0 then begin
      message, 'USAGE: CMSAVEDIR, filename, ...', /info
      return
  endif

  catch, catcherr
  if catcherr EQ 0 then lib = cmsvlib(/query) else lib = 0
  catch, /cancel
  if lib EQ 0 then $
    message, 'ERROR: The CMSVLIB library must be in your IDL path.'

  <span class="comments">;; Open the file</span>
  get_lun, unit
  cmsv_open, unit, filename(0), pp, status=status, errmsg=errmsg, $
    force=force, compressed=compressed
  if status NE 1 then begin
      free_lun, unit
      message, errmsg, /info
      return
  endif
  pp0 = pp

  <span class="comments">;; Initial set-up</span>
  <span class="comments">;; promote64 is due to a format change in IDL 5.4</span>
  <span class="comments">;; stamp is the timestamp structure</span>
  <span class="comments">;; vers  is the version structure</span>
  <span class="comments">;; firstvar is used to know when we hit the first variable so we can</span>
  <span class="comments">;;          print the header of the display</span>
  <span class="comments">;; rstamp and rvers are use to know when we have read the timestamp</span>
  <span class="comments">;;        and version records.</span>

  print_raw = keyword_set(raw)
  promote64 = 0 & opromote64 = 0
  stamp = {save_date: '', save_user: '', save_host: ''}
  vers  = {arch: '', os: '', release: '4.X', format_version: 0L}
  notice = {text: ''}
  firstvar = 1 & nvar = 0L & npro = 0L & nfunc = 0L & nheap = 0L
  rstamp = 0 & rvers = 0
  fs = fstat(unit)
  filesize = fs.size

  <span class="comments">;; Empty the NAMED_STRUCTS and NAMED_CLASSES keywords, so they can</span>
  <span class="comments">;; be filled in fresh by CMSV_RVTYPE</span>
  structs = 0 & dummy = temporary(structs)
  classes = 0 & dummy = temporary(classes)

  <span class="comments">;; Simple set-up for heap data</span>
  ptr_index   = [0L]
  ptr_offsets = [0L]

  <span class="comments">;; Loop through the file reading records as we go.</span>

  while status EQ 1 do begin
      <span class="comments">;; Read the next block, or at least the first 2 kB of it</span>
      <span class="comments">;; This is OK since all scalar types will be smaller than that</span>
      point_lun, unit, pp
      cmsv_rrec, block, p1, bdata, unit=unit, next_block=pnext, /init, $
        block_type=bt, block_name=bn, status=status, errmsg=errmsg, $
        promote64=promote64, compressed=compressed
      if status EQ 0 then goto, DONE

      if bn EQ 'END_MARKER' then goto, DONE

      <span class="comments">;; After any header blocks have been read, then print info</span>
      if NOT keyword_set(quiet) AND firstvar $
        AND bn NE 'TIMESTAMP' AND bn NE 'VERSION' then begin
          print, '** '+filename(0)
          print, stamp.save_date, stamp.save_user, stamp.save_host, $
            format='("** ",A0," (",A0,"@",A0,")")'
          print, vers.release, vers.os, $
            format='("** IDL v",A0," (",A0,")")'
          firstvar = 0
      endif
      
      <span class="comments">;; We can't really decode the compressed block, but we can print</span>
      <span class="comments">;; some information about it</span>
      if compressed then goto, FAILED_BLOCK

      errmsg = ''
      <span class="comments">;; Check for each block type of interest.</span>
      case bn of 

          <span class="comments">;; Timestamp record</span>
          'TIMESTAMP': begin
              stamp = bdata
              if NOT keyword_set(all) then goto, NEXT_BLOCK
              rstamp = 1
              if NOT keyword_set(quiet) then begin
                  print, stamp.save_date, format='("    Date: ''",A0,"''")'
                  print, stamp.save_user, format='("Username: ''",A0,"''")'
                  print, stamp.save_host, format='("Hostname: ''",A0,"''")'
              endif
          end

          <span class="comments">;; Version record</span>
          'VERSION': begin
              vers = bdata
              if NOT keyword_set(all) then goto, NEXT_BLOCK

              rvers = 1
              if NOT keyword_set(quiet) then begin
                  print, vers.arch,           format='("    Arch: ''",A0,"''")'
                  print, vers.os,             format='("      OS: ''",A0,"''")'
                  print, vers.release,        format='(" Release: ''",A0,"''")'
                  print, vers.format_version, format='("File Ver: ",I0)'
              endif
          end

          'IDENTIFICATION': begin
              ident = bdata
              if NOT keyword_set(all) then goto, NEXT_BLOCK
              
              print, ident.author,        format='("  Author: ''",A0,"''")'
              print, ident.title,         format='("   Title: ''",A0,"''")'
              print, ident.idcode,        format='(" ID Code: ''",A0,"''")'
          end

          'NOTICE': begin
              notice = bdata
              if keyword_set(all) then $
                print, '   - Record type '+strtrim(bt,2)+' ('+bn+')'
              print, strlen(notice.text), $
                format='("** NOTICE record: ",I0," chars (view with /VERBOSE)")'
              if keyword_set(all) then $
                print, notice.text
          end

          <span class="comments">;; Variable record.  This is the meat of the routine.  Some</span>
          <span class="comments">;; other routines are routed here too, when they need to</span>
          <span class="comments">;; print variable information.</span>
          'VARIABLE': begin
              sysvar = 0
              DO_VARIABLE:
              tp1 = 0
              stname = 0 & dummy = temporary(stname)
              <span class="comments">;; Read name and type</span>
              cmsv_rvtype, block, p1, varname, sz1, status=st1, template=val, $
                unit=unit, system=sysvar, errmsg=errmsg, /no_create, $
                structure_name=stname, $
                named_structs=structs, named_classes=classes
              if varname EQ '' OR st1 EQ 0 then goto, FAILED_BLOCK

              <span class="comments">;; Save the name and type information</span>
              if nvar EQ 0 then vnames = [varname] $
              else vnames = [vnames, varname]
              if nvar EQ 0 then vtypes = ([sz1, lonarr(11)])(0:10) $
              else vtypes = [vtypes, ([sz1, lonarr(11)])(0:10)]
              nvar = nvar + 1

              <span class="comments">;; Read the data if needed</span>
              type1 = sz1(sz1(0)+1)
              if sz1(0) EQ 0 AND type1 NE 11 then begin
                  if n_elements(val) GT 0 then tp1 = val
                  cmsv_rdata, block, p1, sz1, val, template=tp1, status=st1, $
                    unit=unit, errmsg=errmsg
                  if st1 EQ 0 then goto, NEXT_BLOCK
              endif 

              <span class="comments">;; Print the data</span>
              hf = helpform(varname, val, size=sz1, width=78, $
                            structure_name=stname)
              if NOT keyword_set(quiet) then begin
                  print, '  '+hf, format='(A)'
              endif
          end

          <span class="comments">;; A system variable is recorded just like a variable.</span>
          'SYSTEM_VARIABLE': begin
              sysvar = 1
              goto, DO_VARIABLE
          end

          <span class="comments">;; A common variable is printed but not counted</span>
          'COMMON_BLOCK': begin
              names = bdata
              if n_elements(names) LE 1 then  goto, NEXT_BLOCK
              if NOT keyword_set(quiet) then begin
                  print, '  '+names(1:*)+' ('+names(0)+')', format='(A)'
              endif
              <span class="comments">;; nvar = nvar + n_elements(names) ; don't count common variables</span>
          end

          <span class="comments">;; A compiled routine.  Just the simple stuff is restored</span>
          <span class="comments">;; here since it seems to change a lot between versions.</span>
          'COMPILED': begin

              proname = cmsv_rraw(/string, block, p1, status=st1, unit=unit)
              if st1 then prolength = cmsv_rraw(/long, block, p1, status=st1)
              if st1 then n_vars = cmsv_rraw(/long, block, p1, status=st1)
              if st1 then n_args = cmsv_rraw(/long, block, p1, status=st1)
              if st1 then flags = cmsv_rraw(/long, block, p1, status=st1)
              if st1 EQ 0 then goto, NEXT_BLOCK
              key = '' & extra = ''
              if (flags AND '01'xb) NE 0 then begin
                  type = 'FUNCTION' 
                  if nfunc EQ 0 then funnames = proname $
                  else funnames = [funnames, proname]
                  nfunc = nfunc + 1
              endif else begin
                  type = 'PRO'
                  if npro EQ 0 then pronames = proname $
                  else pronames = [pronames, proname]
                  npro = npro + 1
              endelse
              if (flags AND '02'xb) NE 0 then key  = ', KEYWORDS'
              if (flags AND '08'xb) NE 0 then extra = ', _EXTRA'
              if NOT keyword_set(quiet) then begin
                  print, type, proname, n_args, key, extra, $
                    format='("  ",A0," ",A0,", ",I0," args",A0,A0)'
              endif
          end

          <span class="comments">;; A heap header is really an index to following heap</span>
          <span class="comments">;; variables, so that at a later time they can be restored.</span>
          'HEAP_INDEX': begin
              if keyword_set(all) then $
                print, '   - Record type '+strtrim(bt,2)+' ('+bn+')'
              ii = bdata
              ptr_index   = [ptr_index, ii]
              ptr_offsets = [ptr_offsets, ii*0L]
          end

          <span class="comments">;; The heap data is stored here, unnamed.</span>
          'HEAP_DATA': begin
              if keyword_set(all) then $
                print, '   - Record type '+strtrim(bt,2)+' ('+bn+')'
              p2 = p1
              cmsv_rvtype, block, p1, vindex, /heap, /no_create, unit=unit, $
                status=st1, errmsg=errmsg, $
                structure_name=stname, $
                named_structs=structs, named_classes=classes
              if st1 EQ 0 then goto, NEXT_BLOCK

              <span class="comments">;; VINDEX will be the heap variable number.  Once we</span>
              <span class="comments">;; know this we can put the file offset into</span>
              vindex = floor(vindex(0))
              wh = where(ptr_index EQ vindex, ct)
              if ct EQ 0 then goto, NEXT_BLOCK
              nheap = nheap + 1
              ptr_offsets(wh(0)) = pp + p2
          end

          <span class="comments">;; What to do in the generic case</span>
          else: begin
              FAILED_BLOCK:
              if compressed then compstr = '  (compressed)' else compstr = ''
              if keyword_set(all) OR bn EQ 'UNKNOWN' then $
                print, '   - Record type '+strtrim(bt,2)+' ('+bn+')'+compstr
              if keyword_set(all) AND bn EQ 'UNKNOWN' then print_raw = 1
          end
      endcase

      NEXT_BLOCK:
      <span class="comments">;; Some final extremely verbose output for every block, if</span>
      <span class="comments">;; requested.</span>
      if print_raw then begin
          point_lun, unit, pp
          cmsv_rrec, block, p1, unit=unit, /init, /full, $
            status=status, errmsg=errmsg, offset=pp, $
            promote64=opromote64, compressed=compressed
          if status EQ 1 then begin
              print, '     (binary data)'
              binaryform_long, block
          endif
      endif

      if NOT keyword_set(raw) then print_raw = 0
      if errmsg NE '' then message, errmsg, /info

      <span class="comments">;; Now advance to the next record.</span>
      if pnext EQ 0 then begin
          message, 'WARNING: premature termination of '+filename(0), /info
          goto, DONE
      endif
      if pp NE pnext then begin
          pp = pnext 
      endif else begin
          status = 0
          errmsg = 'ERROR: internal inconsistency'
      endelse

      opromote64 = promote64
  endwhile
  DONE:
  if status EQ 0 then message, errmsg, /info 

  <span class="comments">;; Final statistics</span>
  if nvar GT 0 then vtypes = reform(vtypes, 11, nvar, /overwrite)

  if NOT keyword_set(quiet) then $
    print, nvar, nheap, npro+nfunc, filesize, $
    format=('("** ",I0," variable(s), ",I0," heap value(s) and ",' + $
            'I0," procedure(s) in ",I0," bytes")')

  free_lun, unit
  return
end
</code>
    </div>
  </body>
</html>