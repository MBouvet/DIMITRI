<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:32 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmrestore.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmrestore.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMRESTORE</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Restore variables from an IDL SAVE file.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE: (various)</span>
<span class="comments">;   CMRESTORE, filename                           (implicit)</span>
<span class="comments">;   CMRESTORE, filename, var1, var2, ..., [, NAMES=names]</span>
<span class="comments">;   CMRESTORE, filename, DATA=pointers, NAMES=names, PASS_METHOD='POINTER'</span>
<span class="comments">;   CMRESTORE, filename, DATA=handles,  NAMES=names, PASS_METHOD='HANDLE'</span>
<span class="comments">;   CMRESTORE, filename, DATA=structure,             PASS_METHOD='STRUCT'</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE is a replacement for the built-in IDL procedure RESTORE.</span>
<span class="comments">;   It restores variables and data from an existing IDL SAVE file,</span>
<span class="comments">;   written either by SAVE or CMSAVE.  The CMSV utility library must</span>
<span class="comments">;   be installed in your IDL path to use CMSAVE and CMRESTORE.</span>
<span class="comments">;</span>
<span class="comments">;   The primary advantage to CMRESTORE is the ability to selectively</span>
<span class="comments">;   restore only certain variables from the input file (based on</span>
<span class="comments">;   name).  CMRESTORE provides a number of ways to pass the data</span>
<span class="comments">;   between routines, typically using a pointer or structure, which</span>
<span class="comments">;   avoids the unsafe practice of restoring variables in the caller's</span>
<span class="comments">;   namespace.  However, CMRESTORE can restore variables into the</span>
<span class="comments">;   caller's namespace, but users should be aware that this capacity</span>
<span class="comments">;   is somewhat limited in IDL versions 5.2 and below.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; COMPATIBILITY:</span>
<span class="comments">;</span>
<span class="comments">;   -- File Format --</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE should be able to read files written by SAVE and CMSAVE</span>
<span class="comments">;   from IDL version 4 to version 5.4.</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE cannot restore objects, pointers, compressed files, or</span>
<span class="comments">;   data sets larger than 2 gigabytes.</span>
<span class="comments">;   </span>
<span class="comments">;   Data types available in newer versions of IDL, such as pointers</span>
<span class="comments">;   and long integers, will not be readable in older versions of IDL</span>
<span class="comments">;   which do not have those data types.</span>
<span class="comments">;</span>
<span class="comments">;   -- Calling Interface --</span>
<span class="comments">;</span>
<span class="comments">;   For the most part, all capabilities of CMRESTORE are available to</span>
<span class="comments">;   the user.  However, it should be noted that passing variables by</span>
<span class="comments">;   positional parameter is not available under IDL 4, unless NAMES is</span>
<span class="comments">;   used to name the variables explicitly.  Also, under IDL versions</span>
<span class="comments">;   5.2 and previous, it is not possible for CMRESTORE to restore</span>
<span class="comments">;   variables into the caller's name space if they are not yet</span>
<span class="comments">;   defined.</span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   FILENAME - the name of the SAVE file.</span>
<span class="comments">;              Default: none, this parameter must be specified.</span>
<span class="comments">;</span>
<span class="comments">;   VAR{i} - The values to be restored.  By default the save name is</span>
<span class="comments">;            taken from the named variables that are passed.  These</span>
<span class="comments">;            default names can be overridden by using the NAMES</span>
<span class="comments">;            keyword.</span>
<span class="comments">;</span>
<span class="comments">;            If no variables are passed as positional parameters, they</span>
<span class="comments">;            can still be saved using the DATA keyword.  By invoking</span>
<span class="comments">;            CMRESTORE without positional parameters or DATA,</span>
<span class="comments">;            CMRESTORE automatically will attempt to restore the</span>
<span class="comments">;            variables to the calling routine's name space (the</span>
<span class="comments">;            "implicit" technique).</span>
<span class="comments">;</span>
<span class="comments">;               NOTE: in IDL 5.2 and below, user routines are not</span>
<span class="comments">;               allowed to *CREATE* new variables in the caller's name</span>
<span class="comments">;               space.  CMRESTORE may fail if the variable in</span>
<span class="comments">;               undefined in the caller.  Therefore you must define it</span>
<span class="comments">;               before calling CMRESTORE.  The safer practice is to</span>
<span class="comments">;               use the VAR{i} positional parameters, or the DATA</span>
<span class="comments">;               keyword.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   FILENAME - the name of the SAVE file.  The positional FILENAME</span>
<span class="comments">;              parameter takes precedence over the keyword FILENAME</span>
<span class="comments">;              parameter.</span>
<span class="comments">;</span>
<span class="comments">;              NOTE that if you pass variables as positional</span>
<span class="comments">;              parameters, then the first parameter *must* be the file</span>
<span class="comments">;              name, and the FILENAME *keyword* will be ignored.</span>
<span class="comments">;</span>
<span class="comments">;   PASS_METHOD - a scalar string, describing the method of passing</span>
<span class="comments">;                 data between the caller and CMRESTORE.  The keyword</span>
<span class="comments">;                 can take the value 'ARGUMENT', 'POINTER', 'HANDLE'</span>
<span class="comments">;                 or 'STRUCT'.  A value of 'ARGUMENT' indicates that</span>
<span class="comments">;                 data values will be passed by command line argument,</span>
<span class="comments">;                 and is the default.  Other values are described</span>
<span class="comments">;                 below.</span>
<span class="comments">;</span>
<span class="comments">;   DATA - A list of data elements to be restored from the output</span>
<span class="comments">;          file.  The data elements can be one of the following,</span>
<span class="comments">;          depending on the value of PASS_METHOD.  The means of</span>
<span class="comments">;          extracting the data, and the method of naming each</span>
<span class="comments">;          variable, are also indicated.</span>
<span class="comments">;</span>
<span class="comments">;            * PASS_METHOD='POINTER': An array of pointers to the variables</span>
<span class="comments">;                    Data: pointed-to value     Name: from NAMES keyword</span>
<span class="comments">;            * PASS_METHOD='HANDLE':  An array of handles to the variables</span>
<span class="comments">;                    Data: pointed-to value     Name: from NAMES keyword</span>
<span class="comments">;            * PASS_METHOD='STRUCT':  A structure containing data to be saved</span>
<span class="comments">;                    Data: tag value            Name: tag name</span>
<span class="comments">;</span>
<span class="comments">;          Data values are restored one by one, using the appropriate</span>
<span class="comments">;          name.  Note that any variables passed as positional</span>
<span class="comments">;          parameters will cause the DATA keyword to be ignored.</span>
<span class="comments">;</span>
<span class="comments">;          CMRESTORE will allocate any pointer or handle resources.</span>
<span class="comments">;          The calling routine is responsible for deallocating any</span>
<span class="comments">;          pointer or handle resources.</span>
<span class="comments">;</span>
<span class="comments">;   NAMES - a string array, giving the names for each variable.  </span>
<span class="comments">;</span>
<span class="comments">;           If the data are passed by positional parameters, the names</span>
<span class="comments">;           are assigned according to the position of the parameter in</span>
<span class="comments">;           the procedure call.  </span>
<span class="comments">;</span>
<span class="comments">;           If the data are passed by an array of pointers or handles,</span>
<span class="comments">;           then the names are assigned according to the position of</span>
<span class="comments">;           the data in the array.  In this case there is no other way</span>
<span class="comments">;           to supply the variable name.  NAMES is required.</span>
<span class="comments">;</span>
<span class="comments">;           If the data are passed in a structure, then the names are</span>
<span class="comments">;           assigned according to the position of the data in the</span>
<span class="comments">;           structure.  The values specified in the names keyword</span>
<span class="comments">;           override the tag names.</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, an integer indicating the status of the</span>
<span class="comments">;            operation.  A value of 1 indicates success, while 0</span>
<span class="comments">;            indicates failure.  A failure condition does not</span>
<span class="comments">;            necessarily indicate that an individual variable could</span>
<span class="comments">;            not be restored; use the VARSTATUS keyword to detect such</span>
<span class="comments">;            situations.</span>
<span class="comments">;</span>
<span class="comments">;   VARSTATUS - upon return, an integer array indicating the status of</span>
<span class="comments">;               the restore operation for each variable.  A value of 1</span>
<span class="comments">;               at position i in the array indicates success for the</span>
<span class="comments">;               ith variable, while a value of 0 indicates failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return, a string indicating the status of the</span>
<span class="comments">;            operation.  The empty string indicates success, while a</span>
<span class="comments">;            non-empty string indicates failure and describes the</span>
<span class="comments">;            error condition.</span>
<span class="comments">;</span>
<span class="comments">;   QUIET - if set, then the error message is returned to the calling</span>
<span class="comments">;           routine.  By default an error condition causes execution</span>
<span class="comments">;           to stop and the message to be printed on the console.</span>
<span class="comments">;</span>
<span class="comments">;   VERBOSE - if set, then a short message is printed for each</span>
<span class="comments">;             variable.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   CMSAVE, VAR1, VAR2, FILENAME='test.sav'</span>
<span class="comments">;   CMSAVE, VAR1, VAR2, FILENAME='test.sav', NAMES=['A','B']</span>
<span class="comments">;</span>
<span class="comments">;     Save the data in VAR1 and VAR2 to the file test.sav.  In the</span>
<span class="comments">;     first case the saved variable names will be VAR1 and VAR2.  In</span>
<span class="comments">;     the second case the saved variable names will be A and B.</span>
<span class="comments">;</span>
<span class="comments">;   POINTERS = [ptr_new(VAR1), ptr_new(VAR2)]</span>
<span class="comments">;   CMSAVE, DATA=POINTERS, NAMES=['A','B'], FILENAME='test.sav'</span>
<span class="comments">;</span>
<span class="comments">;     Save the data in VAR1 and VAR2 to the file test.sav.  The saved</span>
<span class="comments">;     variable names will be A and B.</span>
<span class="comments">;</span>
<span class="comments">;   STRUCTURE = {A: VAR1, B: VAR2}</span>
<span class="comments">;   CMSAVE, DATA=STRUCTURE, FILENAME='test.sav'</span>
<span class="comments">;</span>
<span class="comments">;     Save the data in VAR1 and VAR2 to the file test.sav.  The saved</span>
<span class="comments">;     variable names will be A and B.</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMSAVE, SAVE, RESTORE</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 14 May 2000</span>
<span class="comments">;   Documented, 22 Sep 2000</span>
<span class="comments">;   Restore into caller's name space now permitted, 11 Jan 2001</span>
<span class="comments">;   Documented "implicit" restore a little better, w/ errors, 01 Mar 2001</span>
<span class="comments">;   Make version checks with correct precision, 19 Jul 2001, CM</span>
<span class="comments">;   Restore with no args automatically does ALL, is this right?,</span>
<span class="comments">;     CM, 20 Aug 2001</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   Handle the case of CMRESTORE, FILENAME, X properly, 03 Sep 2008, CM</span>
<span class="comments">;     (thanks to Sergey Koposov for reporting)</span>
<span class="comments">;   Report CMSVLIB version number when /VERBOSE is set, 22 Nov 2009,</span>
<span class="comments">;      CM</span>
<span class="comments">;   Change to accomodate lack of GDL functionality when restoring</span>
<span class="comments">;      all variables, 22 Nov 2009, CM</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmrestore.pro,v 1.22 2009/11/22 23:31:00 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, 2008, 2009, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

<span class="comments">;; This utility function is only called under IDL 4</span>
<a id="arg_present:source"></a>function arg_present, x
  return, 0
end

<a id="cmrestore:source"></a>pro cmrestore,   filename0, filename=filename1, $
                  p0,  p1,  p2,  p3,  p4,  p5,  p6,  p7,  p8,  p9, $
                 p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, $
                 p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, $
                 verbose=verbose, all=all, restored_objects=restobj, $
                 status=status, varstatus=colstatus, mtimes=mtimes, $
                 names=names, data=data, pass_method=method, $
                 errmsg=errmsg, quiet=quiet, nocatch=nocatch, $
                 relaxed_structure_assignment=relax, version=revision
                  
  forward_function routine_names, ptrarr, ptr_new, handle_create, arg_present

  status = 0
  errmsg = ''
  colstatus = 0 & dummy = temporary(colstatus)  <span class="comments">;; Void out the status</span>

  cmsvlib_version = '&lt;unknown>'
  catch, catcherr
  if catcherr EQ 0 then lib = cmsvlib(/query, version=cmsvlib_version) else lib = 0
  catch, /cancel
  if lib EQ 0 then $
    message, 'ERROR: The CMSVLIB library must be in your IDL path.'

  revision = '$Revision: 1.22 $'
  <span class="comments">;; Extract the version number</span>
  revision = stregex(revision,'\$'+'Revision: *([0-9.]+) *'+'\$',/extract,/sub)
  revision = revision(1)

  if keyword_set(verbose) then begin
     message, /info, 'CMRESTORE version '+revision, traceback=0
     message, /info, 'CMSV Library version '+cmsvlib_version(0), traceback=0
  endif

  if NOT keyword_set(nocatch) then on_error, 2
  kall = 0                      <span class="comments">;; NOTE: Ignoring ALL keyword!!</span>

  n_par = n_params()
  nnames = n_elements(names)
  ver = double(!version.release)
  if n_elements(filename0) EQ 0 AND n_elements(filename1) EQ 0 then begin
      message, 'USAGE: CMRESTORE, filename, VAR1, VAR2, ...', /info
      return
  end
  <span class="comments">;; Now n_par refers to the number of positional variables (ie,</span>
  <span class="comments">;; filename excluded)</span>
  n_par = n_par - 1

  <span class="comments">;; Default processing</span>
  if n_elements(filename0) GT 0 then filename = strtrim(filename0(0),2) $
  else                               filename = strtrim(filename1(0),2)

  <span class="comments">;; Input method</span>
  if n_elements(method) EQ 0 then begin
      if n_par GT 0 then meth = 'ARGUMENT' $
      else               meth = 'STORE'
  endif else begin
      meth = strupcase(strtrim(method(0),2))
  endelse
  <span class="comments">;; Trim it down so that people don't have to type too many characters</span>
  meth = strmid(meth, 0, 3)

  <span class="comments">;; Error checking on input method, depending on IDL version</span>
  if meth EQ 'ARG' AND ver LT 5D AND nnames EQ 0 then begin
      errmsg = ('ERROR: in IDL 4 you cannot pass variables by argument '+ $
                'to CMRESTORE.')
      goto, PRE_CLEANUP
  endif
  <span class="comments">;; Implicit restore of ALL, if no names are provided</span>
  if nnames EQ 0 AND n_par EQ 0 then kall = 1
  <span class="comments">;; GDL is incapable of restoring all variables without them being named.</span>
  DEFSYSV, '!gdl', exists=is_it_gdl
  if is_it_gdl then begin
      if nnames EQ 0 then kall = 1
  endif

  <span class="comments">;; Extract some information about the calling routine</span>
  lev = routine_names(/level)
  vlev = lev - 1

  <span class="comments">;; Note: if the user specified "ALL" then we set NNAMES to zero,</span>
  <span class="comments">;; indicating that the number of variables to be returned is unknown</span>
  <span class="comments">;; at present.</span>
  if kall then nnames = 0L

  if n_par LT 1 AND meth NE 'STO' AND arg_present(data) EQ 0 then begin
      if ver GE 5D OR meth EQ 'ARG' then begin
          errmsg = ('ERROR: A way to return data must be specified.  Pass by'+$
                    ' argument (IDL >= 5), or using the NAMES/DATA keywords.')
          goto, PRE_CLEANUP
      endif
  endif

  <span class="comments">;; ---------------- Establish I/O parameters -------------------</span>
  <span class="comments">;; Upon exit from this block, at least the following variables must</span>
  <span class="comments">;; be set: (a) nvar = number of named variables, (b) vnames = names</span>
  <span class="comments">;; of variables in SAVE file to be restored.</span>
  
  <span class="comments">;; Special case: if keyword ALL is set, then nvar EQ 0, and vnames</span>
  <span class="comments">;; is undefined.  It will be filled in later then.</span>
  if meth EQ 'ARG' then begin
      <span class="comments">;; Now processing that depends on the data passing method.  The</span>
      <span class="comments">;; "argument" method is via positional arguments.</span>

      <span class="comments">;; Extract variables from positional parameters</span>
      if kall EQ 0 then nnames = n_par
      if (kall EQ 0 AND nnames EQ 0) $
        OR (kall AND n_par LE 0) then begin
          errmsg = 'ERROR: Returnable variables must be specified.'
          goto, PRE_CLEANUP
      endif
      lev1 = strtrim(lev-1,2)
      nvar = nnames
      if nvar GT 0 then vnames = strarr(nvar)
      if NOT kall AND ver GE 5D then begin
          for i = 0L, nvar-1 do $
            dummy = execute('vnames(i) = (routine_names(p'+strtrim(i,2)+ $
                            ',arg_name='+lev1+'))(0)')
      endif
  endif else if meth EQ 'STO' then begin
      <span class="comments">;; This information is used to determine whether the variable</span>
      <span class="comments">;; already exists in the caller.  If it doesn't, and we are in</span>
      <span class="comments">;; IDL 5.2 or earlier, then we can't save it.</span>
      cnames = strupcase(strtrim(routine_names(variables=vlev),2))

      nvar = nnames
      if nvar GT 0 then vnames = strarr(nvar)
      
  endif else begin

      <span class="comments">;; Instead of passing the data via positional parameters, they</span>
      <span class="comments">;; can be set through the DATA keyword, but even there this can</span>
      <span class="comments">;; be accomplished with several means: via pointers, via</span>
      <span class="comments">;; handles, or using a structure.</span>
      
      <span class="comments">;; Clear DATA in preparation for restore operation</span>
      data = 0 & dummy = temporary(data)
      nvar = nnames
      if nvar GT 0 then vnames = strarr(nvar)

      if meth EQ 'POI' then begin               <span class="comments">;; POINTER TYPE</span>
          <span class="comments">;; Construct an array of null pointers to start with</span>
          if nvar GT 0 then data = ptrarr(nvar)
      endif else if meth EQ 'HAN' then begin     <span class="comments">;; HANDLE TYPE</span>
          <span class="comments">;; Construct an array of invalid handles to start with</span>
          if nvar GT 0 then data = lonarr(nvar)-1L
      endif else if meth EQ 'STR' then begin
          <span class="comments">;; Do nothing</span>
      endif else begin
          errmsg = 'ERROR: PASS_METHOD must be one of ARGUMENT, POINTER, '+$
            'HANDLE or STRUCT'
          PRE_CLEANUP:
          status = 0
          if NOT keyword_set(quiet) then message, errmsg, /info
          return
      endelse
  endelse

  if kall EQ 0 then begin
      if nvar LE 0 then begin
          errmsg = 'ERROR: no variable names were specified'
          goto, PRE_CLEANUP
      endif else begin
          colstatus = lonarr(nvar)
      endelse
  endif

  <span class="comments">;; User-renamed variables.  These names will override any names</span>
  <span class="comments">;; specified in positional parameters.</span>
  if n_elements(names) GT 0 AND NOT kall then begin
      sz = size(names)
      if sz(sz(0)+1) NE 7 then begin
          errmsg = 'ERROR: NAMES must be a string array'
          goto, PRE_CLEANUP
      endif
      vnames(0) = strtrim(strupcase(names(*)),2)
  endif

  <span class="comments">;; Open the save file</span>
  get_lun, unit
  cmsv_open, unit, filename, pp, access='R', status=status, errmsg=errmsg
  if status EQ 0 then goto, CLEANUP
  if keyword_set(verbose) then $
    message, 'Portable (XDR) SAVE/RESTORE file.', /info, traceback=0

  pp0 = pp  <span class="comments">;; Block pointer</span>
  ivar = 0L <span class="comments">;; Number of variables that have been read successfully</span>
  if n_elements(vnames) GT 0 then $
    found = lonarr(n_elements(vnames))

  ptr_index   = [0L]
  ptr_offsets = [0L]
  if ver GE 5D then ptr_data = [ptr_new()] $
  else              ptr_data = [0L]

  <span class="comments">;; Now begin the processing</span>
  repeat begin
      <span class="comments">;; Read block from SAVE file</span>
      bn = ''
      point_lun, unit, pp
      block = 0 & dummy = temporary(block)
      cmsv_rrec, block, pp1, bdata, unit=unit, next_block=pnext, /init, $
        block_type=bt, block_name=bn, status=status, errmsg=errmsg, offset=pp,$
        promote64=promote64
      if status EQ 0 then goto, CLEANUP
      eb = (bn EQ 'END_MARKER')

      <span class="comments">;; Examine each block type  -----</span>

      errmsg = ''
      jfind = -1L
      case bn of 

          <span class="comments">;; Promote record header to 64-bits (compatibility)</span>
          'PROMOTE64': if keyword_set(verbose) then begin
              message, 'File contains 64-bit offsets.', /info, traceback=0
          endif

          <span class="comments">;; Read time stamp record</span>
          'TIMESTAMP': if keyword_set(verbose) then begin
              stamp = bdata
              message, 'Save file written by '+stamp.save_user+'@'+ $
                stamp.save_host+', '+stamp.save_date, /info, traceback=0
          endif
          
          <span class="comments">;; Read version record</span>
          'VERSION': if keyword_set(verbose) then begin
              vers = bdata
              message, ('IDL version '+vers.release+' ('+vers.os+ $
                        ', '+vers.arch+')'), /info, traceback=0
              message, 'File format revision: '+ $
                strtrim(vers.format_version,2), /info, traceback=0
          endif

          <span class="comments">;; Read heap index record</span>
          'HEAP_INDEX': begin
              ii = bdata
              ptr_index   = [ptr_index, ii]
              ptr_offsets = [ptr_offsets, ii*0L]
              if ver GE 5D then $
                ptr_data    = [ptr_data, ptrarr(n_elements(ii))]
          end

          <span class="comments">;; Read heap data - just store a file pointer for later</span>
          <span class="comments">;;                  referral</span>
          'HEAP_DATA': begin
              p2 = pp1
              cmsv_rvtype, block, pp1, vindex, /heap, unit=unit, $
                status=st1, errmsg=errmsg
              if st1 EQ 0 then goto, NEXT_BLOCK

              <span class="comments">;; VINDEX will be the heap variable number.  Once we</span>
              <span class="comments">;; know this we can put the file offset into</span>
              vindex = floor(vindex(0))
              wh = where(ptr_index EQ vindex, ct)
              if ct EQ 0 then goto, NEXT_BLOCK
              ptr_offsets(wh(0)) = pp + p2  <span class="comments">;; block address + offset</span>
          end              

          <span class="comments">;; Read variable data, and store for return to caller</span>
          'VARIABLE': begin
              <span class="comments">;; Read variable type</span>
              cmsv_rvtype, block, pp1, vn, sz1, unit=unit, status=st1, $
                template=tpp1, errmsg=err1
              if vn EQ '' OR st1 EQ 0 then goto, NEXT_BLOCK
              if kall EQ 0 then begin
                  jfind = (where(vn EQ vnames, ct))(0)
                  if ct EQ 0 then goto, NEXT_BLOCK
                  found(jfind) = 1
              endif
              
              <span class="comments">;; Read variable data</span>
              cmsv_rdata, block, pp1, sz1, val, template=tpp1, status=st1, $
                unit=unit, errmsg=errmsg, ptr_offsets=ptr_offsets, $
                ptr_index=ptr_index, ptr_data=ptr_data
              if st1 EQ 0 then goto, NEXT_BLOCK
              if sz1(0) GT 0 then arr = 1 else arr = 0
              if arr then begin
                  <span class="comments">;; If an array then reform to be sure dimensions are right</span>
                  dims = sz1(1:sz1(0))
                  val = reform(val, dims, /overwrite)
              endif
              
              if kall then begin
                  <span class="comments">;; With ALL, we extend the vector at each variable</span>
                  jfind = ivar & ii = strtrim(jfind,2)
                  if ivar EQ 0 then begin
                      anames = [vn]
                      colstatus = [0L]
                  endif else begin
                      anames = [anames, vn]
                      colstatus = [colstatus, 0L]
                  endelse
              endif
              
              <span class="comments">;; Now send the data to output, depending on the method</span>
              case meth of 
                  'ARG': begin
                      <span class="comments">;; Position dependent parameter</span>
                      if jfind GE n_par then goto, NEXT_BLOCK
                      ii = strtrim(jfind,2)
                      if arr EQ 0 then begin
                          dummy = execute('p'+ii+' = temporary(val)') 
                      endif else begin
                          dummy = execute('p'+ii+' = reform(val, dims, '+ $
                                          '/overwrite)')
                      endelse
                      if dummy EQ 0 then goto, NEXT_BLOCK
                  end
                  'STO': begin
                      <span class="comments">;; Store the data in caller.  Check for IDL 5.3</span>
                      <span class="comments">;; compatibility.</span>
                      jfind1 = where(vn EQ cnames, ct1)
                      if ver LT 5.3D AND jfind1(0) EQ -1 then begin
                          if keyword_set(quiet) EQ 0 then begin
                              message, 'WARNING: could not create variable '+$
                                vn+' in calling routine.', /info, traceback=0
                          endif
                          goto, NEXT_BLOCK
                      endif
                      dummy = routine_names(vn, val, store=vlev)
                  end
                  'POI': begin
                      <span class="comments">;; Pointer to data</span>
                      if kall then begin
                          if ivar EQ 0 then data = ptrarr(1) $
                          else data = [data, ptr_new()]
                      endif
                      data(jfind) = ptr_new(val)
                  end
                  'HAN': begin
                      <span class="comments">;; Handle to data</span>
                      if kall then begin
                          if ivar EQ 0 then data = [-1L] $
                          else data = [data, -1L]
                      endif
                      data(jfind) = handle_create(value=val, /no_copy)
                  end
                  'STR': begin
                      <span class="comments">;; Add data to structure</span>
                      if n_elements(sdata) EQ 0 then $
                        sdata = create_struct(vn, val) $
                      else $
                        sdata = create_struct(sdata, vn, val)
                  end
              endcase
              
              colstatus(jfind) = 1
              if kall then ivar = ivar + 1
          end


          ELSE: dummy = 1
      endcase

      NEXT_BLOCK:
      if NOT keyword_set(quiet) then begin
          if errmsg NE '' then $
            message, errmsg, /info
          if keyword_set(verbose) AND jfind GE 0 then begin
              if colstatus(jfind) EQ 1 then $
                message, 'Restored variable: '+vn+'.', /info, traceback=0 $
              else $
                message, 'Unable to restore variable: '+vn+'.', /info, $
                traceback=0
          endif
      endif
      <span class="comments">;; Advance to next block</span>
      if pp NE pnext then begin
          pp = pnext 
      endif else begin
          status = 0
          errmsg = 'ERROR: internal inconsistency'
      endelse
  endrep until bn EQ 'END_MARKER' OR status EQ 0

  <span class="comments">;; Clean up</span>
  free_lun, unit

  DONE_RESTORE:
  if meth EQ 'STR' then begin
      <span class="comments">;; Put new struct data on output</span>
      data = 0 & dummy = temporary(data)
      if n_elements(sdata) GT 0 then data = temporary(sdata)
  endif
  if kall then begin
      names = 0 & dummy = temporary(names)
      if n_elements(anames) GT 0 then names = anames
  endif

  if n_elements(found) GT 0 then begin
      wh = where(found EQ 0, ct)
      fmt = '(A,'+strtrim(ct,2)+'(A,:," "),".")'
      if ct GT 0 then begin
          errmsg = string("WARNING: the following variables were not found: ",$
                          vnames(wh), format=fmt)+'.'
          if NOT keyword_set(quiet) OR keyword_set(verbose) then $
            message, errmsg, /info, traceback=0
      endif
  endif

  if total(colstatus) GT 0 then begin
      status = 1
  endif else begin
      status = 0
      errmsg = 'ERROR: No variables were restored.'
      if meth EQ 'STO' AND ver LT 5.3D then begin
          errmsg = errmsg + '  NOTE: In IDL 5.2 and earlier the variable '+$
            'must first be defined by the caller in order to use the '+$
            '"implicit" restore technique.'
          message, errmsg, /info, traceback=0
      endif
  endelse

  return

  <span class="comments">;; </span>
  <span class="comments">;; Error handling routine, outside the normal call flow</span>
  CLEANUP:
  catch, /cancel
  if n_elements(unit) GT 0 then free_lun, unit
  status = 0
  if errmsg NE '' AND NOT keyword_set(quiet) then message, errmsg, /info

  return
end

</code>
    </div>
  </body>
</html>