<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:35 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>inputform.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="inputform.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   INPUTFORM</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Generates expression string from an IDL value</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   STRING = INPUTFORM(VALUE, ERRMSG=ERRMSG, STATUS=STATUS, ...)</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   The INPUTFORM function converts an IDL data value into its string</span>
<span class="comments">;   representation, suitable for execution at the IDL command line or</span>
<span class="comments">;   with EXECUTE().  This is similar to the "InForm" output</span>
<span class="comments">;   representation of Mathematica, which formats output so that it can</span>
<span class="comments">;   be entered again on the command line.  INPUTFORM() is a</span>
<span class="comments">;   specialized form of STRING().</span>
<span class="comments">;</span>
<span class="comments">;   For example, the value DBLARR(2,2) has the default representation</span>
<span class="comments">;</span>
<span class="comments">;      '[[0D,0],[0D,0]]'</span>
<span class="comments">;</span>
<span class="comments">;   The formal goal of INPUTFORM is for the resulting textual</span>
<span class="comments">;   expression to be an exact representation of the original data.</span>
<span class="comments">;   Several other output options can be selected by using the /ZERO or</span>
<span class="comments">;   /ARRAY_NOTATION keywords.</span>
<span class="comments">;</span>
<span class="comments">;   Therefore, given the original value VARIABLE, then after executing</span>
<span class="comments">;</span>
<span class="comments">;      R = EXECUTE( 'variable1 = '+INPUTFORM(variable) )</span>
<span class="comments">;</span>
<span class="comments">;   The value, type, and dimension of VARIABLE1 and VARIABLE will be</span>
<span class="comments">;   the same.  </span>
<span class="comments">;</span>
<span class="comments">;   Such behavior might useful in several circumstances:</span>
<span class="comments">;</span>
<span class="comments">;      * for printing values meant to be "pasted" back into the</span>
<span class="comments">;        command line by the user;</span>
<span class="comments">;      * for constructing command arguments to be EXECUTE()'d;</span>
<span class="comments">;      * for saving values in ASCII format for later execution.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUT OPTIONS:</span>
<span class="comments">;</span>
<span class="comments">;   The output of INPUTFORM can be controlled in the following ways.</span>
<span class="comments">;   See the EXAMPLES section for examples of each kind of behavior.</span>
<span class="comments">;</span>
<span class="comments">;      * By default, the output will replicate the exact values of the</span>
<span class="comments">;        input;</span>
<span class="comments">;      * If the /ZERO keyword parameter is set, then the output will</span>
<span class="comments">;        match the type and structure of the input, but all values</span>
<span class="comments">;        will be zero or blank, including IDL strings and structures.</span>
<span class="comments">;        This is useful if one wants to make a "blank template" from</span>
<span class="comments">;        an existing IDL data structure.</span>
<span class="comments">;      * If the /ARRAY_NOTATION keyword parameter is set, then any</span>
<span class="comments">;        input arrays are converted to INTARR(), DBLARR(), STRARR().</span>
<span class="comments">;        Scalars appear as in the input.  Obviously the contents of</span>
<span class="comments">;        arrays will be zero/blank in this case.  The combination of</span>
<span class="comments">;        /ZERO and /ARRAY_NOTATION produces a nice short-hand</span>
<span class="comments">;        blank template.</span>
<span class="comments">;</span>
<span class="comments">; LIMITATIONS:</span>
<span class="comments">;   </span>
<span class="comments">;   It should be noted that the IDL parser is not perfect.</span>
<span class="comments">;   While IDL has many data types, not all expressions are</span>
<span class="comments">;   representable as a textual string.  Pointers and objects can be</span>
<span class="comments">;   represented.  Examples of the parser limitation include,</span>
<span class="comments">;</span>
<span class="comments">;      * array expressions can have no more than 90 elements;</span>
<span class="comments">;      * bracketed array notation cannot be nested too deeply;</span>
<span class="comments">;      * anonymous structure arrays have no textual representation;</span>
<span class="comments">;</span>
<span class="comments">;   Given these limitations, the user of this routine must be prepared</span>
<span class="comments">;   for failure and have contingency plans.  Error messages and status</span>
<span class="comments">;   indicators are provided to facilitate this.  INPUTFORM() does not</span>
<span class="comments">;   call MESSAGE, so it should never intentionally crash.</span>
<span class="comments">;</span>
<span class="comments">;   Also, consider that the textual representation can never really be</span>
<span class="comments">;   suitable for very large arrays.  The internal algorithm is thus</span>
<span class="comments">;   not optimized for speed as heavily numeric routines might be, and</span>
<span class="comments">;   instead tries to make the output slightly more readable.</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   VALUE - the IDL value to be converted.  Any value which has a</span>
<span class="comments">;           legal textual representation is permitted.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   ARRAY_NOTATION - if set, then any arrays in the input will be</span>
<span class="comments">;            replaced by their xxxARR() equivalent.</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, a status indicator.  A value of zero</span>
<span class="comments">;            indicates failure; one indicates success.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return, a string message indicating the reason for a</span>
<span class="comments">;            failure, if any.  The empty string ('') indicates</span>
<span class="comments">;            success.</span>
<span class="comments">;</span>
<span class="comments">;   MAX_DIMENSIONS - maximum number of array dimensions permitted in</span>
<span class="comments">;                    VALUE.  The conversion fails if the maximum is</span>
<span class="comments">;                    exceeded.</span>
<span class="comments">;                    Default: any number of dimensions is permitted.</span>
<span class="comments">;</span>
<span class="comments">;                    NOTE: IDL does not permit deep nesting, for</span>
<span class="comments">;                    dimensions greater than three.</span>
<span class="comments">;</span>
<span class="comments">;   MAX_ELEMENTS - maximum number of elements permitted in VALUE.  The</span>
<span class="comments">;                  conversion fails if the maximum is exceeded.</span>
<span class="comments">;                  Default: any number of elements is permitted.</span>
<span class="comments">;</span>
<span class="comments">;                  NOTE: the conversion may still fail if any array</span>
<span class="comments">;                  dimension exceeds 90.</span>
<span class="comments">;</span>
<span class="comments">;   MAX_LEN - approximate maximum length of returned string.  If large</span>
<span class="comments">;             string expressions exceed this size as they are being</span>
<span class="comments">;             composed internally, they will be terminated by a '...'</span>
<span class="comments">;             ellipsis and returned.  This value is to be used as a</span>
<span class="comments">;             guideline by INPUTFORM(); the precise limit may not be</span>
<span class="comments">;             adhered to.</span>
<span class="comments">;             Default: 16384L</span>
<span class="comments">;</span>
<span class="comments">;   MAX_TAGS - maximum number of structure tags permitted in VALUE.</span>
<span class="comments">;              The conversion fails if the maximum is exceeded.</span>
<span class="comments">;              Default: any number of tags is permitted.</span>
<span class="comments">;</span>
<span class="comments">;   N_FLOAT - for floating point numerical values, N_FLOAT gives the</span>
<span class="comments">;             number of decimal digits to print.  By definition,</span>
<span class="comments">;             setting this keyword will involve the loss of some</span>
<span class="comments">;             precision compared to the original value.</span>
<span class="comments">;             Default: full precision is printed.</span>
<span class="comments">;</span>
<span class="comments">;   ZERO - if set, then the output command will have zero values for</span>
<span class="comments">;          all fields, regardless of the contents of the input data.</span>
<span class="comments">;</span>
<span class="comments">;            </span>
<span class="comments">; RETURNS:</span>
<span class="comments">;   The resulting converted string, if successful.  Upon failure,</span>
<span class="comments">;   STATUS is set to zero and the empty string ('') is returned.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;   </span>
<span class="comments">;   Convert a double array to text using the default output option,</span>
<span class="comments">;     IDL> x = [[1,2],[3,4]]</span>
<span class="comments">;     IDL> print, inputform(x)</span>
<span class="comments">;     --->   [[1,2],[3,4]]</span>
<span class="comments">;</span>
<span class="comments">;   The same input, but using the /ZERO and /ARRAY_NOTATION options,</span>
<span class="comments">;     IDL> print, inputform(x, /zero)</span>
<span class="comments">;     --->   [[0,0],[0,0]]</span>
<span class="comments">;     IDL> print, inputform(x, /array_notation)</span>
<span class="comments">;     --->   INTARR(2L,2L)</span>
<span class="comments">;</span>
<span class="comments">;   Convert a structure,</span>
<span class="comments">;     IDL> y = create_struct('s1',5,'s2','strvalue','s3',[1,2,3])</span>
<span class="comments">;     IDL> print, inputform(y)</span>
<span class="comments">;     --->   [{S1:5,S2:'strvalue',S3:[1,2,3]}]</span>
<span class="comments">;</span>
<span class="comments">;   Also with /ZERO and /ARRAY_NOTATION options,</span>
<span class="comments">;     IDL> print, inputform(y, /zero)</span>
<span class="comments">;     --->   {S1:0,S2:'',S3:[0,0,0]}</span>
<span class="comments">;     IDL> print, inputform(y, /array_notation)</span>
<span class="comments">;     --->   {S1:5,S2:'strvalue',S3:INTARR(3L)}</span>
<span class="comments">;     (Note that in the final case with /ARRAY_NOTATION alone, S3 is</span>
<span class="comments">;      replaced by INTARR(), but that the scalars are left unchanged.)</span>
<span class="comments">;     IDL> print, inputform(y, /zero, /array_notation)</span>
<span class="comments">;     --->   {S1:0,S2:'',S3:INTARR(3L)}</span>
<span class="comments">;     (With /ZERO and /ARRAY_NOTATION combined, then all fields are</span>
<span class="comments">;      zero or blank).</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   STRING, PRINT, HELP, HELPFORM</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, CM, 10 Apr 2000</span>
<span class="comments">;   Added HELPFORM to SEE ALSO, CM, 04 Jul 2000</span>
<span class="comments">;   Corrected case of scalar float value, CM, 13 Jul 2000</span>
<span class="comments">;   Put a space after float types like 1E or 1D to ease parsing, CM,</span>
<span class="comments">;     18 Jul 2000</span>
<span class="comments">;   Add ability to print INPUTFORM of pointers, CM, 09 Dec 2002</span>
<span class="comments">;   Add ability to print INPUTFORM of object pointers, CM, 01 Oct 2003</span>
<span class="comments">;   Bug fix: actually obey MAX_ELEMENTS (was being ignored), CM, 22</span>
<span class="comments">;     Oct 2006</span>
<span class="comments">;   Change to square-bracket array syntax, CM, 27 Feb 2007</span>
<span class="comments">;   Add the ZERO and ARRAY_NOTATION keywords; handle NAN and INFINITY</span>
<span class="comments">;     values properly, CM, 02 Jun 2009</span>
<span class="comments">;   Add N_FLOAT keyword, CM, 13 Nov 2010</span>
<span class="comments">;   </span>
<span class="comments">;</span>
<span class="comments">;  $Id: inputform.pro,v 1.8 2010/11/13 09:27:36 cmarkwar Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000,2001,2002,2003,2006,2007,2009,2010 Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

<span class="comments">;; Forward declarations of functions, for goodness's sake</span>
forward_function inputform_int, inputform_float, inputform_string, $
  inputform_struct, inputform_basic, inputform

<span class="comments">;; Convert an integer style value to a string</span>
<a id="inputform_int:source"></a>function inputform_int, x, format, zero=zero
  COMPILE_OPT strictarr
  n = n_elements(x)
  if keyword_set(zero) then x[*] = 0
  <span class="comments">;; Construct format like (N(format,:,","))</span>
  fmt = '('+strtrim(n,2)+'('+format+',:,","))'
  return, string(x, format=fmt)
end

<span class="comments">;; Convert a floating style value to a string.  Note the conversion</span>
<span class="comments">;; happens twice, once as a E and once as a G.  The shortest correct</span>
<span class="comments">;; version of the two is used.</span>
<a id="inputform_float:source"></a>function inputform_float, x, format, dconvert=dcon, zero=zero, $
                          nfloat=nfloat
  COMPILE_OPT strictarr
  n = n_elements(x)
  sz = size(x) & tp = sz[sz[0]+1]

  gfmt = 'G0'
  if n_elements(nfloat) GT 0 then gfmt = gfmt+'.'+strtrim(nfloat,2)
  gfmt = '('+gfmt+')'

  if keyword_set(zero) then begin
      x[*] = 0
      str = string(x, format=gfmt)
  endif else begin

      str = string(x[*], format=format)

      <span class="comments">;; Sorry, there appears to be no other way to make nice looking</span>
      <span class="comments">;; floating point numbers.</span>
      str1 = string(x[*], format=gfmt)
      if n_elements(nfloat) EQ 0 then begin
          if tp EQ 4 then x1 = float(str1)
          if tp EQ 5 then x1 = double(str1)
          wh = where(x-x1 EQ 0, ct)
          if ct GT 0 then str[wh] = str1[wh]
          str1 = 0
      endif else begin
          str = temporary(str1)
      endelse
  endelse
  str = strtrim(str,2)

  p = strpos(str[0], 'E')  <span class="comments">;; Make sure at least one element is float-type</span>
  <span class="comments">;; Note, the space is needed in case the string is placed inside</span>
  <span class="comments">;; another expression down the line.</span>
  if p LT 0 then begin
      if keyword_set(dcon) then str[0] = str[0] + 'D' $
      else str[0] = str[0] + 'E'
  endif
  if keyword_set(dcon) then begin
      <span class="comments">;; Convert from floating to double</span>
      p = strpos(str, 'E')
      wh = where(p GE 0, ct)
      for i = 0L, ct-1 do begin
          str1 = str[wh[i]]
          strput, str1, 'D', p[wh[i]]
          str[wh[i]] = str1
      endfor
  endif

  if NOT keyword_set(zero) then begin
      <span class="comments">;; Handle NAN</span>
      wh = where(x NE x, ct)
      if ct GT 0 then begin
          str[wh] = (keyword_set(dcon)) ? ('!VALUES.D_NAN') : ('!VALUES.F_NAN')
      endif
      
      <span class="comments">;; Handle infinities</span>
      <span class="comments">;; ... plus infinity ...</span>
      wh = where(x EQ !values.d_infinity, ct)
      if ct GT 0 then begin
          str[wh] = (keyword_set(dcon)) ? ('!VALUES.D_INFINITY') : ('!VALUES.F_INFINITY')
      endif
      <span class="comments">;; ... minus infinity ...</span>
      wh = where(x EQ -!values.d_infinity, ct)
      if ct GT 0 then begin
          str[wh] = (keyword_set(dcon)) ? ('-!VALUES.D_INFINITY') : ('-!VALUES.F_INFINITY')
      endif
  endif

  <span class="comments">;; Construct format like (N(A,:,","))</span>
  fmt = '('+strtrim(n,2)+'(A,:,","))'
  return, string(str, format=fmt)
end

<span class="comments">;; Convert a string to a string.  This means protecting against stray</span>
<span class="comments">;; quotation marks.</span>
<a id="inputform_string:source"></a>function inputform_string, x, zero=zero
  COMPILE_OPT strictarr
  n = n_elements(x)

  if keyword_set(zero) then begin
      x1 = strarr(n)
  endif else begin
      x1 = x
      <span class="comments">;; Strings must be protected against having quotation marks within</span>
      <span class="comments">;; themselves</span>
      wh = where(strpos(x1, "'") GE 0, ct)
      if ct GT 0 then begin
          for i = 0L, ct-1 do begin
              x2 = x1[wh[i]]
              <span class="comments">;; Find each quotation mark and replace it</span>
              p = strpos(x2, "'")
              while p GE 0 do begin
                  l = strlen(x2)
                  if p GE 0 then x2 = strmid(x2, 0, p)+"'"+strmid(x2, p, l-p)
                  p = strpos(x2, "'", p+2)
              endwhile
              x1[wh[i]] = x2
          endfor
      endif
  endelse

  <span class="comments">;; Now protected, the strings can be joined</span>
  fmt = '('+strtrim(n,2)+'("''",A,"''",:,","))'
  return, string(x1, format=fmt)
end

<span class="comments">;; Convert a structure type.  Recursive calls to inputform() are</span>
<span class="comments">;; performed to convert the internal tag values.</span>
<a id="inputform_struct:source"></a>function inputform_struct, data, status=status, errmsg=errmsg, zero=zero, $
                           array_notation=arrnot, nocatch=nocatch, $
                           nfloat=nfl
  COMPILE_OPT strictarr
  n = n_elements(data)
  s0 = ''
  tn = tag_names(data)
  sn = tag_names(data, /structure_name)
  for i = 0L, n-1 do begin
      s = '{'
      <span class="comments">;; Open braces and add structure name if possible</span>
      if sn NE '' then s = s + sn + ','
      comma = ''
      for j = 0L, n_elements(tn)-1 do begin
          <span class="comments">;; Add each tag</span>
          status = 0
          s = s + comma + tn[j] + ':' + $
            inputform(data[i].(j), status=status, errmsg=errmsg, max_dim=2, $
                      zero=zero, array_notation=arrnot, $
                      n_float_digits=nfloat, $
                      nocatch=nocatch)
          if status NE 1 then return, ''
          comma = ','
      endfor
      s = s + '}'
      if i NE n-1 then s = s + ','
      s0 = s0 + s
  endfor
  status = 1
  return, s0
end

<span class="comments">;; Convert pointer</span>
<a id="inputform_ptr:source"></a>function inputform_ptr, x, tp, zero=zero
  COMPILE_OPT strictarr
  nel = n_elements(x)

  if tp EQ 10 then fun = 'PTR' else fun = 'OBJ'
  if keyword_set(zero) then begin
      if nel EQ 1 then return, fun+'_NEW()'
      return, string(fun, nel, format='(A0,"_ARR(",I0,")")')
  endif

  <span class="comments">;; Convert to string representation, then fish out the integers</span>
  strep = string(x, /print)
  stb = byte(strep)
  st0 = stb*0b + 32b
  <span class="comments">;; Fish out the integers...</span>
  wh = where(stb GE (byte('0'))[0] AND stb LE (byte('9'))[0], ct)
  if ct GT 0 then st0[wh] = stb[wh]
  
  <span class="comments">;; .. but also replace Nulls with 0 and '>' with commas</span>
  wh = where(stb EQ (byte('>'))[0], ct)
  if ct GT 0 then st0[wh] = (byte(','))[0]
  wh = where(stb EQ (byte('N'))[0], ct)
  if ct GT 0 then st0[wh] = (byte('0'))[0]

  sti = strcompress(string(st0),/remove_all)
  dummy = execute('ind = [0L,'+sti+'0L]')
  ind = ind[1:nel]

  <span class="comments">;; Convert to a list of pointers using PTR_VALID and /CAST</span>
  format = '('+strtrim(nel,2)+'("'+fun+'_valid(",I0,",/cast)",:,","))'
  stf = string(ind, format=format)

  return, stf
end

<span class="comments">;; Convert basic types</span>
<a id="inputform_basic:source"></a>function inputform_basic, x, status=status, errmsg=errmsg, si=si, zero=z, $
                          array_notation=arrnot, nocatch=nocatch, $
                          nfloat=nfl
  COMPILE_OPT strictarr

  s = ''
  si = ''
  status = 1
  sz = size(x)
  tp = sz[sz[0]+1]
  case (tp) of 
      1:  s = inputform_int(x, '(I0,"B")', zero=z)      <span class="comments">;; BYTE</span>
      2:  s = inputform_int(x, '(I0)', zero=z)          <span class="comments">;; INTEGER</span>
      3:  s = inputform_int(x, '(I0,"L")', zero=z)      <span class="comments">;; LONG</span>
      4:  s = inputform_float(x, '(E)', zero=z,nfl=nfl) <span class="comments">;; FLOAT</span>
      5:  s = inputform_float(x, '(E)', /dconv, zero=z,nfl=nfl) <span class="comments">;; DOUBLE</span>
      7:  s = inputform_string(x, zero=z)               <span class="comments">;; STRING</span>
      10: s = inputform_ptr(x,10, zero=z)               <span class="comments">;; POINTER</span>
      11: s = inputform_ptr(x,11, zero=z)               <span class="comments">;; OBJPTR</span>
      12: s = inputform_int(x, '(I0,"U")', zero=z)      <span class="comments">;; UNSIGNED INTEGER</span>
      13: s = inputform_int(x, '(I0,"UL")', zero=z)     <span class="comments">;; UNSIGNED LONG</span>
      14: s = inputform_int(x, '(I0,"LL")', zero=z)     <span class="comments">;; LONG64</span>
      15: s = inputform_int(x, '(I0,"ULL")', zero=z)    <span class="comments">;; UNSIGNED LONG64  </span>
      
      6: begin <span class="comments">;; COMPLEX</span>
          s  = inputform_float(float(x), '(E)', zero=z, nfl=nfl)
          si = inputform_float(imaginary(x), '(E)', zero=z, nfl=nfl)
      end
      9: begin <span class="comments">;; DCOMPLEX</span>
          s  = inputform_float(double(x), '(E)', /dconv, zero=z, nfl=nfl)
          si = inputform_float(imaginary(x), '(E)', /dconv, zero=z, nfl=nfl)
      end
      
      8: begin <span class="comments">;; STRUCTURE</span>
          s = inputform_struct(x, status=status, errmsg=errmsg, zero=z, $
                               array_notation=arrnot, nocatch=nocatch, nfl=nfl)
          if status EQ 0 then return, ''
      end

      else: return, ''
  end

  return, s
end


<a id="inputform_array1:source"></a>function inputform_array1, type, dims
  COMPILE_OPT strictarr
  return, type+'('+inputform_int(dims, '(I0,"L")')+')'
end

<a id="inputform_array:source"></a>function inputform_array, x, status=status, errmsg=errmsg, si=si
  COMPILE_OPT strictarr

  s = ''
  si = ''
  sz = size(x)
  tp = sz[sz[0]+1]
  ndim = sz[0]
  dims = sz[1:ndim]

  status = 0

  case (tp) of 
      1:  s = inputform_array1('BYTARR',dims)       <span class="comments">;; BYTE             </span>
      2:  s = inputform_array1('INTARR',dims)       <span class="comments">;; INTEGER          </span>
      3:  s = inputform_array1('LONARR',dims)       <span class="comments">;; LONG             </span>
      4:  s = inputform_array1('FLTARR',dims)       <span class="comments">;; FLOAT            </span>
      5:  s = inputform_array1('DBLARR',dims)       <span class="comments">;; DOUBLE           </span>
      6:  s = inputform_array1('COMPLEXARR',dims)   <span class="comments">;; COMPLEX</span>
      7:  s = inputform_array1('STRARR',dims)       <span class="comments">;; STRING           </span>
      9:  s = inputform_array1('DCOMPLEXARR',dims)  <span class="comments">;; DCOMPLEX</span>
      10: s = inputform_array1('PTRARR',dims)       <span class="comments">;; POINTER          </span>
      11: s = inputform_array1('OBJARR',dims)       <span class="comments">;; OBJPTR           </span>
      12: s = inputform_array1('UINTARR',dims)      <span class="comments">;; UNSIGNED INTEGER </span>
      13: s = inputform_array1('ULONARR',dims)      <span class="comments">;; UNSIGNED LONG    </span>
      14: s = inputform_array1('LON64ARR',dims)     <span class="comments">;; LONG64           </span>
      15: s = inputform_array1('ULON64ARR',dims)    <span class="comments">;; UNSIGNED LONG64  </span>
      
      else: begin
          errmsg = 'Cannot make ARRAY notation for type '+strtrim(tp,2)
          return, ''
      end
  end

  status = 1
  return, s
end


<a id="inputform_brackets:source"></a>function inputform_brackets, s, l, r, si=si, status=status, errmsg=errmsg
  COMPILE_OPT strictarr

  if status EQ 0 then return, s

  for i = 0, l-1 do begin
      s  = '[' + s
      if n_elements(si) GT 0 then if si NE '' then si = '[' + si
  endfor
  for i = 0, r-1 do begin
      s  = s + ']'
      if n_elements(si) GT 0 then if si NE '' then si = si + ']'
  endfor

  return, s
end



<span class="comments">;; Main routine</span>
<a id="inputform:source"></a>function inputform, data, errmsg=errmsg, status=status, max_elements=nmax, $
                    max_dimensions=nmaxd, max_tags=nmaxt, max_len=nmaxl, $
                    array_notation=arrnot, zero=z, $
                    n_float_digits=nfl, $
                    nocatch=nocatch

  COMPILE_OPT strictarr
  status = 0
  expr = ''
  errmsg = ''

  <span class="comments">;; General error catching, in case we didn't get everything</span>
  catcherr = 0
  if NOT keyword_set(nocatch) then catch, catcherr
  if catcherr NE 0 then begin
      catch, /cancel
      status = 0
      expr = ''
      if errmsg EQ '' then errmsg = 'An unknown conversion error occurred'
      return, expr
  endif

  sz = size(data)
  typenames = ['UNDEFINED', 'BYTE', 'INTEGER', 'LONG', 'FLOAT', 'DOUBLE', $
               'COMPLEX', 'STRING', 'STRUCTURE', 'DCOMPLEX', 'POINTER', $
               'OBJECT', 'UNSIGNED INTEGER', 'UNSIGNED LONG', $
               'LONG64', 'UNSIGNED LONG64', 'UNKNOWN']

  <span class="comments">;; Certain types have *no* representation</span>
  ndims = sz[0]
  tp = sz[ndims+1]
  if (tp EQ 0) OR (tp GT 15) then begin
      errmsg = 'Type '+typenames[tp&lt<span class="comments">;16]+' has no input representation'</span>
      return, expr
  endif

  <span class="comments">;; Don't convert arrays that are too large</span>
  ndata = n_elements(data)
  if n_elements(nmax) EQ 0 then nmax = ndata
  if ndata GT nmax[0] then begin
      errmsg = 'DATA array has too many elements'
      return, expr
  endif

  <span class="comments">;; Arrays cannot be too big, or have anonymous structures</span>
  MAXLEN = nmax
  if ndims GT 0 then begin
      if max(sz[1:ndims]) GT MAXLEN then begin
          errmsg = string(MAXLEN, $
            format='("Array type is too large (>",I0," elements per dim)")')
          return, expr
      endif
      <span class="comments">;; Structure cannot be anonymous</span>
      if ndata GT 1 AND tp EQ 8 then begin
          if tag_names(data[0], /structure) EQ '' then begin
              errmsg = 'Arrays of anonymous structures are not permitted'
              return, expr
          endif
      endif
  endif

  odims = 1L     <span class="comments">;; "OUTER" dimensions </span>
  fdims = sz[1]  <span class="comments">;; "INNER" dimensions</span>
  if ndims EQ 0 then fdims = 1L
  if ndims GE 2 then for i = 2, ndims do odims = odims * sz[i]

  if ndims GT 0 then begin
      dims = sz[1:ndims]
  endif else begin
      dims = [0L]
  endelse

  <span class="comments">;; Look for the maximum number of dimensions or structure tags</span>
  if n_elements(nmaxd) GT 0 then if ndims GT nmaxd[0] then begin
      errmsg = 'Array has too many dimensions'
      return, expr
  endif
  if tp EQ 8 AND n_elements(nmaxt) GT 0 then $
    if n_elements(tag_names(data[0])) GT nmaxt[0] then begin
      errmsg = 'Structure has too many tags'
      return, expr
  endif

  <span class="comments">;; Create a nicer array to work with</span>
  ss  = '' & ssi = ''
  x = reform([data], fdims, odims)

  case 1 of 
      (NDIMS EQ 0): begin    <span class="comments">;;; =========== SCALAR</span>
          ss = inputform_basic(data, si=ssi, status=status, errmsg=errmsg, zero=z, nfl=nfl)
      END

      ((NDIMS EQ 1) AND (TP EQ 8) AND (NDATA EQ 1)): begin <span class="comments">;; ====== SCALAR STRUCT</span>
          ss = inputform_basic(data, si=ssi, status=status, errmsg=errmsg, zero=z, $
                               nocatch=nocatch, array_notation=arrnot, nfl=nfl)
      END

      (keyword_set(arrnot) AND (TP NE 8)): begin
          ss = inputform_array(data, status=status, errmsg=errmsg)
      end
          
      (NDIMS EQ 1): begin    <span class="comments">;;; =========== 1-D ARRAY</span>
          ss = inputform_basic(data, si=ssi, status=status, errmsg=errmsg, zero=z, nfl=nfl)
          ss = inputform_brackets(ss, 1, 1, si=si, status=status, errmsg=errmsg)
      end
          
      else: begin    <span class="comments">;; ========== Higher dimensional arrays</span>
          xdims = dims[1:*]
          for i = 1, ndims-2 do xdims[i] = xdims[i]*xdims[i-1]
  
          comma = ''
          
          for i = 0L, odims-1 do begin
              
              xx = x[*,i]
              
              <span class="comments">;; Opening and closing brackets depends on whether we</span>
              <span class="comments">;; are at the end of a multiple of the array dimensions.</span>
              wh = where((i MOD xdims) EQ 0,     nleft)  & nleft  = nleft  + 1
              wh = where(((i+1) MOD xdims) EQ 0, nright) & nright = nright + 1

              <span class="comments">;; Representation with brackets</span>
              s = inputform_brackets(inputform_basic(xx, si=si, zero=z, nfl=nfl, $
                                                     errmsg=errmsg, status=status), $
                                     nleft, nright, si=si, $
                                     errmsg=errmsg, status=status)

              <span class="comments">;; Accumulate with previous values</span>
              ss  = ss  + comma + s
              ssi = ssi + comma + si 

              if status EQ 0 then break

              comma = ','
              if n_elements(nmaxl) GT 0 then $
                if strlen(ss)+strlen(ssi) GT nmaxl[0] then begin
                  ss = ss + '...'
                  ssi = ssi + '...'
                  break
              endif

          endfor
      end
  endcase

  <span class="comments">;; If we had an error condition above, do not continue</span>
  if status EQ 0 then return, expr

  <span class="comments">;; Merge real and imaginary parts together</span>
  if NOT keyword_set(arrnot) then begin
      if tp EQ 6 then ss =  'COMPLEX('+ss+','+ssi+')'
      if tp EQ 9 then ss = 'DCOMPLEX('+ss+','+ssi+')'
  endif
  s = ''
  <span class="comments">;; Final dimensions can be lost if they are not reformed</span>
  if ndims GT 1 then begin
      for j = ndims-1, 0, -1 do begin
          if dims[j] NE 1 then goto, DONE_DCHECK
      endfor
      DONE_DCHECK:
      if j NE ndims-1 then $
        ss = 'REFORM('+ss+','+inputform(dims)+')'
  endif

  <span class="comments">;; Return</span>
  expr = ss
  status = 1
  return, expr
end
</code>
    </div>
  </body>
</html>