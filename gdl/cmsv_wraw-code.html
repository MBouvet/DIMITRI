<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:34 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsv_wraw.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsv_wraw.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSV_WRAW</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Write raw SAVE data to output block</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   CMSV_WRAW, BLOCK, POINTER, DATA, UNIT=UNIT, $</span>
<span class="comments">;              STRING=STRING, LONG=LONG, BYTE=BYTE, TYPE=TYPE, $</span>
<span class="comments">;              OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   This procedure writes raw integer or string data to an IDL SAVE</span>
<span class="comments">;   block in memory.  This is the lowest level writing function in the</span>
<span class="comments">;   library, intended for developers who are investigating new and</span>
<span class="comments">;   existing SAVE file formats.</span>
<span class="comments">;</span>
<span class="comments">;   The data to be written is specified by the DATA parameter.  The</span>
<span class="comments">;   data must be of type BYTE, LONG or STRING, and the type is</span>
<span class="comments">;   determined automatically from the data itself.  [ The mnemonic</span>
<span class="comments">;   STRING LONG and BYTE keywords are accepted for programming clarity</span>
<span class="comments">;   but ignored. ]</span>
<span class="comments">;</span>
<span class="comments">;   This procedure accepts but currently ignores the UNIT keyword.  It</span>
<span class="comments">;   is the caller's responsibility to write the BLOCK data to disk</span>
<span class="comments">;   when appropriate.</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; BLOCK, POINTER, OFFSET</span>
<span class="comments">;</span>
<span class="comments">;   This procedure writes data to a byte array only.  The intent is</span>
<span class="comments">;   for users to accumulate a significant amount of data in a BLOCK</span>
<span class="comments">;   and then write it out with a single call to WRITEU.  Users should</span>
<span class="comments">;   be aware that the block can be larger than the buffered data, so</span>
<span class="comments">;   they should use something like the following:</span>
<span class="comments">;</span>
<span class="comments">;          WRITEU, UNIT, BLOCK(0:POINTER-1)</span>
<span class="comments">;</span>
<span class="comments">;   When library routines do indeed write buffered BLOCK data to disk,</span>
<span class="comments">;   they will appropriately reset the BLOCK and POINTER.  Namely,</span>
<span class="comments">;   BLOCK will be reset to empty, and POINTER will be reset to zero.</span>
<span class="comments">;   OFFSET will be advanced the according number of bytes.</span>
<span class="comments">;</span>
<span class="comments">;   The terminology is as follows: BLOCK is a byte array which</span>
<span class="comments">;   represents a portion of, or an entire, IDL SAVE file.  The block</span>
<span class="comments">;   may be a cached portion of an on-disk file, or an entire in-memory</span>
<span class="comments">;   SAVE file.  POINTER is the current file pointer within BLOCK</span>
<span class="comments">;   (i.e., the next byte to be written is BLOCK[POINTER]).  Hence, a</span>
<span class="comments">;   POINTER value of 0 refers to the start of the block.  OFFSET is</span>
<span class="comments">;   the file offset of the 0th byte of BLOCK; thus "POINT_LUN,</span>
<span class="comments">;   OFFSET+POINTER" should point to the same byte as BLOCK[POINTER].</span>
<span class="comments">;   The following diagram shows the meanings for BLOCK, POINTER and</span>
<span class="comments">;   OFFSET schematically:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;                 0 &lt;-  OFFSET  -> |</span>
<span class="comments">;   FILE          |----------------|------*--------|---------></span>
<span class="comments">;</span>
<span class="comments">;   BLOCK                          |------*--------|</span>
<span class="comments">;                                  0      ^ POINTER</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK - a byte array, a cache of the SAVE file.  Users will</span>
<span class="comments">;           usually not access this array directly.  Users are advised</span>
<span class="comments">;           to clear BLOCK after calling POINT_LUN or writing the</span>
<span class="comments">;           block to disk.</span>
<span class="comments">;</span>
<span class="comments">;   POINTER - a long integer, a pointer to the next byte to be written</span>
<span class="comments">;             from BLOCK.  CMSVLIB routines will automatically advance</span>
<span class="comments">;             the pointer.</span>
<span class="comments">;</span>
<span class="comments">;   DATA - the data to be written.  Must of type STRING, BYTE or LONG.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   LONG - ignored (to be used for clarity)</span>
<span class="comments">;   BYTE - ignored (to be used for clarity)</span>
<span class="comments">;   STRING - ignored (to be used for clarity)</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a file unit.  Currently ignored.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSET - the file offset of byte zero of BLOCK.  </span>
<span class="comments">;            Upon output, if the file pointer is advanced, OFFSET will</span>
<span class="comments">;            also be changed.</span>
<span class="comments">;            (OFFSET is not currently used by this routine)</span>
<span class="comments">;            Default: 0</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, this keyword will contain 1 for success and</span>
<span class="comments">;            0 for failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return with a failure, this keyword will contain the</span>
<span class="comments">;            error condition as a string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 2000</span>
<span class="comments">;   Documented, 24 Jan 2001</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   Fixed bug in writing of empty strings, 28 Mar 2006, CM</span>
<span class="comments">;   Fixed bug when writing strings >128 characters, 2012-04-05, CM</span>
<span class="comments">;   NOTE: remember to modify CMSVLIB.PRO when changing library!</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsv_wraw.pro,v 1.9 2012/04/05 20:43:09 cmarkwar Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, 2006, 2012, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>
<a id="cmsv_enlarge:source"></a>pro cmsv_enlarge, block, pointer, nbytes, status=status, errmsg=errmsg

  status = 1

  diff = pointer+nbytes - n_elements(block)
  if diff GT 0 then begin
      if n_elements(block) GT 0 then $
        block = [temporary(block), bytarr(diff + 1024L)] $
      else $
        block = bytarr(diff + 1024L)
  endif

  return
end

<a id="cmsv_wraw:source"></a>pro cmsv_wraw, block, pointer, value0, unit=unit, replen=replen, $
               byte=byte, long=long, string=string, $
               status=status, errmsg=errmsg

  if n_elements(pointer) EQ 0 then pointer = 0L
  sz = size(value0)
  tp = sz(sz(0)+1)
  
  if tp EQ 7 then begin   <span class="comments">;; STRING DATA</span>
      <span class="comments">;; STRING_DATA</span>
      <span class="comments">;;   LONG - STRLEN - string length in characters</span>
      <span class="comments">;;   BYTExSTRLEN - string characters, padded to next four-byte boundary</span>

      if n_elements(pointer) EQ 0 then pointer = 0L

      <span class="comments">;; Compute number of bytes required to store this data</span>
      replen1 = keyword_set(replen)
      len = strlen(value0)
      <span class="comments">;; Length in bytes of the string header</span>
      llen = 4*(replen1*(len GT 0) + 1) 

      stride = 4
      ntotbytes = long( total(floor((len+3)/4)*4L + llen) )
      if pointer+ntotbytes GT n_elements(block) then $
        cmsv_enlarge, block, pointer, ntotbytes

      for i = 0L, n_elements(value0)-1 do begin
          name = value0(i)

          <span class="comments">;; Add string length</span>
          hlen = len(i)
          byteorder, hlen, /HTONL
          block(pointer) = byte(hlen, 0, 4)
          if replen1 AND hlen NE 0 then block(pointer+4) = byte(hlen, 0, 4)
          pointer = pointer + stride + stride*replen1*(hlen NE 0)

          if len(i) GT 0 then begin
              <span class="comments">;; Add string contents</span>
              nbytes = floor((len(i)+3)/4)*4L  <span class="comments">;; Round up to next 4-bytes</span>
              block(pointer) = byte(name)
              pointer = pointer + nbytes
          endif
      endfor

      status = 1
      return
  endif

  status = 0

  nelt = n_elements(value0)
  sz = size(value0)
  tp = sz(sz(0)+1)
  value = value0

  if tp EQ 1 then begin
      nbytes = 1L    <span class="comments">;; BYTE DATA</span>
  endif else if tp EQ 3 then begin
      nbytes = 4L    <span class="comments">;; LONG DATA</span>
  endif else begin
      status = 0
      errmsg = 'ERROR: CMSV_WRAW: data must byte BYTE, LONG or STRING'
      return
  endelse
      
  ntotbytes = nbytes * nelt

  if pointer+ntotbytes GT n_elements(block) then $
    cmsv_enlarge, block, pointer, ntotbytes

  common cmsv_conv_common, lendian
  if n_elements(lendian) EQ 0 then begin
      <span class="comments">;; Little-endian?</span>
      lendian = (long(['01'xb,'02'xb,'03'xb,'04'xb],0,1))(0) NE '01020304'xl
  endif

  <span class="comments">;; Convert values to net order from host endianness</span>
  case nbytes of 
<span class="comments">;     1: dummy = 1                                    ; byte</span>
<span class="comments">;     2: byteorder, value, /HTONS                     ; int </span>
      4: byteorder, value, /HTONL                     <span class="comments">; long</span>
<span class="comments">;     8: if lendian then byteorder, value, /L64SWAP   ; long64</span>
      else:
  endcase

  block(pointer) = byte(temporary(value), 0, ntotbytes)

  pointer = pointer + ntotbytes
  status = 1
  return
end
</code>
    </div>
  </body>
</html>