<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:34 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsv_wdata.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsv_wdata.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSV_WDATA</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Write SAVE-formatted data variable record to output block or file</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   CMSV_WDATA, BLOCK, POINTER, DATA, UNIT=UNIT, TEMPORARY=TEMPORARY, $</span>
<span class="comments">;               PTR_INDEX=PTR_INDEX, PTR_DATA=PTR_DATA, $</span>
<span class="comments">;               OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   CMSV_WDATA writes the data portion of an IDL SAVE variable record.</span>
<span class="comments">;   An IDL variable is stored in two components: the type descriptor</span>
<span class="comments">;   which describes the name, type, and dimensions of the variable;</span>
<span class="comments">;   and the data record, which contains the raw data of the variable.</span>
<span class="comments">;   This procedure writes the raw data to the output.  The initial</span>
<span class="comments">;   type descriptor portion of the record must have already been</span>
<span class="comments">;   writtenusing the CMSV_WVTYPE procedure.</span>
<span class="comments">;</span>
<span class="comments">;   Under normal circumstances a user will write variable or heap data</span>
<span class="comments">;   using the CMSV_WREC procedure.</span>
<span class="comments">;</span>
<span class="comments">;   CMSV_WDATA supports the following variable types:</span>
<span class="comments">;</span>
<span class="comments">;     BYTE(1),INT(2),LONG(3) - integer types</span>
<span class="comments">;     UINT(12),ULONG(13),LONG64(14),ULONG64(15) - integer types (IDL >5.2 only)</span>
<span class="comments">;     FLOAT(4),DOUBLE(5),COMPLEX(6),DCOMPLEX(9) - float types</span>
<span class="comments">;     STRING(7) - string type</span>
<span class="comments">;     STRUCT(8) - structure type</span>
<span class="comments">;     POINTER(10) - pointer type - SEE BELOW</span>
<span class="comments">;     NOT SUPPORTED - OBJ(11) - object reference type - NOT SUPPORTED</span>
<span class="comments">;</span>
<span class="comments">;   Arrays and structures containing any of the supported types are</span>
<span class="comments">;   supported (including structures within structures).</span>
<span class="comments">;</span>
<span class="comments">;   The caller must specify in the DATA parameter, the data to be</span>
<span class="comments">;   written to output.  The variable passed as DATA must have the same</span>
<span class="comments">;   type and dimensions as passed to CMSV_WVTYPE.</span>
<span class="comments">;</span>
<span class="comments">;   Unlike most of the other output routines, this procedure is able</span>
<span class="comments">;   to send its output to a file rather than to the BLOCK buffer.  If</span>
<span class="comments">;   the UNIT keyword is specified then output is sent to that file</span>
<span class="comments">;   UNIT, after any pending BLOCK data is first sent.  Users should</span>
<span class="comments">;   note that after such operations, the BLOCK POINTER and OFFSET</span>
<span class="comments">;   parameters may be modified (ie reset to new values).</span>
<span class="comments">;</span>
<span class="comments">;   See CMSV_WREC for instructions on how to write heap data.</span>
<span class="comments">;</span>
<span class="comments">;   [ This code assumes the record header and type descriptor have</span>
<span class="comments">;   been written with CMSV_WREC and CMSV_WVTYPE. ]</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; BLOCK, POINTER, OFFSET</span>
<span class="comments">;</span>
<span class="comments">;   This procedure writes data to a byte array or a file.  If the UNIT</span>
<span class="comments">;   keyword is specified then file is sent to the specified unit</span>
<span class="comments">;   number rather than to the buffer BLOCK.  However, the intent is</span>
<span class="comments">;   for users to accumulate a significant amount of data in a BLOCK</span>
<span class="comments">;   and then write it out with a single call to WRITEU.  Users should</span>
<span class="comments">;   be aware that the block can be larger than the buffered data, so</span>
<span class="comments">;   they should use something like the following:</span>
<span class="comments">;</span>
<span class="comments">;          WRITEU, UNIT, BLOCK(0:POINTER-1)</span>
<span class="comments">;</span>
<span class="comments">;   When library routines do indeed write buffered BLOCK data to disk,</span>
<span class="comments">;   they will appropriately reset the BLOCK and POINTER.  Namely,</span>
<span class="comments">;   BLOCK will be reset to empty, and POINTER will be reset to zero.</span>
<span class="comments">;   OFFSET will be advanced the according number of bytes.</span>
<span class="comments">;</span>
<span class="comments">;   The terminology is as follows: BLOCK is a byte array which</span>
<span class="comments">;   represents a portion of, or an entire, IDL SAVE file.  The block</span>
<span class="comments">;   may be a cached portion of an on-disk file, or an entire in-memory</span>
<span class="comments">;   SAVE file.  POINTER is the current file pointer within BLOCK</span>
<span class="comments">;   (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a</span>
<span class="comments">;   POINTER value of 0 refers to the start of the block.  OFFSET is</span>
<span class="comments">;   the file offset of the 0th byte of BLOCK; thus "POINT_LUN,</span>
<span class="comments">;   OFFSET+POINTER" should point to the same byte as BLOCK[POINTER].</span>
<span class="comments">;   The following diagram shows the meanings for BLOCK, POINTER and</span>
<span class="comments">;   OFFSET schematically:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;                 0 &lt;-  OFFSET  -> |</span>
<span class="comments">;   FILE          |----------------|------*--------|---------></span>
<span class="comments">;</span>
<span class="comments">;   BLOCK                          |------*--------|</span>
<span class="comments">;                                  0      ^ POINTER</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK - a byte array, a cache of the SAVE file.  Users will</span>
<span class="comments">;           usually not access this array directly.  Users are advised</span>
<span class="comments">;           to clear BLOCK after calling POINT_LUN or writing the</span>
<span class="comments">;           block to disk.</span>
<span class="comments">;</span>
<span class="comments">;   POINTER - a long integer, a pointer to the next byte to be read</span>
<span class="comments">;             from BLOCK.  CMSVLIB routines will automatically</span>
<span class="comments">;             advance the pointer.</span>
<span class="comments">;</span>
<span class="comments">;   DATA - the data to be written, of any save-able data type.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   TEMPORARY - if set, then the input DATA are discarded after being</span>
<span class="comments">;               written, as a memory economy provision.</span>
<span class="comments">;</span>
<span class="comments">;   PTR_INDEX - a heap index array for the data being written, if any</span>
<span class="comments">;               heap data records have been written.</span>
<span class="comments">;               Default: no pointers are written</span>
<span class="comments">;</span>
<span class="comments">;   PTR_DATA - an array of pointers, pointing to the heap values being</span>
<span class="comments">;              written.</span>
<span class="comments">;              Default: no pointers are written</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a file unit.  If specified then data are directed to the</span>
<span class="comments">;          file unit rather than to the buffer BLOCK.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSET - the file offset of byte zero of BLOCK.  </span>
<span class="comments">;            Upon output, if the file pointer is advanced, OFFSET will</span>
<span class="comments">;            also be changed.</span>
<span class="comments">;            (OFFSET is not currently used by this routine)</span>
<span class="comments">;            Default: 0</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, this keyword will contain 1 for success and</span>
<span class="comments">;            0 for failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return with a failure, this keyword will contain the</span>
<span class="comments">;            error condition as a string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 2000</span>
<span class="comments">;   Documented, 24 Jan 2001</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   Added support for byte scalars and arrays (!), 27 Mar 2006, CM</span>
<span class="comments">;   NOTE: remember to modify CMSVLIB.PRO when changing library!</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsv_wdata.pro,v 1.10 2009/11/22 22:50:49 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, 2006, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>

<span class="comments">; ---------------- Convert from host to network order ------------------</span>
<a id="cmsv_wconv:source"></a>pro cmsv_wconv, data

  <span class="comments">;; Inspired by IDL Astronomy Library routine HOST_TO_IEEE</span>
  common cmsv_conv_common, lendian
  if n_elements(lendian) EQ 0 then begin
      <span class="comments">;; Little-endian?</span>
      lendian = (long(['01'xb,'02'xb,'03'xb,'04'xb],0,1))(0) NE '01020304'xl
  endif

  sz = size(data)
  case sz(sz(0)+1) of 
      1:  return                    <span class="comments">;; Byte</span>
      2:  byteorder, data, /HTONS   <span class="comments">;; Integer</span>
      3:  byteorder, data, /HTONL   <span class="comments">;; Long</span>
      4:  byteorder, data, /FTOXDR  <span class="comments">;; Float</span>
      5:  byteorder, data, /DTOXDR  <span class="comments">;; Double</span>
      6:  byteorder, data, /FTOXDR  <span class="comments">;; Complex</span>
      9:  byteorder, data, /DTOXDR  <span class="comments">;; DComplex</span>
      12: byteorder, data, /HTONS   <span class="comments">;; UInt</span>
      13: byteorder, data, /HTONL   <span class="comments">;; ULong</span>
      14: if lendian EQ 1 then byteorder, data, /L64SWAP <span class="comments">;; LONG64</span>
      15: if lendian EQ 1 then byteorder, data, /L64SWAP <span class="comments">;; ULONG64</span>
      ELSE: 
  endcase

end

<a id="cmsv_wdata:source"></a>pro cmsv_wdata, block, pointer, value, unit=unit, temporary=temp, $
                ptr_index=pi, ptr_data=pd, start=start, $
                status=status, errmsg=errmsg

  <span class="comments">;; VAR_DATA</span>
  <span class="comments">;;   LONG - START_DATA TOKEN - value 7</span>
  <span class="comments">;;   for bytes - consecutive bytes</span>
  <span class="comments">;;   for (u)ints - upcast to type long </span>
  <span class="comments">;;   for (u)longs - consecutive longs</span>
  <span class="comments">;;   for pointers - consecutive longs, indices into saved heap data</span>
  <span class="comments">;;   for strings - consecutive STRING's</span>
  <span class="comments">;;   for structs - compacted versions of above</span>
  forward_function byte, long, ulong, float, double, ptr_new

  data = 0
  if n_elements(start) EQ 0 then start = 1
  if n_elements(pointer) EQ 0 then pointer = 0L

  if keyword_set(start) then begin
      cmsv_wraw, /long, block, pointer, 7L, unit=unit, $
        status=status, errmsg=errmsg
      if status EQ 0 then return
  endif
  sz = size(value)
  tp = sz(sz(0)+1)
  if (tp EQ 11) then begin
      status = 0
      errmsg = 'ERROR: CMSV_WDATA: cannot write object data'
      return
  endif
  nelt = sz(sz(0)+2)

  if (tp EQ 8) then begin   <span class="comments">;; Structure type</span>
      tn = tag_names(value(0)) & nt = n_elements(tn)

      for i = 0L, nelt-1 do begin
          for j = 0L, nt-1 do begin
              cmsv_wdata, block, pointer, value(i).(j), start=0, $
                status=status, errmsg=errmsg
              if status EQ 0 then return
          endfor

          <span class="comments">;; Occasionally flush the data to disk</span>
          if keyword_set(start) AND n_elements(unit) GT 0 then begin
              if (i EQ nelt-1) OR (pointer GT 65536L) then begin
                  writeu, unit(0), block(0:pointer-1)
                  pointer = 0L
                  block = 0 & dummy = temporary(block)
              endif
          endif
      endfor

      return
  endif

  if tp EQ 7 then begin     <span class="comments">;; String type</span>
      cmsv_wraw, /string, block, pointer, value, /replen, $
        status=status, errmsg=errmsg
      if status EQ 0 then return

      if (n_elements(unit) GT 0 AND keyword_set(start) $
          AND pointer GT 0) then begin
          writeu, unit(0), block(0:pointer-1)
          pointer = 0L
          block = 0 & dummy = temporary(block)
      endif
      return
  endif

  <span class="comments">;; Sometimes the input data is stored as a different type</span>
  common cmsv_datatypes, stype, sbyte, nbyte, selts
  if n_elements(stype) EQ 0 then begin
      <span class="comments">;;      0      1       2       3        4        5         6    7   8</span>
      <span class="comments">;;          byte     int    long    float    double   complex str struct</span>
      stype =['','BYTE', 'LONG', 'LONG', 'FLOAT', 'DOUBLE', 'FLOAT', '', '' ]
      sbyte =[0,     1,      4,      4,       4,        8,       4,   0,  0 ]
      selts =[0,     1,      1,      1,       1,        1,       2,   0,  0 ]

      <span class="comments">;;                  9     10   11     12       13        14</span>
      <span class="comments">;;            dcomplex   ptr   obj   uint     ulong    long64   ulong64</span>
      stype =[stype,'DOUBLE', 'LONG', '', 'ULONG', 'ULONG', 'LONG64','ULONG64']
      sbyte =[sbyte,      8,     4,   0,     4,       4,        8,        8, 0]
      selts =[selts,      2,     1,   0,     1,       1,        1,        1, 0]
  endif

  status = 0
  nb = sbyte(tp&lt<span class="comments">;16)</span>
  if nb EQ 0 then begin
      errmsg = 'ERROR: CMSV_WDATA: cannot write specified type ('+strtrim(tp,2)+')'
      return
  endif
  nelt1 = nelt*selts(tp&lt<span class="comments">;16)     ;; Account for complex type</span>
  nb = nb*nelt1                 <span class="comments">;; Number of total bytes</span>

  if keyword_set(temp) then data = temporary(value) $
  else                      data = value
  if sz(0) GT 0 then data = reform(data, /overwrite)
  
  <span class="comments">;; Convert from pointer type to LONG</span>
  psz = size(pd)
  if (tp EQ 10) then begin
      odata = temporary(data)
      null = ptr_new()
      <span class="comments">;; Initialize as null pointers</span>
      if sz(0) GT 0 then data = lonarr(nelt) else data = 0L

      <span class="comments">;; Fill in the pointers if we know about it</span>
      if (n_elements(pi) GT 0) AND (n_elements(pi) EQ n_elements(pd)) $
        AND (psz(psz(0)+1) EQ 10) then begin
          for i = 0L, nelt-1 do if odata(i) NE null then begin
              wh = where(odata(i) EQ pd, ct)
              if ct GT 0 then begin
                  data(i) = abs(pi(wh(0)))
                  pi(wh(0)) = -pi(wh(0))
              endif
          endif
      endif
      odata = 0
  endif

  <span class="comments">;; Error handler returns zero and error condition</span>
  on_ioerror, WRITE_ERROR
  if 0 then begin
      WRITE_ERROR:
      errmsg = 'ERROR: CMSV_WDATA: a write error occurred'
      return
  end

  <span class="comments">;; Special conversions</span>
  if (tp EQ 1)  then begin
      <span class="comments">;; BYTE data type: make a special header which </span>
      <span class="comments">;; contains the number of bytes;  also, round </span>
      <span class="comments">;; the number of storage bytes up to the next</span>
      <span class="comments">;; 4-byte word boundary.</span>
      data1 = long(nelt)
      cmsv_wconv, data1
      data = [byte(data1,0,4),temporary(data)]

      if nb MOD 4 NE 0 then data = [temporary(data), bytarr(4-(nb MOD 4))]
      nb = n_elements(data)
  endif else begin
      if (tp EQ 2)  then data = long(temporary(data))
      if (tp EQ 12) then data = ulong(temporary(data))
      if (tp EQ 6)  then data = float(temporary(data), 0, nelt1)
      if (tp EQ 9)  then data = double(temporary(data), 0, nelt1)
      cmsv_wconv, data
  endelse

  if n_elements(unit) GT 0 then begin
      <span class="comments">;; Write data to file directly</span>
      if n_elements(pointer) GT 0 then begin
          writeu, unit(0), block(0:pointer-1)
          pointer = 0L
          block = 0 & dummy = temporary(block)
      endif
      writeu, unit(0), data
  endif else begin
      <span class="comments">;; Write data to byte buffer</span>

      cmsv_wraw, block, pointer, byte(temporary(data), 0, nb), /byte, $
        status=status, errmsg=errmsg
  endelse

  on_ioerror, NULL

  status = 1
  return
end
</code>
    </div>
  </body>
</html>