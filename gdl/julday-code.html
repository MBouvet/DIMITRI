<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:49 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>julday.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="julday.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; $Id: //depot/Release/ENVI50_IDL82/idl/idldir/lib/julday.pro#2 $</span>
<span class="comments">;</span>
<span class="comments">; Copyright (c) 1988-2012, Exelis Visual Information Solutions, Inc. All</span>
<span class="comments">;       rights reserved. Unauthorized reproduction is prohibited.</span>

<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	JULDAY</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Calculate the Julian Day Number for a given month, day, and year.</span>
<span class="comments">;	This is the inverse of the library function CALDAT.</span>
<span class="comments">;	See also caldat, the inverse of this function.</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	Misc.</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	Result = JULDAY([[[[Month, Day, Year], Hour], Minute], Second])</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;	MONTH:	Number of the desired month (1 = January, ..., 12 = December).</span>
<span class="comments">;</span>
<span class="comments">;	DAY:	Number of day of the month.</span>
<span class="comments">;</span>
<span class="comments">;	YEAR:	Number of the desired year.Year parameters must be valid</span>
<span class="comments">;               values from the civil calendar.  Years B.C.E. are represented</span>
<span class="comments">;               as negative integers.  Years in the common era are represented</span>
<span class="comments">;               as positive integers.  In particular, note that there is no</span>
<span class="comments">;               year 0 in the civil calendar.  1 B.C.E. (-1) is followed by</span>
<span class="comments">;               1 C.E. (1).</span>
<span class="comments">;</span>
<span class="comments">;	HOUR:	Number of the hour of the day.</span>
<span class="comments">;</span>
<span class="comments">;	MINUTE:	Number of the minute of the hour.</span>
<span class="comments">;</span>
<span class="comments">;	SECOND:	Number of the second of the minute.</span>
<span class="comments">;</span>
<span class="comments">;   Note: Month, Day, Year, Hour, Minute, and Second can all be arrays.</span>
<span class="comments">;         The Result will have the same dimensions as the smallest array, or</span>
<span class="comments">;         will be a scalar if all arguments are scalars.</span>
<span class="comments">;</span>
<span class="comments">; OPTIONAL INPUT PARAMETERS:</span>
<span class="comments">;	Hour, Minute, Second = optional time of day.</span>
<span class="comments">;</span>
<span class="comments">; OUTPUTS:</span>
<span class="comments">;	JULDAY returns the Julian Day Number (which begins at noon) of the</span>
<span class="comments">;	specified calendar date.  If Hour, Minute, and Second are not specified,</span>
<span class="comments">;	then the result will be a long integer, otherwise the result is a</span>
<span class="comments">;	double precision floating point number.</span>
<span class="comments">;</span>
<span class="comments">; COMMON BLOCKS:</span>
<span class="comments">;	None.</span>
<span class="comments">;</span>
<span class="comments">; SIDE EFFECTS:</span>
<span class="comments">;	None.</span>
<span class="comments">;</span>
<span class="comments">; RESTRICTIONS:</span>
<span class="comments">;	Accuracy using IEEE double precision numbers is approximately</span>
<span class="comments">;   1/10000th of a second, with higher accuracy for smaller (earlier)</span>
<span class="comments">;   Julian dates.</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;	Translated from "Numerical Recipies in C", by William H. Press,</span>
<span class="comments">;	Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling.</span>
<span class="comments">;	Cambridge University Press, 1988 (second printing).</span>
<span class="comments">;</span>
<span class="comments">;	AB, September, 1988</span>
<span class="comments">;	DMS, April, 1995, Added time of day.</span>
<span class="comments">; CT, April 2000, Now accepts vectors or scalars.</span>
<span class="comments">; CT, June 2012: Add undocumented PROLEPTIC_GREGORIAN, used by GREG2JUL.</span>
<span class="comments">;     Also rewrote the algorithm using integer arithmetic, for speed.</span>
<span class="comments">;-</span>
<span class="comments">;</span>
<a id="JULDAY:source"></a>function JULDAY, MONTH, DAY, YEAR, Hour, Minute, Second, $
  PROLEPTIC_GREGORIAN=prolepticGregorian

COMPILE_OPT idl2

ON_ERROR, 2		<span class="comments">; Return to caller if errors</span>

<span class="comments">; Gregorian Calander was adopted on Oct. 15, 1582</span>
<span class="comments">; skipping from Oct. 4, 1582 to Oct. 15, 1582</span>
GREG = 2299171L  <span class="comments">; incorrect Julian day for Oct. 25, 1582</span>

<span class="comments">; Process the input, if all are missing, use todays date.</span>
NP = n_params()
IF (np EQ 0) THEN RETURN, SYSTIME(/JULIAN)
IF (np LT 3) THEN MESSAGE, 'Incorrect number of arguments.', $
   NONAME=KEYWORD_SET(prolepticGregorian)

<span class="comments">; Find the dimensions of the Result:</span>
<span class="comments">;  1. Find all of the input arguments that are arrays (ignore scalars)</span>
<span class="comments">;  2. Out of the arrays, find the smallest number of elements</span>
<span class="comments">;  3. Find the dimensions of the smallest array</span>

<span class="comments">; Step 1: find all array arguments</span>
nDims = [SIZE(month,/N_DIMENSIONS), SIZE(day,/N_DIMENSIONS), $
	SIZE(year,/N_DIMENSIONS), SIZE(hour,/N_DIMENSIONS), $
	SIZE(minute,/N_DIMENSIONS), SIZE(second,/N_DIMENSIONS)]
arrays = WHERE(nDims GE 1)

nJulian = 1L    <span class="comments">; assume everything is a scalar</span>
IF (arrays[0] GE 0) THEN BEGIN
	<span class="comments">; Step 2: find the smallest number of elements</span>
	nElement = [N_ELEMENTS(month), N_ELEMENTS(day), $
		N_ELEMENTS(year), N_ELEMENTS(hour), $
		N_ELEMENTS(minute), N_ELEMENTS(second)]
	nJulian = MIN(nElement[arrays], whichVar)
	<span class="comments">; step 3: find dimensions of the smallest array</span>
	CASE arrays[whichVar] OF
	0: julianDims = SIZE(month,/DIMENSIONS)
	1: julianDims = SIZE(day,/DIMENSIONS)
	2: julianDims = SIZE(year,/DIMENSIONS)
	3: julianDims = SIZE(hour,/DIMENSIONS)
	4: julianDims = SIZE(minute,/DIMENSIONS)
	5: julianDims = SIZE(second,/DIMENSIONS)
	ENDCASE
ENDIF

d_Second = 0d  <span class="comments">; defaults</span>
d_Minute = 0d
d_Hour = 0d
<span class="comments">; convert all Arguments to appropriate array size & type</span>
SWITCH np OF  <span class="comments">; use switch so we fall thru all arguments...</span>
6: d_Second = (SIZE(second,/N_DIMENSIONS) GT 0) ? $
	second[0:nJulian-1] : second
5: d_Minute = (SIZE(minute,/N_DIMENSIONS) GT 0) ? $
	minute[0:nJulian-1] : minute
4: d_Hour = (SIZE(hour,/N_DIMENSIONS) GT 0) ? $
	hour[0:nJulian-1] : hour
3: BEGIN <span class="comments">; convert m,d,y to type LONG</span>
	L_MONTH = (SIZE(month,/N_DIMENSIONS) GT 0) ? $
		LONG(month[0:nJulian-1]) : LONG(month)
	L_DAY = (SIZE(day,/N_DIMENSIONS) GT 0) ? $
		LONG(day[0:nJulian-1]) : LONG(day)
	L_YEAR = (SIZE(year,/N_DIMENSIONS) GT 0) ? $
		LONG(year[0:nJulian-1]) : LONG(year)
	END
ENDSWITCH


min_calendar = -4801
max_calendar = 5000000
minn = MIN(l_year, MAX=maxx)
IF (minn LT min_calendar) OR (maxx GT max_calendar) THEN MESSAGE, $
	'Value of Julian date is out of allowed range.', $
   NONAME=KEYWORD_SET(prolepticGregorian)
if (MAX(L_YEAR eq 0) NE 0) then message, $
	'There is no year zero in the civil calendar.', $
   NONAME=KEYWORD_SET(prolepticGregorian)


bc = (L_YEAR LT 0)
L_YEAR = TEMPORARY(L_YEAR) + TEMPORARY(bc)
inJanFeb = (L_MONTH LE 2)
JY = L_YEAR - inJanFeb + 4800
JM = L_MONTH + 12b*TEMPORARY(inJanFeb) - 3

JUL = 365*JY + JY/4 + (153*TEMPORARY(JM)+2)/5 + TEMPORARY(L_DAY) - 32083

  <span class="comments">; Test whether to change to Gregorian Calendar.</span>
  <span class="comments">; For the Gregorian calendar, *after 1582*, if the year ends in a 00,</span>
  <span class="comments">; then it is not a leap year, unless it is also divisible by 400.</span>
  <span class="comments">; ;</span>
  <span class="comments">; The proleptic Gregorian extends the Gregorian calendar backwards to dates</span>
  <span class="comments">; preceeding its introduction on 15 Oct 1582. For 15 Oct 1582 or later,</span>
  <span class="comments">; the Julian Day Number will be equal regardless of whether the proleptic</span>
  <span class="comments">; Gregorian is used or not.</span>
  if (MIN(jul) ge greg || KEYWORD_SET(prolepticGregorian)) then begin
    JUL += 38L - JY/100 + JY/400
  endif else begin
  	gregChange = WHERE(JUL ge GREG, ngreg)
  	if (ngreg gt 0) then begin
  		JY = JY[gregChange]
  		JUL[gregChange] += 38L - JY/100 + JY/400
  	endif
  endelse



<span class="comments">; hour,minute,second?</span>
IF (np GT 3) THEN BEGIN <span class="comments">; yes, compute the fractional Julian date</span>
<span class="comments">; Add a small offset so we get the hours, minutes, & seconds back correctly</span>
<span class="comments">; if we convert the Julian dates back. This offset is proportional to the</span>
<span class="comments">; Julian date, so small dates (a long, long time ago) will be "more" accurate.</span>
	eps = (MACHAR(/DOUBLE)).eps
	eps = eps*ABS(jul) > eps
<span class="comments">; For Hours, divide by 24, then subtract 0.5, in case we have unsigned ints.</span>
	jul = TEMPORARY(JUL) + ( (TEMPORARY(d_Hour)/24d - 0.5d) + $
		TEMPORARY(d_Minute)/1440d + TEMPORARY(d_Second)/86400d + eps )
ENDIF

<span class="comments">; check to see if we need to reform vector to array of correct dimensions</span>
IF (N_ELEMENTS(julianDims) GT 1) THEN $
	JUL = REFORM(TEMPORARY(JUL), julianDims)

RETURN, jul

END
</code>
    </div>
  </body>
</html>