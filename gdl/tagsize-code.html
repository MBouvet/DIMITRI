<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Thu Jul  4 16:01:37 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>tagsize.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="tagsize.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   TAGSIZE</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Compute SIZE descriptors for each tag in a structure</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   SIZES = TAGSIZE(STRUCT, N_TAGS=ntags, TAG_NAMES=tagnames,</span>
<span class="comments">;                   STRUCTURE_NAME=structname, STATUS=status, LENGTH=length)</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   The TAGSIZE function determines the types and sizes of each tag in</span>
<span class="comments">;   a structure.  This is not as easy as it may seem, because IDL</span>
<span class="comments">;   makes it very, *very* difficult to find out the true dimensions of</span>
<span class="comments">;   a structure element.</span>
<span class="comments">;</span>
<span class="comments">;   Here is a brief explanation.  It is known that IDL drops trailing</span>
<span class="comments">;   dimensions of size 1 in many situations.  Also, for structures</span>
<span class="comments">;   only, arrays of any dimensionality which have only one element are</span>
<span class="comments">;   RETURNED AS SCALARS.  Thus, if you are doing any heavy duty work</span>
<span class="comments">;   with structures, copying and querying individual elements between</span>
<span class="comments">;   structures, etc., you will find that you will lose some crucial</span>
<span class="comments">;   dimensions which you can't normally regain.</span>
<span class="comments">;</span>
<span class="comments">;   TAGSIZE attempts to work around all of these limitations to</span>
<span class="comments">;   present the true dimensions of all elements in a structure.</span>
<span class="comments">;</span>
<span class="comments">;   It returns an 11xNTAGS array, which contains a SIZE-style vector</span>
<span class="comments">;   for each element in the structure.  Eleven elements is the largest</span>
<span class="comments">;   array size needed to describe any IDL data type using SIZE.  Thus,</span>
<span class="comments">;   to extract information about the second tag in structure X</span>
<span class="comments">;   (element number 1 starting from zero), you would use the following</span>
<span class="comments">;   code:</span>
<span class="comments">;</span>
<span class="comments">;     SIZES = TAGSIZE(X)  ;; Extract type information from structure X</span>
<span class="comments">;     SIZE_1 = SIZES(*,1) ;; Extract type information about the 2nd element</span>
<span class="comments">;</span>
<span class="comments">;     SIZE_1 = SIZE_1(0:SIZE_1(0)+2) ;; Trim the array if desired</span>
<span class="comments">;</span>
<span class="comments">;   The last command is optional, but trims the resulting array to be</span>
<span class="comments">;   a true SIZE-style result.</span>
<span class="comments">;     </span>
<span class="comments">;   TAGSIZE also has several convenience keywords to extract other</span>
<span class="comments">;   relevant information about a structure.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   STRUCTURE - any structure to examine.  If the value is not a</span>
<span class="comments">;               structure then an error is reported.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   N_TAGS - upon return, the number of tags in the structure is</span>
<span class="comments">;            stored in this keyword.</span>
<span class="comments">;</span>
<span class="comments">;   TAG_NAMES - upon return, the names of each tag are stored in this</span>
<span class="comments">;               keyword, as an array of strings.</span>
<span class="comments">;</span>
<span class="comments">;   STRUCTURE_NAME - upon return, the name of the structure is stored</span>
<span class="comments">;                    in this keyword.  If the structure is anonymous</span>
<span class="comments">;                    then the empty string ('') is returned.</span>
<span class="comments">;</span>
<span class="comments">;   LENGTH - upon return, the size in bytes of each tag element in the</span>
<span class="comments">;            structure is stored in this keyword, as an array of</span>
<span class="comments">;            integers.</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, the status is stored in this keyword.  A</span>
<span class="comments">;            value of 1 indicates success, 0 indicates failure.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RETURNS:</span>
<span class="comments">;</span>
<span class="comments">;   A two dimensional array, with dimensions LONARR(11,NTAGS),</span>
<span class="comments">;   containing the size information of all tag elements in the</span>
<span class="comments">;   structure.  SIZES(*,i) is the SIZE-style vector for tag element i.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;   Compute the sizes of the elements in X, defined here.</span>
<span class="comments">;     IDL> x = {a: [1], b: intarr(2,2), c: reform(strarr(2,1),2,1)}</span>
<span class="comments">;     IDL> help, /struct, x</span>
<span class="comments">;     ** Structure &lt;818c8b4>, 3 tags, length=28, refs=1:</span>
<span class="comments">;        A               INT       Array[1]</span>
<span class="comments">;        B               INT       Array[2, 2]</span>
<span class="comments">;        C               STRING    Array[2, 1]</span>
<span class="comments">;     IDL> print, byte(tagsize(x))</span>
<span class="comments">;        1  [1]  2   1   0   0   0   0   0   0   0</span>
<span class="comments">;        2  [2   2]  2   4   0   0   0   0   0   0</span>
<span class="comments">;        2  [2   1]  7   2   0   0   0   0   0   0</span>
<span class="comments">;     [ Array dimensions are emphasized with brackets ]</span>
<span class="comments">;</span>
<span class="comments">;   Compare this to the type information returned by HELP, which is</span>
<span class="comments">;   incorrect for tags A and C.</span>
<span class="comments">;     IDL> help, x.a, x.b, x.c</span>
<span class="comments">;     &lt;Expression>    INT       =        1</span>
<span class="comments">;     &lt;Expression>    INT       = Array[2, 2]</span>
<span class="comments">;     &lt;Expression>    STRING    = Array[2]</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   TAG_NAMES, N_TAGS, SIZE, HELP, INPUTFORM, HELPFORM</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, CM, 13 May 2000</span>
<span class="comments">;   Documented, 05 Jul 2000</span>
<span class="comments">;   Small documentation changes, CM, 31 Aug 2000</span>
<span class="comments">;   Signficant cleanup of HELP parsing, CM, 04 Dec 2000</span>
<span class="comments">;   Added case for array of structures with new parsing, CM 12 Jan</span>
<span class="comments">;     2001</span>
<span class="comments">;</span>
<span class="comments">;  $Id: tagsize.pro,v 1.4 2001/02/09 04:57:42 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>
<a id="tagsize:source"></a>function tagsize, structure, n_tags=ntags, tag_names=tnames, $
                  structure_name=sname, status=status, nocatch=nocatch, $
                  length=length

  <span class="comments">;; Error checking</span>
  status = 0
  on_error, 2
  if n_elements(structure) EQ 0 then $
    message, 'ERROR: parameter must be of type STRUCTURE'
  sz = size(structure)
  if sz(sz(0)+1) NE 8 then $
    message, 'ERROR: parameter must be of type STRUCTURE'

  <span class="comments">;; Take only the first element, if STRUCTURE is an array</span>
  st = structure(0)
  <span class="comments">;; Extract "help" style output </span>
  if float(!version.release) GE 5.0 then begin
      help, st, /struct, output=hh
      hh = strtrim(hh, 2)+' '
  endif

  <span class="comments">;; Get some generic information our users are too lazy to get</span>
  <span class="comments">;; themselves.  We need some of it anyway.</span>
  tnames = tag_names(st)
  ntags  = n_elements(tnames)
  sname  = tag_names(st, /structure_name)
  
  <span class="comments">;; Output array</span>
  ssz = reform(lonarr(11, ntags), 11, ntags, /overwrite)
  length = lonarr(ntags)

  nhelp = n_elements(hh)
  <span class="comments">;; j is the index into hh, the HELP output</span>
  j = 0L  
  for i = 0L, ntags-1 do begin
      <span class="comments">;; Get some basic information</span>
      sz = size(st.(i))
      ndims = sz(0)
      <span class="comments">;; Cheap way to get the number of bytes of element i</span>
      len = n_tags({test:st.(i)}, /length)  
      
      <span class="comments">;; Arghh, this is bad!  Arrays with trailing dimensions of</span>
      <span class="comments">;; length 1 are hard to detect.  This almost does it.  What this</span>
      <span class="comments">;; tries to do is double the dimensions of a value, which breaks</span>
      <span class="comments">;; the trailing-ones degeneracy problem.  The error checking is</span>
      <span class="comments">;; for when we have an 8-dimensional array (!).  Unfortunately,</span>
      <span class="comments">;; it doesn't help if st.(i) has only one element, as evidence</span>
      <span class="comments">;; by the next load of crap.</span>
      catcherr = 0
      if NOT keyword_set(nocatch) then catch, catcherr
      if catcherr EQ 0 then xsz = size(st([0,0]).(i)) $
      else                  xsz = [9L]
      catch, /cancel
      ndims = xsz(0) - 1

      <span class="comments">;; Check for structures, always an array</span>
      if sz(sz(0)+1) EQ 8 AND ndims EQ 0 then ndims = 1
      if sz(sz(0)+2) GT 1 AND ndims EQ 0 then ndims = 1

      <span class="comments">;; Arrgggghhhh!  It gets even worse, since for some reason</span>
      <span class="comments">;; one-element array tags are converted to scalars when</span>
      <span class="comments">;; extracted.  We then parse the output of HELP, which only</span>
      <span class="comments">;; works for IDL 5.</span>
      if ndims EQ 0 AND nhelp GT 0 then begin

          <span class="comments">;; Scan to find the name of the variable of interest</span>
          wh = (where(strpos(hh, tnames(i)+' ') EQ 0, ct))(0)
          if ct EQ 0 then $
            message, 'ERROR: structure composition was inconsistent (1)'

          <span class="comments">;; Combine the next two lines, removing = signs</span>
          h1 = hh(wh) + hh((wh+1)&lt<span class="comments">;(nhelp-1))</span>
          while strpos(h1, '=') GE 0 do strput, h1, ' ', strpos(h1, '=')
          h2 = str_sep(strcompress(h1), ' ')
          n = n_elements(h2)

          <span class="comments">;; Locate the tag in the help output</span>
          if n LT 3 then $
            message, 'ERROR: structure tag '+tnames(i)+' not found'

          <span class="comments">;; Extract the dimensions</span>
          sdims = ''
          ii = 2
          if strupcase(strmid(h2(ii),0,5)) EQ 'ARRAY' then begin
              DO_ARRAY:
              slen = strlen(h2(ii)) - 7   <span class="comments">;; Remove "array[]"</span>
              sdims = strmid(h2(ii),6,slen)
              if sdims EQ '' then goto, DONE_HELP

              dims = 0 & dummy = temporary(dims)
              if execute('dims = ['+sdims+']') EQ 0 then goto, DONE_HELP

              <span class="comments">;; Sanity check</span>
              if sz(sz(0)+2) NE total(dims) then $
                message, 'ERROR: structure composition was inconsistent (2)'
              
              ndims = n_elements(dims)
              goto, DONE_HELP
          endif else if h2(2) EQ '->' then begin
              ii = 4
              goto, DO_ARRAY
          endif
            
      endif
      DONE_HELP:
      
      <span class="comments">;; Finally, FINALLY, assemble this information into a SIZE-style</span>
      <span class="comments">;; vector.</span>
      ssz(0,i) = ndims
      if ndims GT 0 then ssz(1:ndims,i) = 1     <span class="comments">;; Pre-fill with ones</span>
      if sz(0) GT 0 then ssz(1,i) = sz(1:sz(0)) <span class="comments">;; Put non-one dimensions</span>
      ssz(ndims+1,i) = sz(sz(0)+1)              <span class="comments">;; Put variable type</span>
      ssz(ndims+2,i) = sz(sz(0)+2)              <span class="comments">;; Put n_elements</span>
      length(i) = len                           <span class="comments">;; Length of tag in bytes</span>
  endfor

  status = 1
  return, ssz
end
</code>
    </div>
  </body>
</html>