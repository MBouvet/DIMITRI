<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.5.1 on Tue Jul  2 12:50:48 2013 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>cmsv_wvtype.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="../idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="../idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="cmsv_wvtype.pro (Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;   CMSV_WVTYPE</span>
<span class="comments">;</span>
<span class="comments">; AUTHOR:</span>
<span class="comments">;   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="comments">;   craigm@lheamail.gsfc.nasa.gov</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;   Write variable type information to output block</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;   CMSV_WVTYPE, BLOCK, DATA, IDENT, $</span>
<span class="comments">;                HEAP=HEAP, SYSTEM=SYSTEM, UNIT=UNIT, $</span>
<span class="comments">;                OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG</span>
<span class="comments">;   </span>
<span class="comments">; DESCRIPTION: </span>
<span class="comments">;</span>
<span class="comments">;   CMSV_WVTYPE writes the type portion of an IDL SAVE variable</span>
<span class="comments">;   record.  An IDL variable is stored in two components: the type</span>
<span class="comments">;   descriptor which describes the name, type, and dimensions of the</span>
<span class="comments">;   variable; and the data record, which contains the raw data of the</span>
<span class="comments">;   variable.  This procedure writes the type descriptor based on a</span>
<span class="comments">;   variable passed by the user.  Once the type descriptor has been</span>
<span class="comments">;   written, the data portion can be written using the CMSV_WDATA</span>
<span class="comments">;   procedure.</span>
<span class="comments">;</span>
<span class="comments">;   CMSV_WVTYPE should recognize and correctly output type descriptors</span>
<span class="comments">;   for all currently known IDL data types, except for object</span>
<span class="comments">;   references.  Type information is inferred from the DATA parameter</span>
<span class="comments">;   passed by the user.  </span>
<span class="comments">;</span>
<span class="comments">;   Heap data is a special case, since the data itself are stored</span>
<span class="comments">;   separately from the pointer in the SAVE file.  Three steps must be</span>
<span class="comments">;   satisfied: a HEAP_INDEX record must be written; a valid HEAP_DATA</span>
<span class="comments">;   record must be written containing a type descriptor (written with</span>
<span class="comments">;   this procedure) and the heap data; and the named pointer itself</span>
<span class="comments">;   must be written.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;   Research Systems, Inc. has issued a separate license intended</span>
<span class="comments">;   to resolve any potential conflict between this software and the</span>
<span class="comments">;   IDL End User License Agreement. The text of that license</span>
<span class="comments">;   can be found in the file LICENSE.RSI, included with this</span>
<span class="comments">;   software library.</span>
<span class="comments">; ==================================================================</span>
<span class="comments">;</span>
<span class="comments">; BLOCK, POINTER, OFFSET</span>
<span class="comments">;</span>
<span class="comments">;   This procedure writes data to a byte array only.  The intent is</span>
<span class="comments">;   for users to accumulate a significant amount of data in a BLOCK</span>
<span class="comments">;   and then write it out with a single call to WRITEU.  Users should</span>
<span class="comments">;   be aware that the block can be larger than the buffered data, so</span>
<span class="comments">;   they should use something like the following:</span>
<span class="comments">;</span>
<span class="comments">;          WRITEU, UNIT, BLOCK(0:POINTER-1)</span>
<span class="comments">;</span>
<span class="comments">;   When library routines do indeed write buffered BLOCK data to disk,</span>
<span class="comments">;   they will appropriately reset the BLOCK and POINTER.  Namely,</span>
<span class="comments">;   BLOCK will be reset to empty, and POINTER will be reset to zero.</span>
<span class="comments">;   OFFSET will be advanced the according number of bytes.</span>
<span class="comments">;</span>
<span class="comments">;   The terminology is as follows: BLOCK is a byte array which</span>
<span class="comments">;   represents a portion of, or an entire, IDL SAVE file.  The block</span>
<span class="comments">;   may be a cached portion of an on-disk file, or an entire in-memory</span>
<span class="comments">;   SAVE file.  POINTER is the current file pointer within BLOCK</span>
<span class="comments">;   (i.e., the next byte to be written is BLOCK[POINTER]).  Hence, a</span>
<span class="comments">;   POINTER value of 0 refers to the start of the block.  OFFSET is</span>
<span class="comments">;   the file offset of the 0th byte of BLOCK; thus "POINT_LUN,</span>
<span class="comments">;   OFFSET+POINTER" should point to the same byte as BLOCK[POINTER].</span>
<span class="comments">;   The following diagram shows the meanings for BLOCK, POINTER and</span>
<span class="comments">;   OFFSET schematically:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;                 0 &lt;-  OFFSET  -> |</span>
<span class="comments">;   FILE          |----------------|------*--------|---------></span>
<span class="comments">;</span>
<span class="comments">;   BLOCK                          |------*--------|</span>
<span class="comments">;                                  0      ^ POINTER</span>
<span class="comments">;     </span>
<span class="comments">;</span>
<span class="comments">;   This procedure is part of the CMSVLIB SAVE library for IDL by</span>
<span class="comments">;   Craig Markwardt.  You must have the full CMSVLIB core package</span>
<span class="comments">;   installed in order for this procedure to function properly.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; INPUTS:</span>
<span class="comments">;</span>
<span class="comments">;   BLOCK - a byte array, a cache of the SAVE file.  Users will</span>
<span class="comments">;           usually not access this array directly.  Users are advised</span>
<span class="comments">;           to clear BLOCK after calling POINT_LUN or writing the</span>
<span class="comments">;           block to disk.</span>
<span class="comments">;</span>
<span class="comments">;   POINTER - a long integer, a pointer to the next byte to be written</span>
<span class="comments">;             from BLOCK.  CMSVLIB routines will automatically advance</span>
<span class="comments">;             the pointer.</span>
<span class="comments">;</span>
<span class="comments">;   DATA - the data to be written, of any save-able data type.</span>
<span class="comments">;</span>
<span class="comments">;   IDENT - for variables, the name of the variable as a string; for</span>
<span class="comments">;           heap data, the heap index as an integer.</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;</span>
<span class="comments">;   HEAP - if set, the data is treated as heap data, and IDENT must be</span>
<span class="comments">;          an integer heap index.</span>
<span class="comments">;</span>
<span class="comments">;   SYSTEM - if set, the data is assumed to be a system variable.</span>
<span class="comments">;</span>
<span class="comments">;   UNIT - a file unit.  Currently ignored.</span>
<span class="comments">;</span>
<span class="comments">;   OFFSET - the file offset of byte zero of BLOCK.  </span>
<span class="comments">;            Upon output, if the file pointer is advanced, OFFSET will</span>
<span class="comments">;            also be changed.</span>
<span class="comments">;            (OFFSET is not currently used by this routine)</span>
<span class="comments">;            Default: 0</span>
<span class="comments">;</span>
<span class="comments">;   STATUS - upon return, this keyword will contain 1 for success and</span>
<span class="comments">;            0 for failure.</span>
<span class="comments">;</span>
<span class="comments">;   ERRMSG - upon return with a failure, this keyword will contain the</span>
<span class="comments">;            error condition as a string.</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;</span>
<span class="comments">;   CMRESTORE, SAVE, RESTORE, CMSVLIB</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">;   Written, 2000</span>
<span class="comments">;   Documented, 24 Jan 2001</span>
<span class="comments">;   Added notification about RSI License, 13 May 2002, CM</span>
<span class="comments">;   NOTE: remember to modify CMSVLIB.PRO when changing library!</span>
<span class="comments">;</span>
<span class="comments">; $Id: cmsv_wvtype.pro,v 1.14 2009/11/22 22:50:49 craigm Exp $</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">; Copyright (C) 2000-2001, Craig Markwardt</span>
<span class="comments">; This software is provided as is without any warranty whatsoever.</span>
<span class="comments">; Permission to use, copy, modify, and distribute modified or</span>
<span class="comments">; unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="comments">; are included unchanged.</span>
<span class="comments">;-</span>
<a id="cmsv_warrdesc:source"></a>pro cmsv_warrdesc, block, pointer, sz, status=status, length=length, $
                   errmsg=errmsg
  <span class="comments">;; ARRAY_DESC</span>
  <span class="comments">;;   LONG - START_TOKEN - value 08 - array descriptor flag</span>
  <span class="comments">;;   LONG - number of bytes per element</span>
  <span class="comments">;;   LONG - number of bytes per array</span>
  <span class="comments">;;   LONG - number of elements per array</span>
  <span class="comments">;;   LONG - number of variable dimensions</span>
  <span class="comments">;;   LONG - unknown (value 0)</span>
  <span class="comments">;;   LONG - unknown (checksum?)</span>
  <span class="comments">;;   LONG - maximum number of stored dimensions ( = 8 )</span>
  <span class="comments">;;   LONGx8 - dimensions of number</span>
  forward_function make_array

  if n_elements(pointer) EQ 0 then pointer = 0L
  nelt = sz(sz(0)+2)
  tp = sz(sz(0)+1)

  if sz(0) EQ 0 then begin
      errmsg = 'ERROR: CMSV_WVTYPE: data must be an ARRAY type'
stop
      status = 0
      return
  endif

  if n_elements(length) EQ 0 then $
    length = n_tags({test:make_array(1,type=tp)}, /length)
  buff = lonarr(16)
  buff(0) = 8           <span class="comments">;; Array descriptor token</span>
  buff(1) = length/nelt <span class="comments">;; Unknown value</span>
  buff(2) = length      <span class="comments">;; Number of bytes</span>
  buff(3) = nelt        <span class="comments">;; Number of elements</span>
  buff(4) = sz(0)       <span class="comments">;; Number of dimensions</span>
  buff(7) = 8           <span class="comments">;; Number of stored dimensions</span>
  buff(8:15) = 1        <span class="comments">;; All eight dimensions start as 1  ...</span>
  buff(8) = sz(1:sz(0)) <span class="comments">;; ... and are overwritten by the actual dimensions</span>

  cmsv_wraw, /long, block, pointer, buff, status=status, errmsg=errmsg
end

<a id="cmsv_wstructdesc:source"></a>pro cmsv_wstructdesc, block, pointer, status=status, template=template1, $
                      errmsg=errmsg, nocatch=nocatch

  <span class="comments">;; STRUCT_DESCR</span>
  <span class="comments">;;   LONG - START_TOKEN - value 9 - struct descriptor flag</span>
  <span class="comments">;;   STRING - name of struct (or 0 if anonymous)</span>
  <span class="comments">;;   LONG - unknown - value 0</span>
  <span class="comments">;;   LONG - N_TAGS - number of structure tags</span>
  <span class="comments">;;   LONG - total "length" in bytes, but nothing meaningful</span>
  <span class="comments">;;   TAGDESCxN_TAGS - TAG_TABLE - description of each tag</span>
  <span class="comments">;;   STRINGxN_TAGS - TAG_NAMES - name of each tag</span>
  <span class="comments">;;   ARRAY_DESCxN_ARRAYS - ARRAY_TAB - descriptor for each array</span>
  <span class="comments">;;   STRUCT_DESCRxN_STRUCTS - STRUCT_TAB - descriptor for each struct</span>

  if n_elements(pointer) EQ 0 then pointer = 0L
  cmsv_wraw, /long, block, pointer, 9L, status=status, errmsg=errmsg
  if status EQ 0 then return
  templ8 = template1(0)
  sn = tag_names(templ8, /structure_name)
  cmsv_wraw, /string, block, pointer, sn, status=status, errmsg=errmsg
  if status EQ 0 then return

  <span class="comments">;; Create structure descriptor header</span>
  buff = lonarr(3)
  buff(1) = n_tags(templ8)          <span class="comments">;; Number of tags</span>
  buff(2) = n_tags(templ8, /length) <span class="comments">;; Length of struct in bytes</span>
  cmsv_wraw, /long, block, pointer, buff, status=status, errmsg=errmsg
  if status EQ 0 then return

  nt = buff(1)
  tn = tag_names(templ8)

  status = 0

  <span class="comments">;; Retrieve type and dimensions of each structure element</span>
  forward_function tagsize
  ssz = tagsize(templ8, length=tlength, status=status)
  if status EQ 0 then begin
      errmsg = 'ERROR: CMSV_WVTYPE: cannot determine structure variable type'
      return
  endif

  <span class="comments">;; Create tag table - type descriptions of each tag</span>
  <span class="comments">;; LONG - offset</span>
  <span class="comments">;; LONG - IDL variable type</span>
  <span class="comments">;; LONG - type flags '20'x: struct, '14'x: array</span>
  offset = 0L
  tag_table = reform(lonarr(3,nt), 3, nt, /overwrite)
  for i = 0L, nt-1 do begin
      sz = ssz(*,i)
      tp = sz(sz(0)+1)
      tag_table(0,i) = offset
      tag_table(1,i) = tp
      if tp EQ 8    then tag_table(2,i) = '20'x
      if sz(0) GT 0 then tag_table(2,i) = tag_table(2,i) OR '14'x

      ilength = tlength(i) 
      if tag_table(2,i) NE 0 then ilength = floor((tlength(i)+3)/4)*4
      offset = offset + ilength
  endfor
  cmsv_wraw, /long, block, pointer, tag_table, status=status
  if status EQ 0 then return

  <span class="comments">;; Write tag names</span>
  <span class="comments">;; STRING - name of tag</span>
  cmsv_wraw, /string, block, pointer, tn, status=status, errmsg=errmsg

  <span class="comments">;; Write array descriptors, one for each array in struct</span>
  for i = 0L, nt-1 do begin
      sz = reform(ssz(*,i))
      if (tag_table(2,i) AND '24'x) NE 0 then begin
          cmsv_warrdesc, block, pointer, sz, status=status, length=tlength(i),$
            errmsg=errmsg
          if status EQ 0 then return
      endif
  endfor

  <span class="comments">;; Write struct descriptors - one for each struct with this struct</span>
  for i = 0L, nt-1 do begin
      sz = reform(ssz(*,i))

      <span class="comments">;; Recursively read struct descriptor</span>
      if (tag_table(2,i) AND '20'x) NE 0 then begin
          cmsv_wstructdesc, block, pointer, status=status, $
            template=(templ8.(i))(0), errmsg=errmsg
          if status EQ 0 then return
      endif
  endfor

  status = 1
  return
end

<a id="cmsv_wvtype:source"></a>pro cmsv_wvtype, block, pointer, data, ident, heap=heap, system=system, $
                 offset=offset, unit=unit, $
                 status=status, errmsg=errmsg

  <span class="comments">;; VARIABLE BLOCK</span>
  <span class="comments">;;   STRING - VARNAME - name of variable</span>
  <span class="comments">;;   TYPEDESC - type descriptor</span>

  <span class="comments">;; HEAP VARIABLE</span>
  <span class="comments">;;   LONG - HEAP_INDEX - heap index of data value</span>
  <span class="comments">;;   LONG - value 0x02 or 0x12 - unknown</span>
  <span class="comments">;;   TYPEDESC - type descriptor</span>
  status = 0
  if n_elements(pointer) EQ 0 then pointer = 0L
  sz = size(data)
  if sz(sz(0)+1) EQ 0 then begin
      errmsg = 'ERROR: CMSV_WVTYPE: DATA must be set'
      return
  endif
  if keyword_set(heap) then begin
      <span class="comments">;; Write heap index</span>
      if n_elements(ident) EQ 0 then ident = 0L
      cmsv_wraw, /long, block, pointer, [long(ident(0)), '02'xl], $
        status=status, errmsg=errmsg
  endif else begin
      <span class="comments">;; Write variable name</span>
      if n_elements(ident) EQ 0 then ident = '&lt;UNKNOWN>'
      cmsv_wraw, /string, block, pointer, strtrim(strupcase(ident(0)),2), $
        status=status, errmsg=errmsg
  endelse
  if status EQ 0 then return

  <span class="comments">;; Write out the type descriptors</span>

  <span class="comments">;; SCALAR_TYPE</span>
  <span class="comments">;;   LONG - variable type (IDL type code)</span>
  <span class="comments">;;   LONG - value 0</span>

  <span class="comments">;; ARRAY_TYPE</span>
  <span class="comments">;;   LONG - variable type (IDL type code)</span>
  <span class="comments">;;   LONG - ARRTYPE - values 0x14 (or 0x34 for struct)</span>
  <span class="comments">;;   ARRAY_DESC - array descriptor</span>
  <span class="comments">;;   STRUCT_DESC (if a structure) - structure descriptor</span>

  vartype = sz(sz(0)+1)
  <span class="comments">;; IDL variable type</span>

  status = 0
  if vartype EQ 0 then begin
      errmsg = 'CMSV_WVTYPE: ERROR: DATA must be defined'
      return
  endif
  
  if vartype EQ 11 then begin
      errmsg = 'CMSV_WVTYPE: ERROR: OBJREF data cannot be written'
      return
  endif

  cmsv_wraw, /long, block, pointer, vartype, status=status, errmsg=errmsg
  if status EQ 0 then return

  arrtype = 0L
  if sz(0) GT 0   then arrtype = arrtype OR '14'x
  if vartype EQ 8 then arrtype = arrtype OR '20'x
  <span class="comments">;; Array type flags</span>
  cmsv_wraw, /long, block, pointer, arrtype, status=status, errmsg=errmsg
  if status EQ 0 then return

  <span class="comments">;; System variable</span>
  if keyword_set(system) then begin
      sysflags = lonarr(2)
      sysflags(0) = vartype
      sysflags(1) = arrtype OR '02'xl

      cmsv_wraw, /long, block, pointer, sysflags, $
        status=status, errmsg=errmsg
  endif

  if arrtype EQ 0 then return  <span class="comments">;; Scalar type</span>

  <span class="comments">;; Complex array type</span>
  if vartype EQ 8 then length = n_tags(data(0), /length)
  cmsv_warrdesc, block, pointer, sz, status=status, length=length, $
    errmsg=errmsg
  if status AND vartype EQ 8 then begin
      cmsv_wstructdesc, block, pointer, status=status, template=data, $
        errmsg=errmsg, nocatch=nocatch
  endif

  return
end
</code>
    </div>
  </body>
</html>