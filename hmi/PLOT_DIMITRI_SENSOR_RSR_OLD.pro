;**************************************************************************************
;**************************************************************************************
;*
;* NAME:
;*      PLOT_DIMITRI_SENSOR_RSR       
;* 
;* PURPOSE:
;*      THIS FILE CONTAINS AND NUMBER OF ROUTINES WHICH CREATE AN INTERACTIVE OBJECT 
;*      GRAPHICS WINDOW ALLOWING USERS TO OVERLPLOT THE SPECTRAL RESPONSE FOR ANY SELECTED 
;*      DIMITRI SENSOR, ADD/REMOVE A LEGEND, AND IMPORT A USER CREATED RSR FILE (NOTE, 
;*      MUST BE A SEMI-COLON SEPERATED FILE WITH THE COLUMNS "WAVELENGTH" AND 
;*      "SPECTRAL RESPONSE", WITH DATA STARTING ON LINE 1 (STARTING FROM 0)
;* 
;* CALLING SEQUENCE:
;*      PLOT_DIMITRI_SENSOR_RSR,RANGE     
;* 
;* INPUTS:
;*      RANGE    - A 2-ELEMENT INTEGER ARRAY CONTAINING THE MIN AND MAX WAVELENGTHS OF INTEREST
;*                 E.G. [400,1000]
;*
;* KEYWORDS:
;*      VERBOSE  - PROCESSING STATUS OUTPUTS
;*
;* OUTPUTS:
;*      NONE
;*
;* COMMON BLOCKS:
;*      NONE
;*
;* MODIFICATION HISTORY:
;*      28 JAN 2011 - C KENT   - DIMITRI-2 V1.0
;*      21 FEB 2011 - C KENT   - ADDED CATCH FOR WIDGET RESIZE, UPDATE EGEND TO UPDATE IF ON
;*      21 MAR 2011 - C KENT   - MODIFIED FILE DEFINITION TO USE GET_DIMITRI_LOCATION
;*
;* VALIDATION HISTORY:
;*      23 DEC 2010 - C KENT   - 
;*
;**************************************************************************************
;**************************************************************************************

PRO RSR_OBJECT_EVENT, EVENT

  WIDGET_CONTROL, EVENT.TOP,  GET_UVALUE = RSR_INFO     , /NO_COPY
  WIDGET_CONTROL, EVENT.ID,   GET_UVALUE = ACTION
  RSR_INFO.RSR_WINDOW->DRAW, RSR_INFO.RSR_VIEW 
  WIDGET_CONTROL, EVENT.TOP, SET_UVALUE = RSR_INFO,/NO_COPY

END

;--------------------------------------------------------------------
;()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
;--------------------------------------------------------------------


PRO RSR_OBJECT_EXIT, EVENT
  
;------------------------------------
; CLEANUP POINTERS AND OBJECTS FROM MEMORY  
  
  WIDGET_CONTROL, EVENT.TOP, GET_UVALUE = RSR_INFO, /NO_COPY
  PTR_FREE,       RSR_INFO.USERXDATA
  PTR_FREE,       RSR_INFO.USERYDATA
  OBJ_DESTROY,    RSR_INFO.RSR_XTITLE
  OBJ_DESTROY,    RSR_INFO.RSR_YTITLE
  OBJ_DESTROY,    RSR_INFO.RSR_XAXIS
  OBJ_DESTROY,    RSR_INFO.RSR_YAXIS
  OBJ_DESTROY,    RSR_INFO.RSR_LEGEND
  OBJ_DESTROY,    RSR_INFO.RSR_LEGENDMODEL
  OBJ_DESTROY,    RSR_INFO.RSR_PALETTE
  OBJ_DESTROY,    RSR_INFO.RSR_VIEW
  OBJ_DESTROY,    RSR_INFO.RSR_WINDOW
  WIDGET_CONTROL, EVENT.TOP, /DESTROY

END

;--------------------------------------------------------------------
;()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
;--------------------------------------------------------------------

PRO RSR_OBJECT_OPTION,EVENT,VERBOSE=VERBOSE

  WIDGET_CONTROL, EVENT.TOP,  GET_UVALUE = RSR_INFO     , /NO_COPY
  WIDGET_CONTROL, EVENT.ID,   GET_UVALUE = ACTION

  IF N_ELEMENTS(ACTION) EQ 0 THEN GOTO,NO_RSR

;------------------------------------
; FIND OUT IF THE USER WANTS TO 
; OVERLAY A SENSOR RSR

  RES = WHERE(STRCMP(RSR_INFO.SENSOR_ID,ACTION) EQ 1)
  IF RES[0] GT -1 THEN BEGIN
    
;------------------------------------
; IF THE SENSOR ISN'T ALREADY SHOWN 
; THEN LOOP OVER EACH BAND AND PLOT THE DATA 
   
    IF RSR_INFO.SENS_ON[RES] LT 1 THEN BEGIN
      FOR RSR_SENS=0L,RSR_INFO.SENSOR_BANDS[RES[0]]-1 DO BEGIN
        RSR_INFO.RSR_OBJ[RSR_SENS,RES,0]  = OBJ_NEW('IDLGRPLOT',RSR_INFO.WAVELENGTHS,RSR_INFO.RSR_DATA[*,RSR_SENS,RES]  ,$
                                                    LINESTYLE=0, COLOR=RSR_INFO.SENSOR_COLOURS[*,RES],THICK=1       ,$
                                                    XCOORD_CONV = NORM_COORD(RSR_INFO.RSR_XRANGE)                   ,$
                                                    YCOORD_CONV = NORM_COORD(RSR_INFO.RSR_YRANGE)                    $
                                                    )
        RSR_INFO.RSR_OBJ[RSR_SENS,RES,1]  = OBJ_NEW('IDLGRMODEL')
        RSR_INFO.RSR_OBJ[RSR_SENS,RES,1]  ->ADD,  RSR_INFO.RSR_OBJ[RSR_SENS,RES,0]
        RSR_INFO.RSR_VIEW                 ->ADD,  RSR_INFO.RSR_OBJ[RSR_SENS,RES,1]
        RSR_INFO.SENS_ON[RES]             = 1
      ENDFOR
    ENDIF

;------------------------------------  
; IF LEGEND IS ON THE UPDATE IT FOR ALL DATA ON 

    RSR_INFO.RSR_LEGEND->GETPROPERTY,HIDE=TEMP
    IF TEMP EQ 0 THEN BEGIN ;IF THE LEGEND IS ON THEN SWTICH IT OFF
      RES = WHERE(RSR_INFO.SENS_ON EQ 1)
      IF RSR_INFO.USER_DATA_ON[0] EQ 1 THEN BEGIN
        TEMP = [RSR_INFO.USER_COLOUR,REFORM(RSR_INFO.SENSOR_COLOURS[*,RES],N_ELEMENTS(RSR_INFO.SENSOR_COLOURS[*,RES]))]
        TEMP = REFORM(TEMP,3,N_ELEMENTS(RES)+1)
        RSR_INFO.RSR_LEGEND->SETPROPERTY, ITEM_NAME  = [RSR_INFO.USER_DATA_NAME,RSR_INFO.SENSOR_ID[RES]],$ 
                                            ITEM_COLOR = TEMP                                             ,$
                                            THICK      = MAKE_ARRAY(N_ELEMENTS(RES)+1,VALUE=2)
      ENDIF ELSE BEGIN
        RSR_INFO.RSR_LEGEND->SETPROPERTY, ITEM_NAME  = RSR_INFO.SENSOR_ID[RES]                    ,$
                                            ITEM_COLOR = RSR_INFO.SENSOR_COLOURS[*,RES]             ,$
                                            THICK      = MAKE_ARRAY(N_ELEMENTS(RES),VALUE=2)

      ENDELSE
    ENDIF
  ENDIF 

;------------------------------------
; IF THE RESET IS SELECTED THEN DELETE 
; ALL PLOTS AND TURN THE LEGEND OFF

  IF STRCMP(ACTION,'RESET') EQ 1 THEN BEGIN 
    NON_VALUES = FLTARR(N_ELEMENTS(RSR_INFO.WAVELENGTHS))
    RSR_INFO.RSR_LEGEND->GETPROPERTY,HIDE=TEMP
    IF TEMP EQ 0 THEN RSR_INFO.RSR_LEGEND->SETPROPERTY,HIDE=1
    FOR RSR_SENS=0,N_ELEMENTS(RSR_INFO.SENSOR_ID)-1 DO BEGIN
      IF RSR_INFO.SENS_ON[RSR_SENS] EQ 1 THEN BEGIN
        FOR J=0L,RSR_INFO.SENSOR_BANDS[RSR_SENS]-1 DO RSR_INFO.RSR_OBJ[J,RSR_SENS,0]->SETPROPERTY,DATAY=NON_VALUES
        RSR_INFO.SENS_ON[RSR_SENS] = 0
      ENDIF
    ENDFOR
    
;------------------------------------    
; IF UESRR DATA IS CURRENTLY PLOTTED 
; THEN REMOVE IT FROM THE WINDOW
    
    IF RSR_INFO.USER_DATA_ON[0] EQ 1 THEN BEGIN
      RES         = WHERE(*RSR_INFO.USERXDATA GT RSR_INFO.RSR_XRANGE[0] AND *RSR_INFO.USERXDATA LT RSR_INFO.RSR_XRANGE[1])
      NON_VALUES  = FLTARR(N_ELEMENTS(RES))
      RSR_INFO.USR_DATA[0]      ->SETPROPERTY,DATAY=NON_VALUES
      RSR_INFO.USER_DATA_ON[0]  = 0
    ENDIF
  ENDIF

;------------------------------------    
; IF THE LEGEND IS TO BE SWICTHED ON/OFF

  IF STRCMP(ACTION,'LEGEND') EQ 1 THEN BEGIN ; MEANS LEGEND WHAT SELECTED
    RSR_INFO.RSR_LEGEND->GETPROPERTY,HIDE=TEMP

;------------------------------------    
; IF THE LEGEND ON SWITCH IT OFF 
; AND EXIT
    
    IF TEMP EQ 0 THEN BEGIN ;IF THE LEGEND IS ON THEN SWTICH IT OFF
      RSR_INFO.RSR_LEGEND->SETPROPERTY,HIDE=1
      GOTO,LEGEND_SWITCH
    ENDIF

;------------------------------------    
; IF THE LEGEND IS OFF THEN SWITCH IT ON 

    RES = WHERE(RSR_INFO.SENS_ON EQ 1) ;OF ANY SENSOR DATA IS PRESENT
      IF RES[0] GT -1 THEN BEGIN

;------------------------------------    
; ADD ANY USER IMPORTED AND SENSOR 
; DATA TO THE LEGEND 

        IF RSR_INFO.USER_DATA_ON[0] EQ 1 THEN BEGIN
          TEMP = [RSR_INFO.USER_COLOUR,REFORM(RSR_INFO.SENSOR_COLOURS[*,RES],N_ELEMENTS(RSR_INFO.SENSOR_COLOURS[*,RES]))]
          TEMP = REFORM(TEMP,3,N_ELEMENTS(RES)+1)
          RSR_INFO.RSR_LEGEND->SETPROPERTY, ITEM_NAME  = [RSR_INFO.USER_DATA_NAME,RSR_INFO.SENSOR_ID[RES]],$ 
                                            ITEM_COLOR = TEMP                                             ,$
                                            THICK      = MAKE_ARRAY(N_ELEMENTS(RES)+1,VALUE=2)
        ENDIF ELSE BEGIN
          RSR_INFO.RSR_LEGEND->SETPROPERTY, ITEM_NAME  = RSR_INFO.SENSOR_ID[RES]                    ,$
                                            ITEM_COLOR = RSR_INFO.SENSOR_COLOURS[*,RES]             ,$
                                            THICK      = MAKE_ARRAY(N_ELEMENTS(RES),VALUE=2)

        ENDELSE

;------------------------------------    
; TURN ON LEGEND IF ONLY THE USER 
; DATA IS CURRENTLY PLOTTED 
     
      ENDIF ELSE IF RSR_INFO.USER_DATA_ON[0] EQ 1 THEN BEGIN 
        RSR_INFO.RSR_LEGEND->SETPROPERTY,  ITEM_NAME  = [RSR_INFO.USER_DATA_NAME]           ,$
                                           ITEM_COLOR = RSR_INFO.USER_COLOUR                ,$
                                           THICK      = [2] 
      ENDIF
    RSR_INFO.RSR_LEGEND->SETPROPERTY,HIDE=0
    LEGEND_SWITCH:
  ENDIF
  
  NO_RSR:
  RSR_INFO.RSR_WINDOW->DRAW, RSR_INFO.RSR_VIEW 
  WIDGET_CONTROL, EVENT.TOP, SET_UVALUE = RSR_INFO,/NO_COPY
END

;--------------------------------------------------------------------
;()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
;--------------------------------------------------------------------

PRO RSR_OBJECT_IMPORT, EVENT

  WIDGET_CONTROL, EVENT.TOP, GET_UVALUE = RSR_INFO, /NO_COPY

;------------------------------------ 
; ONLY IMPORT IF THE USER HASN'T ALREADY
  
  IF RSR_INFO.USER_DATA_ON[0] EQ 0 THEN BEGIN
    USR_RFILE = DIALOG_PICKFILE(TITLE='PLEASE SELECT A SPECTRAL RESPONSE FILE',/MUST_EXIST)
    IF USR_RFILE NE '' THEN BEGIN

;------------------------------------ 
; FILE SELECTION - NOTE, ASSUMES 
; FILE IS IN RSR FILE TEMPLATE

      TEMP = GET_DIMITRI_RSR_TEMPLATE()
      TEMP = READ_ASCII(USR_RFILE,TEMPLATE=TEMP)

;------------------------------------ 
; FIND WHERE THE DATA IS WITHIN THE 
; USER SELECTED RANGE AND PLOT IT

      RES = WHERE(TEMP.(0) GT RSR_INFO.RSR_XRANGE[0] AND TEMP.(0) LT RSR_INFO.RSR_XRANGE[1])
      IF RES[0] GT -1 THEN BEGIN
        *RSR_INFO.USERXDATA=TEMP.(0)[RES]
        *RSR_INFO.USERYDATA=TEMP.(1)[RES]
        RSR_INFO.USR_DATA[0]      = OBJ_NEW('IDLGRPLOT',*RSR_INFO.USERXDATA,*RSR_INFO.USERYDATA     ,$
                                        LINESTYLE = 0, COLOR = RSR_INFO.USER_COLOUR, THICK = 2      ,$
                                        XCOORD_CONV = NORM_COORD(RSR_INFO.RSR_XRANGE)               ,$
                                        YCOORD_CONV = NORM_COORD(RSR_INFO.RSR_YRANGE)                $
                                        )
        RSR_INFO.USR_DATA[1]      = OBJ_NEW('IDLGRMODEL')
        RSR_INFO.USR_DATA[1]->ADD ,RSR_INFO.USR_DATA[0]
        RSR_INFO.RSR_VIEW->ADD    ,RSR_INFO.USR_DATA[1]
        RSR_INFO.USER_DATA_ON[0]  = 1

;------------------------------------ 
; STORE THE FIRST SEVERN LETTERS 
; OF THE INPUT FILE FOR THE LEGEND

        TEMP  = STRSPLIT(USR_RFILE,'\',/EXTRACT)
 
        IF N_ELEMENTS(TEMP) EQ 1 THEN TEMP = STRSPLIT(USR_RFILE,'/',/EXTRACT)
        RES   = STRMID(TEMP[N_ELEMENTS(TEMP)-1],0,7)
        RSR_INFO.USER_DATA_NAME = RES
      ENDIF
    ENDIF
  ENDIF
  RSR_INFO.RSR_WINDOW->DRAW, RSR_INFO.RSR_VIEW
  WIDGET_CONTROL, EVENT.TOP, SET_UVALUE = RSR_INFO,/NO_COPY
END

;--------------------------------------------------------------------
;()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
;--------------------------------------------------------------------

PRO RSR_OBJECT_EXPORT, EVENT
  
  WIDGET_CONTROL, EVENT.TOP,  GET_UVALUE = RSR_INFO, /NO_COPY
  WIDGET_CONTROL, EVENT.ID,   GET_UVALUE = ACTION
 
;------------------------------------ 
; STORE THE IMAGE WITHIN THE 
; CURRENT RSR_WINDOW

  RSR_INFO.RSR_WINDOW->GETPROPERTY, IMAGE_DATA = RSR_IMAGE   
  RSR_IMAGE2 = COLOR_QUAN(RSR_IMAGE,1,R,G,B)

;------------------------------------ 
; SAVE THE DATA AS REQUESTED
  
  CASE ACTION OF
    'PNG':  BEGIN
              FILENAME = DIALOG_PICKFILE(/WRITE,FILE='RELATIVE_SPECTRAL_RESPONSE.PNG',/OVERWRITE_PROMPT)
              IF FILENAME NE '' THEN WRITE_PNG,FILENAME,RSR_IMAGE2,R,G,B
            END
    'JPG':  BEGIN
              FILENAME = DIALOG_PICKFILE(/WRITE,FILE='RELATIVE_SPECTRAL_RESPONSE.JPG',/OVERWRITE_PROMPT)
              IF FILENAME NE '' THEN WRITE_JPEG,FILENAME,RSR_IMAGE,TRUE=1
            END
    'CSV':  BEGIN
              FILENAME = DIALOG_PICKFILE(/WRITE,FILE='RELATIVE_SPECTRAL_RESPONSE.CSV',/OVERWRITE_PROMPT)
              IF FILENAME NE '' THEN BEGIN

;------------------------------------ 
; OPEN THE CSV FILE
 
                OPENW,OUTF,FILENAME,/GET_LUN
                TEMP = N_ELEMENTS(RSR_INFO.WAVELENGTHS)
                PRINTF,OUTF,'SENSOR','BAND_INDEX',STRTRIM(STRING(RSR_INFO.WAVELENGTHS),2),$
                       FORMAT = STRING('('+STRTRIM(STRING(TEMP+1),2)+'(A,1H;),1(A))')

;------------------------------------ 
; IF USER DATA IMPORTED THEN RE-GRID 
; IT TO THE USER REQUESTED WAVELENGTH 
; RANGE AND PRINT TO FILE

                IF RSR_INFO.USER_DATA_ON[0] EQ 1 THEN BEGIN
                  TEMPD = MAKE_ARRAY(/FLOAT,N_ELEMENTS(RSR_INFO.WAVELENGTHS))
                  NXDATA = *RSR_INFO.USERXDATA
                  NYDATA = *RSR_INFO.USERYDATA

                  FOR I=0,N_ELEMENTS(RSR_INFO.WAVELENGTHS)-1 DO BEGIN
                    TWL = RSR_INFO.WAVELENGTHS[I]
                    TMIN = MIN(ABS(NXDATA-TWL))
                    IF TMIN LT 1.01 THEN BEGIN
                      RES2 = WHERE(ABS(NXDATA-TWL) EQ TMIN)
                      TEMPD[I] = NYDATA[RES2[0]]
                    ENDIF
                  ENDFOR
                  PRINTF,OUTF,RSR_INFO.USER_DATA_NAME,0,TEMPD,$ 
                         FORMAT = STRING('(1(A,1H;),1(I,1H;),'+STRTRIM(STRING(TEMP-1),2)+'(F15.6,1H;),1(F15.6))')
                ENDIF

;------------------------------------ 
; PRINT OUT DATA FOR ANY SENSORS 
; CURRENTLY PLOTTED
  
                RES = WHERE(RSR_INFO.SENS_ON EQ 1)
                IF RES[0] GT -1 THEN BEGIN
                  FOR II=0,N_ELEMENTS(RES)-1 DO BEGIN
                    FOR JJ = 0,RSR_INFO.SENSOR_BANDS[RES[II]]-1 DO BEGIN
                      PRINTF,OUTF,RSR_INFO.SENSOR_ID[RES[II]],STRTRIM(STRING(JJ),2),RSR_INFO.RSR_DATA[*,JJ,RES[II]],$
                             FORMAT = STRING('(1(A,1H;),1(I,1H;),'+STRTRIM(STRING(TEMP-1),2)+'(F15.6,1H;),1(F15.6))')
                    ENDFOR
                  ENDFOR
                ENDIF
                FREE_LUN,OUTF
              ENDIF 
            END 
  ENDCASE
  
  RSR_INFO.RSR_WINDOW->DRAW,RSR_INFO.RSR_VIEW
  WIDGET_CONTROL, EVENT.TOP, SET_UVALUE=RSR_INFO,/NO_COPY  

END

;--------------------------------------------------------------------
;()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
;--------------------------------------------------------------------

PRO PLOT_DIMITRI_SENSOR_RSR,RANGE,VERBOSE=VERBOSE,GROUP_LEADER=GROUP_LEADER

;------------------------------------
; FIND LOCATION OF MAIN DIMITRI FOLDER
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: RETRIEVEING DATA'
  ;CD, CURRENT = RSR_CDIR
  ;RES = STRPOS(RSR_CDIR,'DIMITRI_',/REVERSE_SEARCH)
  ;IF RES EQ -1 THEN BEGIN
  ;  PRINT, 'RSR PLOT MODULE: ERROR ENCOUNTERED WHEN DETERMING MAIN DIMITRI FOLDER'
  ;  RETURN
  ;ENDIF
  ;DL        = STRMID(RSR_CDIR,RES-1,1)
  ;MAIN_DIRC = STRMID(RSR_CDIR,0,RES+11)+DL
  ;SR_FOLDER = STRING(MAIN_DIRC+'AUX_DATA'+DL+'spectral_response'+DL)
  
  DL = GET_DIMITRI_LOCATION('DL')
  SR_FOLDER = GET_DIMITRI_LOCATION('RSR')
  SBI_FILE = GET_DIMITRI_LOCATION('SENSOR_DATA')
  
   
;------------------------------------
; DEFINE SENSOR DATA FILE
  
  ;SBI_FILE = STRING(MAIN_DIRC+'Bin'+DL+'DIMITRI_SENSOR_DATA.txt')
  RES = FILE_INFO(SBI_FILE)
  IF RES.EXISTS EQ 0 THEN BEGIN
    PRINT, 'RSR PLOT MODULE: ERROR, SENSOR INFORMATION FILE NOT FOUND'
    RETURN
  ENDIF

;------------------------------------
; GET A LIST OF ALL SENSORS

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: RETRIEVEING LIST OF SENSORS'
  TEMP        = GET_DIMITRI_SENSOR_DATA_TEMPLATE()
  RES         = READ_ASCII(SBI_FILE,TEMPLATE=TEMP)
  SENSOR_ID   = RES.SENSOR_ID
  NUM_SENSORS = N_ELEMENTS(SENSOR_ID)
  SENSOR_BANDS= RES.NUM_BANDS

;------------------------------------
; DEFINE AN ARRAY CORREPOSNDING TO 
; WL RANGE IN 0.5NM STEPS

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: DEFINING WAVELENGTH RANGE'
  WL_RANGE    = FLOAT(RANGE)
  N_WL        = (WL_RANGE[1]-WL_RANGE[0])/0.5
  WAVELENGTHS = 0.5*FINDGEN(N_WL)+WL_RANGE[0]

;------------------------------------
; CREATE ARRAYS TO HOLD ALL BAND DATA 
; FOR EACH SENSOR AND WAVELENGTH VALUES

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: DEFINING ARRAYS TO HOLD RSR DATA'
  RSR_ARRAY     = FLTARR(500,MAX(SENSOR_BANDS),NUM_SENSORS)
  RSR_WL        = RSR_ARRAY
  RSR_DATA      = FLTARR(N_WL,MAX(SENSOR_BANDS),NUM_SENSORS)
  RSR_TEMPLATE  = GET_DIMITRI_RSR_TEMPLATE()

;------------------------------------
; LOOP OVER EACH SENSOR AND READ RSR DATA
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: STARTING LOOP TO READ EACH SENSORS DATA'  
  FOR RSR_SENS = 0,NUM_SENSORS-1 DO BEGIN
    FOR RSR_BD = 0,SENSOR_BANDS[RSR_SENS]-1 DO BEGIN
      RES = FILE_SEARCH(SR_FOLDER+SENSOR_ID[RSR_SENS]+DL+'RSR_'+SENSOR_ID[RSR_SENS]+'_BAND_'+STRTRIM(STRING(RSR_BD),2)+'.txt')
      IF STRCMP(RES[0],'') NE 1 THEN BEGIN
        TEMP = READ_ASCII(RES[0],TEMPLATE = RSR_TEMPLATE)
        RSR_ARRAY[0:N_ELEMENTS(TEMP.(0))-1,RSR_BD,RSR_SENS] = TEMP.(1)
        RSR_WL[0:N_ELEMENTS(TEMP.(0))-1,RSR_BD,RSR_SENS]    = TEMP.(0)
      ENDIF
    ENDFOR
  ENDFOR

;------------------------------------
; LOOP OVER WAVELENGTH AND FIND DATA 
; FOR EACH SENSOR AND EACH BAND

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: LOOPING OVER EACH WAVELENGTH TO FIND RSR DATA'
  FOR RSR_WV=0,N_WL-1 DO BEGIN
  TWL = WAVELENGTHS[RSR_WV]
    FOR RSR_SENS=0,NUM_SENSORS-1 DO BEGIN
      FOR RSR_BD=0,SENSOR_BANDS[RSR_SENS]-1 DO BEGIN
        TMIN = MIN(ABS(RSR_WL[*,RSR_BD,RSR_SENS]-TWL))
       IF TMIN LT 1.6 THEN BEGIN
          RES = WHERE(ABS(RSR_WL[*,RSR_BD,RSR_SENS]-TWL) EQ TMIN)
          IF RES[0] GT -1 THEN BEGIN
            RSR_DATA[RSR_WV,RSR_BD,RSR_SENS] = RSR_ARRAY[RES[0],RSR_BD,RSR_SENS]
          ENDIF
        ENDIF
      ENDFOR
    ENDFOR
  ENDFOR
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: END OF DATA RETRIEVAL LOOPS'

;------------------------------------
; RELEASE MEMORY FROM ARRAYS
  
  RSR_ARRAY = 0
  RSR_WL    = 0

;------------------------------------
; CREATE AN ARRAY OF OBJECTS TO HOLD 
; THE OBJECT PLOTS AND MODELS FOR EACH 
; BAND OF EACH SENSOR

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: CREATING OBJECT ARRAY FOR ALL SENSORS'
  RSR_OBJ  = OBJARR(MAX(SENSOR_BANDS),NUM_SENSORS,2) 
  USR_DATA = OBJARR(2)
  SENS_ON  = INTARR(NUM_SENSORS)

;------------------------------------ 
; SET THE PLOT COLOURS

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: RETRIEVEING PLOT COLOURS'
  SENSOR_COLOURS  = DIMITRI_RSR_COLOURS()
  USER_COLOUR     = [!COLOR.ORANGE]

;------------------------------------ 
; SET THE PLOT PARAMETERS  
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: SETTING PLOT PARAMETERS'
  RSR_XRANGE  = [RANGE[0],RANGE[1]]
  RSR_YRANGE  = [0.0,1.]
  XMAJTICKS   = (1+(RANGE[1]-RANGE[0])*0.05)<11
  YMAJTICKS   = RSR_YRANGE[1]-RSR_YRANGE[0]

;------------------------------------ 
; CREATE THE PALETTE OBJECT
  
  COLORTABLE  = 39
  RSR_PALETTE = OBJ_NEW('IDLGRPALETTE')
  RSR_PALETTE->LOADCT, COLORTABLE

;------------------------------------  
; CREATE X AND Y TITLE OBJECTS

  IF STRCMP(STRUPCASE(!VERSION.OS_FAMILY),'WINDOWS') EQ 1 THEN   RSR_FONT  = OBJ_NEW('IDLGRFONT',SIZE=11.0) ELSE $
  RSR_FONT  = OBJ_NEW('IDLGRFONT',SIZE=9.0)
  RSR_YTITLE = OBJ_NEW('IDLGRTEXT',"Relative Spectral Response",RECOMPUTE_DIMENSION=1,FONT=RSR_FONT)
  RSR_XTITLE = OBJ_NEW('IDLGRTEXT',"Wavelength (nm)",RECOMPUTE_DIMENSION=1,FONT=RSR_FONT)

;------------------------------------ 
; CREATE THE AXIS OBJECTS

  RSR_XAXIS = OBJ_NEW('IDLGRAXIS', 0, TICKLEN=0.025, MAJOR=XMAJTICKS, TITLE=RSR_XTITLE, $
                      RANGE=RSR_XRANGE, /EXACT, XCOORD_CONV=NORM_COORD(RSR_XRANGE))
  RSR_YAXIS = OBJ_NEW('IDLGRAXIS', 1, TICKLEN=0.025, MINOR=4, TITLE=RSR_YTITLE, $
                      RANGE=RSR_YRANGE, /EXACT, YCOORD_CONV=NORM_COORD(RSR_YRANGE))
  RSR_XAXIS->GETPROPERTY,TICKTEXT=TEMP_TEXTx
  TEMP_TEXTx->SETPROPERTY,FONT=RSR_FONT
  RSR_yAXIS->GETPROPERTY,TICKTEXT=TEMP_TEXTy
  TEMP_TEXTy->SETPROPERTY,FONT=RSR_FONT
 
 
  RSR_LEGEND = OBJ_NEW('IDLGRLEGEND',/SHOW_OUTLINE,/HIDE,BORDER_GAP=0.2,FONT=RSR_FONT)
 
 ;------------------------------------  
 ; CREATE THE PLOT MODEL
 
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: CREATING THE PLOT AND LEGEND MODELS'
  RSR_MODEL = OBJ_NEW('IDLGRMODEL')
  RSR_MODEL->ADD,RSR_XAXIS
  RSR_MODEL->ADD,RSR_YAXIS
  RSR_LEGENDMODEL = OBJ_NEW('IDLGRMODEL')
  RSR_LEGENDMODEL->ADD,RSR_LEGEND

;------------------------------------ 
; CREATE THE PLOT VIEW

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: CREATING THE RSR_VIEW'
  RSR_VIEW = OBJ_NEW('IDLGRVIEW',/DOUBLE)
  RSR_VIEW->ADD,RSR_MODEL
  RSR_VIEW->ADD,RSR_LEGENDMODEL
  ;RSR_VIEW->SETPROPERTY, VIEWPLANE_RECT = [-0.1, -0.1, 1.2, 1.2]
  RSR_VIEW->SETPROPERTY, VIEWPLANE_RECT = [-0.14, -0.12, 1.3, 1.2]

;------------------------------------ 
; GET THE SCREEN DIMENSIONS

  DIMS  = GET_SCREEN_SIZE()
  XSIZE = 700
  YSIZE = 450
  XLOC  = (DIMS[0]/2)-(XSIZE/2)
  YLOC  = (DIMS[1]/2)-(YSIZE/2)

;------------------------------------ 
; DEFINE THE BASE WIDGET FOR THE PLOT

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: DEFINING THE WIDGET AND BUTTONS'
  RSR_WD_TLB  = WIDGET_BASE(TITLE='DIMITRI: RELATIVE SPECTRAL RESPONSE',MBAR=MENUBASE,TLB_SIZE_EVENTS=1,$
                            COLUMN=1, BASE_ALIGN_CENTER=1,XOFFSET=XLOC, YOFFSET=YLOC)
  RSR_WD_DRAW = WIDGET_DRAW(RSR_WD_TLB, XSIZE=XSIZE, YSIZE=YSIZE, GRAPHICS_LEVEL=2, RETAIN=2)

;------------------------------------ 
; CREATE THE FILE MENU AND BUTTONS

  RSR_WD_DLIM = WIDGET_BUTTON(MENUBASE,     VALUE='||', SENSITIVE=0)
  RSR_WD_FILE = WIDGET_BUTTON(MENUBASE,     VALUE='File'      ,/MENU)
  RSR_WD_DLIM = WIDGET_BUTTON(MENUBASE,     VALUE='||', SENSITIVE=0)
  RSR_WD_OPTS = WIDGET_BUTTON(MENUBASE,     VALUE='Options'   ,/MENU)
  RSR_WD_DLIM = WIDGET_BUTTON(MENUBASE,     VALUE='||', SENSITIVE=0)
  RSR_WD_IMPT = WIDGET_BUTTON(RSR_WD_FILE,  VALUE='Import'    ,UVALUE='IMPORT',EVENT_PRO='RSR_OBJECT_IMPORT')
  RSR_WD_EXPT = WIDGET_BUTTON(RSR_WD_FILE,  VALUE='Save as...',/MENU)
  RSR_WD_OUPT = WIDGET_BUTTON(RSR_WD_EXPT,  VALUE='JPG'       ,UVALUE='JPG'   ,EVENT_PRO='RSR_OBJECT_EXPORT')
  RSR_WD_OUPT = WIDGET_BUTTON(RSR_WD_EXPT,  VALUE='PNG'       ,UVALUE='PNG'   ,EVENT_PRO='RSR_OBJECT_EXPORT')
  RSR_WD_OUPT = WIDGET_BUTTON(RSR_WD_EXPT,  VALUE='CSV'       ,UVALUE='CSV'   ,EVENT_PRO='RSR_OBJECT_EXPORT')
  RSR_WD_EXIT = WIDGET_BUTTON(RSR_WD_FILE, /SEPARATOR         ,VALUE ='Exit'  ,EVENT_PRO='RSR_OBJECT_EXIT')

;------------------------------------ 
; CREATE THE OVERLAY MENU AND BUTTONS

  RSR_WD_OVLY = WIDGET_BUTTON(MENUBASE,     VALUE='Overlay' ,/MENU)
;  RSR_WD_OPTS = WIDGET_BUTTON(RSR_WD_OVLY,  VALUE='Options' ,/MENU)
  RSR_WD_REFS = WIDGET_BUTTON(RSR_WD_OPTS,  VALUE='Legend'  ,UVALUE='LEGEND', EVENT_PRO='RSR_OBJECT_OPTION')
  RSR_WD_REFS = WIDGET_BUTTON(RSR_WD_OPTS,  VALUE='Reset'   ,UVALUE='RESET' , EVENT_PRO='RSR_OBJECT_OPTION')

;------------------------------------ 
; LOOP OVER EACH SENSOR AND CREATE BUTTON
  
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: STARTING LOOP TO DEFINE BUTTONS FOR EACH SENSOR'
  FOR RSR_SENS=0,NUM_SENSORS-1 DO BEGIN
    RSR_WD_SENS = WIDGET_BUTTON(RSR_WD_OVLY, VALUE=SENSOR_ID[RSR_SENS],$
                                UVALUE=SENSOR_ID[RSR_SENS], EVENT_PRO='RSR_OBJECT_OPTION')
  ENDFOR

;------------------------------------  
; REALIZE THE WIDGET

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: REALISING THE WIDGET'
  WIDGET_CONTROL, RSR_WD_TLB, /REALIZE
  WIDGET_CONTROL, RSR_WD_DRAW, GET_VALUE=RSR_WINDOW
 
;------------------------------------  
; CREATE THE BLANK PLOT AND MOVE THE LEGEND
 
  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: ADDING THE BLANK PLOT AND MOVING THE LEGEND'
  RSR_WINDOW->DRAW, RSR_VIEW
  DIMS = RSR_LEGEND->COMPUTEDIMENSIONS(RSR_WINDOW) 
  RSR_LEGENDMODEL->TRANSLATE, 1.0, .8, 0 
  RSR_WINDOW->SETPROPERTY, PALETTE=RSR_PALETTE
  RSR_WINDOW->DRAW, RSR_VIEW

;------------------------------------  
; DEFINE THE INFO STRUCTURE TO CONTAIN 
; ALL DATA AND OBJECTS

  IF KEYWORD_SET(VERBOSE) THEN PRINT,'RSR PLOT MODULE: DEFINING SUPER STRUCTURE TO CONTAIN ALL DATA'
  RSR_INFO = {RSR_PALETTE:RSR_PALETTE, $
              RSR_WINDOW:RSR_WINDOW, $
              RSR_VIEW:RSR_VIEW, $
              RSR_LEGEND:RSR_LEGEND, $
              RSR_LEGENDMODEL:RSR_LEGENDMODEL,$
              RSR_XRANGE:RSR_XRANGE,$
              RSR_YRANGE:RSR_YRANGE,$
              RSR_YTITLE:RSR_YTITLE,$
              RSR_XTITLE:RSR_XTITLE,$
              RSR_XAXIS:RSR_XAXIS,$
              RSR_YAXIS:RSR_YAXIS,$
              RSR_DATA:RSR_DATA,$
              RSR_OBJ:RSR_OBJ,$
              WAVELENGTHS:WAVELENGTHS, $
              SENSOR_COLOURS:SENSOR_COLOURS,$
              SENSOR_ID:SENSOR_ID, $
              SENSOR_BANDS:SENSOR_BANDS, $
              SENS_ON:SENS_ON, $
              USR_DATA:USR_DATA,$
              USER_DATA_ON:[0],$
              USER_COLOUR:USER_COLOUR,$
              USER_DATA_NAME:'', $
              USERXDATA:PTR_NEW(0.0),$
              USERYDATA:PTR_NEW(0.0)$
             }

  IF KEYWORD_SET(GROUP_LEADER) THEN WIDGET_CONTROL,RSR_WD_TLB,SET_UVALUE=RSR_INFO,/NO_COPY,GROUP_LEADER=GROUP_LEADER $
  ELSE WIDGET_CONTROL,RSR_WD_TLB,SET_UVALUE=RSR_INFO,/NO_COPY
  XMANAGER,'RSR_OBJECT', RSR_WD_TLB, GROUP_LEADER=GROUP,/NO_BLOCK

END