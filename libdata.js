/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "Documentation for /home/marrabld/projects/DIMITRI_2.0/Source/";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("gdl/__congrid.html", "__congrid.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "__congrid.pro", "", "", " NAME:        CONGRID  PURPOSE:        Shrink or expands an array (any dimensions) to any size,        however only the first 3 dims (max) will be resized.  CATEGORY:        Array Manipulation.  CALLING SEQUENCE:        t2 = CONGRID(t,mx[,my[,mZ]])  INPUTS:        t = input array.                       in        mx, my, mz = new (output) array size.  in        t2 = resulting array.                  out  KEYWORD PARAMETERS:        /INTERPOLATE means do bilinear interpolation. Kept for         compatibility but unused: interpolation IS linear.        CUBIC=cubic: use a cubic interpolation. Currently limited by        the availability of cubic interpolation in GDL's INTERPOLATE.        /CENTERED means assume pixels centered.  This means          the pixel at (0,[0,[0]]) is clipped to 1/4 size.          Default is that pixel start (not center) is at index.'        MISSING=missing gives a value for undefined pixels.        /MINUS_ONE: option will be ignored. MISSING can be used instead.        /HELP gives this help.'   NOTE:        CONGRID performs a resampling. Does not conserve Fluxes.  OUTPUTS:        t2 = resulting array.                  out   MODIFICATION HISTORY:  	Written by: 2011-12-17 G. Duvert (Initial import)   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/__congrid.html#CONGRID", "CONGRID", 'routine in <a href="gdl/__congrid.html">__congrid.pro</a>', "__congrid.pro", "", "CONGRID", "", "CENTERINTERPCUBICMINUS_ONEMISSINGHELPtesttmxmymz", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/__strmatch.html", "__strmatch.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "__strmatch.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/__strmatch.html#strmatch", "strmatch", 'routine in <a href="gdl/__strmatch.html">__strmatch.pro</a>', "__strmatch.pro", "", "strmatch", "", "fold_casestrpattern_input", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/aatsr.html", "aatsr.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "aatsr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_DEFINE_CONSTANTS", "AATSR_DEFINE_CONSTANTS", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_DEFINE_CONSTANTS", "", "KEEP_DEFAULTS", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_ADSR_SQ__DEFINE", "AATSR_ADSR_SQ__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_ADSR_SQ__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_ADSR_LOC__DEFINE", "AATSR_ADSR_LOC__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_ADSR_LOC__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_ADSR_SCAN__DEFINE", "AATSR_ADSR_SCAN__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_ADSR_SCAN__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_ADSR_SA__DEFINE", "AATSR_ADSR_SA__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_ADSR_SA__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_ADSR_PIX__DEFINE", "AATSR_ADSR_PIX__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_ADSR_PIX__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_1P__DEFINE", "AATSR_MDSR_1P__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_1P__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_SR_SMALL__DEFINE", "AATSR_MDSR_SR_SMALL__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_SR_SMALL__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_SR_LARGE__DEFINE", "AATSR_MDSR_SR_LARGE__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_SR_LARGE__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_LR_SMALL__DEFINE", "AATSR_MDSR_LR_SMALL__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_LR_SMALL__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_LR_LARGE__DEFINE", "AATSR_MDSR_LR_LARGE__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_LR_LARGE__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_SST_SMALL__DEFINE", "AATSR_MDSR_SST_SMALL__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_SST_SMALL__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_SST_LARGE__DEFINE", "AATSR_MDSR_SST_LARGE__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_SST_LARGE__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_GADS_VCC__DEFINE", "AATSR_GADS_VCC__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_GADS_VCC__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_MUP__DEFINE", "AATSR_MDSR_MUP__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_MUP__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_DP__DEFINE", "AATSR_MDSR_DP__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_DP__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_RGB__DEFINE", "AATSR_RGB__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_RGB__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_MDSR_BRW__DEFINE", "AATSR_MDSR_BRW__DEFINE", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_MDSR_BRW__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_GET_HEADERS", "AATSR_GET_HEADERS", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_GET_HEADERS", "", "KEEP_DEFAULTSUNITMPHSPHDSD", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_READ_ADS_LOC", "AATSR_READ_ADS_LOC", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_READ_ADS_LOC", "", "NADIR_CORRECTIONFORWARD_CORRECTIONSADISTDEFAULTUNITDSDSPHALONGLENGTHACROSSWIDTH", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_READ_ADS_SA", "AATSR_READ_ADS_SA", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_READ_ADS_SA", "", "SADISTDEFAULTUNITDSDSPHALONGLENGTHACROSSWIDTH", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_READ_MDS", "AATSR_READ_MDS", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_READ_MDS", "", "INTUINTDEFAULTDSR_TIMEUNITDSDALONGLENGTHACROSSWIDTH", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_READ_MDS_DP", "AATSR_READ_MDS_DP", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_READ_MDS_DP", "", "CONFIDENCE_WORDDEFAULTDSR_TIMENADIR_VIEW_SSTDUAL_VIEW_SSTLSTNDVICTTCTHNADIRCOMBINEDUNITDSDALONGLENGTHACROSSWIDTH", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_LOC_TO_INDEX", "AATSR_LOC_TO_INDEX", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_LOC_TO_INDEX", "", "DSR_TIMETOLERANCEITERATIONSSADISTUNITDSDSPHLATITUDELONGITUDE", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/aatsr.html#AATSR_READ_TRACK", "AATSR_READ_TRACK", 'routine in <a href="aatsr/aatsr.html">aatsr.pro</a>', "aatsr.pro", "", "AATSR_READ_TRACK", "", "JDAYCOUNTUNITDSD", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/aatsr_apply_corrections.html", "aatsr_apply_corrections.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "aatsr_apply_corrections.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/aatsr_apply_corrections.html#AATSR_APPLY_CORRECTIONS", "AATSR_APPLY_CORRECTIONS", 'routine in <a href="aatsr/aatsr_apply_corrections.html">aatsr_apply_corrections.pro</a>', "aatsr_apply_corrections.pro", "", "AATSR_APPLY_CORRECTIONS", "* NAME: *      AATSR_APPLY_CORRECTIONS * * PURPOSE: *      APPLIES DRIFT CORRECTION FOR AATSR BANDS * * CALLING SEQUENCE: *      RES = AATSR_APPLY_CORRECTIONS(AATSR_IMAGE,DRIFT_TABLE=DRIFT_TABLE) * * INPUTS: *      AATSR_IMAGE - AN IMAGE STRUCTURE RETURNED FROM ENVISAT.PRO/AATSR.PRO * * KEYWORDS: *      DRIFT_TABLE - THE LOCATION FOR THE DRIFT COEFICIENTS * * OUTPUTS: *      AATSR_IMAGE - CORERECT FOR CALIBRATION DRIFT * * COMMON BLOCKS: *      None * * MODIFICATION HISTORY: *                  - RAL/CCLRC - Initial version * * VALIDATION HISTORY: * * ************************************************************************************** **************************************************************************************  ", "DRIFT_TABLEAATSR_IMAGE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/aatsr_apply_drift_correction.html", "aatsr_apply_drift_correction.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "aatsr_apply_drift_correction.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/aatsr_apply_drift_correction.html#AATSR_APPLY_DRIFT_CORRECTION", "AATSR_APPLY_DRIFT_CORRECTION", 'routine in <a href="aatsr/aatsr_apply_drift_correction.html">aatsr_apply_drift_correction.pro</a>', "aatsr_apply_drift_correction.pro", "", "AATSR_APPLY_DRIFT_CORRECTION", "FILE: AATSR_APPLY_DRIFT_CORRECTION.PRO DESCRIPTION      Uses drift correction look up table to obtain the drift measurement for a given channel and acquisition      time.      WARNING: All previous drift corrections must be removed before using this function. This is performed using      the function AATSR_REMOVE_DRIFT_CORRECTION.  ORIGINAL: 16-Jan-2008 Modification: 11-Mar-2008 - Option included to show error messages  IMPORT: ACQ_TIME - String containing acquistion time of product - format = DD-MMM-YYYY HH:MM:SS         ICH - Integer Variable Containing Channel Number to be processed                0 = 555nm                1 = 659nm                2 = 870nm                3 = 1600nm         REFLECTANCE - Variable containing reflectance reading from L1B product         DRIFT_TABLE - If specified, a structure containing the drift look up table  EXPORT: CORRECTED - Variable containing reflectance reading with drift correction Applied  If an invalid                       channel is specified or the date precedes the launch then an error is reported and -1 is                       set as the return value  ***************************************************************************************************************  ", "DRIFT_TABLESHOW_ERRORACQ_TIMEICHREFLECTANCE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/aatsr_correct_v16_nonlinearity.html", "aatsr_correct_v16_nonlinearity.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "aatsr_correct_v16_nonlinearity.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/aatsr_correct_v16_nonlinearity.html#AATSR_CORRECT_V16_NONLINEARITY", "AATSR_CORRECT_V16_NONLINEARITY", 'routine in <a href="aatsr/aatsr_correct_v16_nonlinearity.html">aatsr_correct_v16_nonlinearity.pro</a>', "aatsr_correct_v16_nonlinearity.pro", "", "AATSR_CORRECT_V16_NONLINEARITY", "FILE: AATSR_CORRECT_V16_NONLINEARITY.PRO FUNCTION:        If GC1 filename = ATS_GC1_AXVIEC20020123_073430_20020101_000000_20200101_000000 then        no nonlinearity correction is NOT applied to 1.6um channel. The function then applies the correction        to the uncorrected data.  This method is described in detail in PO-TN-RAL-AT-0539 Issue 1.1  ORIGINAL: Dave Smith RAL SSTD,  17-Jan-2008  MODIFICATION: Dave Smith RAL SSTD, 30-Jul-2008               Correction to account for scaling of 1.6um reflectance values which should be 0-1. Previous version worked on range 0-100%.  IMPORT:        GC1_FILENAME - String containing name of GC1 filename associated with L1B product - DSD31 in product        V16_UNCORRECTED - Variable containing 1.6um reflectance values from L1B product. The value(s) must be a                          in the range 0-1  EXPORT:        V16_CORRECTED - Corrected 1.6um Refelectance. If no correction is needed then the input value is returned  *************************************************************************************  ", "GC1_FILENAMEV16_UNCORRECTED", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/aatsr_quicklook.html", "aatsr_quicklook.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "aatsr_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/aatsr_quicklook.html#aatsr_quicklook", "aatsr_quicklook", 'routine in <a href="validation/aatsr_quicklook.html">aatsr_quicklook.pro</a>', "aatsr_quicklook.pro", "", "aatsr_quicklook", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/aatsr_read_drift_table.html", "aatsr_read_drift_table.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "aatsr_read_drift_table.pro", "", "", " NAME:     AATSR_READ_DRIFT_TABLE   PURPOSE:     Reads AATSR Visible Channel Drift Corrections from Look-Up-Table   CATEGORY:     Function   CALLING SEQUENCE:     NTAB = AATSR_READ_DRIFT_TABLE(DRIFT_TABLE)   INPUT:     None   KEYWORD PARAMETERS:     PATH - Text String Containing Path to cal table - default is R:\dls47\validation\Visible Calibration Drift Tables\     FILE - Text String Containing Name of cal file to be used - default is latest version   OUTPUT:     DRIFT_TABLE - Structure containing calibration drift table     NTAB - Returned value containing number of elements in table - value set to -1 if an error occurs   Modification History:    Written By: Dave Smith RAL - 16-JAN-2008    28-Jan-2011 - Allows to read new version of table with errors                  Square brackets used for array indices for compatibility with idl8    03-Mar-2011 - Header updated    05-May-2011 - Version and creation date added to output structure    23-JUN-2011 - For Loop for reading header replaced by while to search for string '#'  $Id: AATSR_READ_DRIFT_TABLE.PRO 214 2011-08-05 13:19:32Z dlsmith $  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/aatsr_read_drift_table.html#AATSR_READ_DRIFT_TABLE", "AATSR_READ_DRIFT_TABLE", 'routine in <a href="aatsr/aatsr_read_drift_table.html">aatsr_read_drift_table.pro</a>', "aatsr_read_drift_table.pro", "", "AATSR_READ_DRIFT_TABLE", "", "PATHFILEDRIFT_TABLE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/aatsr_remove_drift_correction.html", "aatsr_remove_drift_correction.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "aatsr_remove_drift_correction.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/aatsr_remove_drift_correction.html#AATSR_REMOVE_DRIFT_CORRECTION", "AATSR_REMOVE_DRIFT_CORRECTION", 'routine in <a href="aatsr/aatsr_remove_drift_correction.html">aatsr_remove_drift_correction.pro</a>', "aatsr_remove_drift_correction.pro", "", "AATSR_REMOVE_DRIFT_CORRECTION", "FILE: AATSR_REMOVE_DRIFT_CORRECTION.PRO DESCRIPTION  Identifies which calibration drift correction is used in AATSR L1B reflectance   VC1 file generation date indicates which drift correction has been applied.      Date before 29-Nov-2005 13:20:26  then no correction applied      Date between 29-Nov-2005 13:20:26 and 18-Dec-2006 20:14:15 then exponential drift correction is applied      Date after 18-Dec-2006 20:14:15 then thin film correction is applied  ORIGINAL: 16-Jan-2008  MODIFICATION:  14-July-2010 - Following a system crash on 4th April 2010 - All VC1 files generated over the period                between 04-April-2010 and 12-July-2010 inclusive did NOT contain any drift correction - hence this function was                incorrectly removing the corrections.  A fix has been implemented to perform no modification to L1b reflectances                where VC1 files generated during that period.  IMPORT: VC1_FILENAME - String containing name of GC1 filename associated with L1B product - DSD31 in product         ACQ_TIME - String containing acquistion time of product - format = DD-MMM-YYYY HH:MM:SS         ICH - Integer Variable Containing Channel Number to be processed                0 = 555nm                1 = 659nm                2 = 870nm                3 = 1600nm         REFLECTANCE - Variable containing reflectance reading from L1B product  EXPORT: UNCORRECTED - Variable containing reflectance reading with drift correction removed.  If an invalid                       channel is specified or the date precedes the launch then an error is reported and -1 is                       set as the return value  ***************************************************************************************************************  ", "VC1_FILENAMEACQ_TIMEICHREFLECTANCE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/batch_extract_vgt_vaa.html", "batch_extract_vgt_vaa.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "batch_extract_vgt_vaa.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/batch_extract_vgt_vaa.html#BATCH_EXTRACT_VGT_VAA", "BATCH_EXTRACT_VGT_VAA", 'routine in <a href="validation/batch_extract_vgt_vaa.html">batch_extract_vgt_vaa.pro</a>', "batch_extract_vgt_vaa.pro", "", "BATCH_EXTRACT_VGT_VAA", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/batch_extract_vgt_vaa.html#EXTRACT_VGT_VAA", "EXTRACT_VGT_VAA", 'routine in <a href="validation/batch_extract_vgt_vaa.html">batch_extract_vgt_vaa.pro</a>', "batch_extract_vgt_vaa.pro", "", "EXTRACT_VGT_VAA", "", "IFOLDEROFOLDERICOORDS", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/batch_extract_vgt_vaa.html#GET_VEGETATION_LAT_LON", "GET_VEGETATION_LAT_LON", 'routine in <a href="validation/batch_extract_vgt_vaa.html">batch_extract_vgt_vaa.pro</a>', "batch_extract_vgt_vaa.pro", "", "GET_VEGETATION_LAT_LON", "", "VERBOSELOG_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/batch_ingest.html", "batch_ingest.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "batch_ingest.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/batch_ingest.html#batch_ingest", "batch_ingest", 'routine in <a href="validation/batch_ingest.html">batch_ingest.pro</a>', "batch_ingest.pro", "", "batch_ingest", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/batch_ingest.html#batch_ingest_meris", "batch_ingest_meris", 'routine in <a href="validation/batch_ingest.html">batch_ingest.pro</a>', "batch_ingest.pro", "", "batch_ingest_meris", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/batch_ingest.html#batch_ingest_parasol", "batch_ingest_parasol", 'routine in <a href="validation/batch_ingest.html">batch_ingest.pro</a>', "batch_ingest.pro", "", "batch_ingest_parasol", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/batch_ingest.html#batch_ingest_modisa", "batch_ingest_modisa", 'routine in <a href="validation/batch_ingest.html">batch_ingest.pro</a>', "batch_ingest.pro", "", "batch_ingest_modisa", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/batch_ingest.html#batch_ingest_aatsr", "batch_ingest_aatsr", 'routine in <a href="validation/batch_ingest.html">batch_ingest.pro</a>', "batch_ingest.pro", "", "batch_ingest_aatsr", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/batch_ingest.html#batch_ingest_atsr2", "batch_ingest_atsr2", 'routine in <a href="validation/batch_ingest.html">batch_ingest.pro</a>', "batch_ingest.pro", "", "batch_ingest_atsr2", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/batch_ingest.html#batch_ingest_vgt", "batch_ingest_vgt", 'routine in <a href="validation/batch_ingest.html">batch_ingest.pro</a>', "batch_ingest.pro", "", "batch_ingest_vgt", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/change_man_cs.html", "change_man_cs.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "change_man_cs.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/change_man_cs.html#change_man_cs", "change_man_cs", 'routine in <a href="validation/change_man_cs.html">change_man_cs.pro</a>', "change_man_cs.pro", "", "change_man_cs", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/check_parasol_angle_computations.html", "check_parasol_angle_computations.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "check_parasol_angle_computations.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/check_parasol_angle_computations.html#check_parasol_angle_computations", "check_parasol_angle_computations", 'routine in <a href="validation/check_parasol_angle_computations.html">check_parasol_angle_computations.pro</a>', "check_parasol_angle_computations.pro", "", "check_parasol_angle_computations", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/check_roi_coverage.html", "check_roi_coverage.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "check_roi_coverage.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/check_roi_coverage.html#CHECK_ROI_COVERAGE", "CHECK_ROI_COVERAGE", 'routine in <a href="misc/check_roi_coverage.html">check_roi_coverage.pro</a>', "check_roi_coverage.pro", "", "CHECK_ROI_COVERAGE", "", "VERBOSECR_LATCR_LONCR_PIXICOORDS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("cloudscreening/cloud_module_globcarbon.html", "cloud_module_globcarbon.pro", '.pro file in <a href="cloudscreening/dir-overview.html">cloudscreening/ directory</a>', "cloud_module_globcarbon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("cloudscreening/cloud_module_globcarbon.html#CLOUD_MODULE_GLOBCARBON", "CLOUD_MODULE_GLOBCARBON", 'routine in <a href="cloudscreening/cloud_module_globcarbon.html">cloud_module_globcarbon.pro</a>', "cloud_module_globcarbon.pro", "", "CLOUD_MODULE_GLOBCARBON", "", "VERBOSESITE_TYPEGCARBON_REFTOA_GEO", "          -1", "");
  
  

libdata[libdataItem++] = new Array("cloudscreening/cloud_module_globcarbon_p.html", "cloud_module_globcarbon_p.pro", '.pro file in <a href="cloudscreening/dir-overview.html">cloudscreening/ directory</a>', "cloud_module_globcarbon_p.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("cloudscreening/cloud_module_globcarbon_p.html#CLOUD_MODULE_GLOBCARBON_P", "CLOUD_MODULE_GLOBCARBON_P", 'routine in <a href="cloudscreening/cloud_module_globcarbon_p.html">cloud_module_globcarbon_p.pro</a>', "cloud_module_globcarbon_p.pro", "", "CLOUD_MODULE_GLOBCARBON_P", "", "VERBOSESITE_TYPEGCARBON_REFTOA_GEO", "          -1", "");
  
  

libdata[libdataItem++] = new Array("cloudscreening/cloud_module_lcca.html", "cloud_module_lcca.pro", '.pro file in <a href="cloudscreening/dir-overview.html">cloudscreening/ directory</a>', "cloud_module_lcca.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("cloudscreening/cloud_module_lcca.html#CLOUD_MODULE_LCCA", "CLOUD_MODULE_LCCA", 'routine in <a href="cloudscreening/cloud_module_lcca.html">cloud_module_lcca.pro</a>', "cloud_module_lcca.pro", "", "CLOUD_MODULE_LCCA", "", "VERBOSEMODISALCCA_REF", "          -1", "");
  
  

libdata[libdataItem++] = new Array("cloudscreening/cloud_module_vgt.html", "cloud_module_vgt.pro", '.pro file in <a href="cloudscreening/dir-overview.html">cloudscreening/ directory</a>', "cloud_module_vgt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("cloudscreening/cloud_module_vgt.html#CLOUD_MODULE_VGT", "CLOUD_MODULE_VGT", 'routine in <a href="cloudscreening/cloud_module_vgt.html">cloud_module_vgt.pro</a>', "cloud_module_vgt.pro", "", "CLOUD_MODULE_VGT", "", "VERBOSESITE_TYPEVGT_REF", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmrestore.html", "cmrestore.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmrestore.pro", "", "", " NAME:    CMRESTORE   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Restore variables from an IDL SAVE file.   CALLING SEQUENCE: (various)    CMRESTORE, filename                           (implicit)    CMRESTORE, filename, var1, var2, ..., [, NAMES=names]    CMRESTORE, filename, DATA=pointers, NAMES=names, PASS_METHOD='POINTER'    CMRESTORE, filename, DATA=handles,  NAMES=names, PASS_METHOD='HANDLE'    CMRESTORE, filename, DATA=structure,             PASS_METHOD='STRUCT'   DESCRIPTION:     CMRESTORE is a replacement for the built-in IDL procedure RESTORE.    It restores variables and data from an existing IDL SAVE file,    written either by SAVE or CMSAVE.  The CMSV utility library must    be installed in your IDL path to use CMSAVE and CMRESTORE.     The primary advantage to CMRESTORE is the ability to selectively    restore only certain variables from the input file (based on    name).  CMRESTORE provides a number of ways to pass the data    between routines, typically using a pointer or structure, which    avoids the unsafe practice of restoring variables in the caller's    namespace.  However, CMRESTORE can restore variables into the    caller's namespace, but users should be aware that this capacity    is somewhat limited in IDL versions 5.2 and below.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   COMPATIBILITY:     -- File Format --     CMRESTORE should be able to read files written by SAVE and CMSAVE    from IDL version 4 to version 5.4.     CMRESTORE cannot restore objects, pointers, compressed files, or    data sets larger than 2 gigabytes.     Data types available in newer versions of IDL, such as pointers    and long integers, will not be readable in older versions of IDL    which do not have those data types.     -- Calling Interface --     For the most part, all capabilities of CMRESTORE are available to    the user.  However, it should be noted that passing variables by    positional parameter is not available under IDL 4, unless NAMES is    used to name the variables explicitly.  Also, under IDL versions    5.2 and previous, it is not possible for CMRESTORE to restore    variables into the caller's name space if they are not yet    defined.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     FILENAME - the name of the SAVE file.               Default: none, this parameter must be specified.     VAR{i} - The values to be restored.  By default the save name is             taken from the named variables that are passed.  These             default names can be overridden by using the NAMES             keyword.              If no variables are passed as positional parameters, they             can still be saved using the DATA keyword.  By invoking             CMRESTORE without positional parameters or DATA,             CMRESTORE automatically will attempt to restore the             variables to the calling routine's name space (the              implicit  technique).                 NOTE: in IDL 5.2 and below, user routines are not                allowed to *CREATE* new variables in the caller's name                space.  CMRESTORE may fail if the variable in                undefined in the caller.  Therefore you must define it                before calling CMRESTORE.  The safer practice is to                use the VAR{i} positional parameters, or the DATA                keyword.   KEYWORDS:     FILENAME - the name of the SAVE file.  The positional FILENAME               parameter takes precedence over the keyword FILENAME               parameter.                NOTE that if you pass variables as positional               parameters, then the first parameter *must* be the file               name, and the FILENAME *keyword* will be ignored.     PASS_METHOD - a scalar string, describing the method of passing                  data between the caller and CMRESTORE.  The keyword                  can take the value 'ARGUMENT', 'POINTER', 'HANDLE'                  or 'STRUCT'.  A value of 'ARGUMENT' indicates that                  data values will be passed by command line argument,                  and is the default.  Other values are described                  below.     DATA - A list of data elements to be restored from the output           file.  The data elements can be one of the following,           depending on the value of PASS_METHOD.  The means of           extracting the data, and the method of naming each           variable, are also indicated.              * PASS_METHOD='POINTER': An array of pointers to the variables                     Data: pointed-to value     Name: from NAMES keyword             * PASS_METHOD='HANDLE':  An array of handles to the variables                     Data: pointed-to value     Name: from NAMES keyword             * PASS_METHOD='STRUCT':  A structure containing data to be saved                     Data: tag value            Name: tag name            Data values are restored one by one, using the appropriate           name.  Note that any variables passed as positional           parameters will cause the DATA keyword to be ignored.            CMRESTORE will allocate any pointer or handle resources.           The calling routine is responsible for deallocating any           pointer or handle resources.     NAMES - a string array, giving the names for each variable.             If the data are passed by positional parameters, the names            are assigned according to the position of the parameter in            the procedure call.             If the data are passed by an array of pointers or handles,            then the names are assigned according to the position of            the data in the array.  In this case there is no other way            to supply the variable name.  NAMES is required.             If the data are passed in a structure, then the names are            assigned according to the position of the data in the            structure.  The values specified in the names keyword            override the tag names.     STATUS - upon return, an integer indicating the status of the             operation.  A value of 1 indicates success, while 0             indicates failure.  A failure condition does not             necessarily indicate that an individual variable could             not be restored; use the VARSTATUS keyword to detect such             situations.     VARSTATUS - upon return, an integer array indicating the status of                the restore operation for each variable.  A value of 1                at position i in the array indicates success for the                ith variable, while a value of 0 indicates failure.     ERRMSG - upon return, a string indicating the status of the             operation.  The empty string indicates success, while a             non-empty string indicates failure and describes the             error condition.     QUIET - if set, then the error message is returned to the calling            routine.  By default an error condition causes execution            to stop and the message to be printed on the console.     VERBOSE - if set, then a short message is printed for each              variable.   EXAMPLE:     CMSAVE, VAR1, VAR2, FILENAME='test.sav'    CMSAVE, VAR1, VAR2, FILENAME='test.sav', NAMES=['A','B']       Save the data in VAR1 and VAR2 to the file test.sav.  In the      first case the saved variable names will be VAR1 and VAR2.  In      the second case the saved variable names will be A and B.     POINTERS = [ptr_new(VAR1), ptr_new(VAR2)]    CMSAVE, DATA=POINTERS, NAMES=['A','B'], FILENAME='test.sav'       Save the data in VAR1 and VAR2 to the file test.sav.  The saved      variable names will be A and B.     STRUCTURE = {A: VAR1, B: VAR2}    CMSAVE, DATA=STRUCTURE, FILENAME='test.sav'       Save the data in VAR1 and VAR2 to the file test.sav.  The saved      variable names will be A and B.   SEE ALSO:     CMSAVE, SAVE, RESTORE   MODIFICATION HISTORY:    Written, 14 May 2000    Documented, 22 Sep 2000    Restore into caller's name space now permitted, 11 Jan 2001    Documented  implicit  restore a little better, w/ errors, 01 Mar 2001    Make version checks with correct precision, 19 Jul 2001, CM    Restore with no args automatically does ALL, is this right?,      CM, 20 Aug 2001    Added notification about RSI License, 13 May 2002, CM    Handle the case of CMRESTORE, FILENAME, X properly, 03 Sep 2008, CM      (thanks to Sergey Koposov for reporting)    Report CMSVLIB version number when /VERBOSE is set, 22 Nov 2009,       CM    Change to accomodate lack of GDL functionality when restoring       all variables, 22 Nov 2009, CM   $Id: cmrestore.pro,v 1.22 2009/11/22 23:31:00 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmrestore.html#arg_present", "arg_present", 'routine in <a href="gdl/cmrestore.html">cmrestore.pro</a>', "cmrestore.pro", "", "arg_present", "", "x", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmrestore.html#cmrestore", "cmrestore", 'routine in <a href="gdl/cmrestore.html">cmrestore.pro</a>', "cmrestore.pro", "", "cmrestore", "", "filenameverboseallrestored_objectsstatusvarstatusmtimesnamesdatapass_methoderrmsgquietnocatchrelaxed_structure_assignmentversionfilename0p0p1p2p3p4p5p6p7p8p9p10p11p12p13p14p15p16p17p18p19p20p21p22p23p24p25p26p27p28p29", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsave.html", "cmsave.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsave.pro", "", "", " NAME:    CMSAVE   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Save IDL variables to a file.  (IDL v5 and greater)   CALLING SEQUENCE: (various)    CMSAVE, var1, var2, ..., FILENAME=filename [, NAMES=names]    CMSAVE, DATA=pointers, NAMES=names, FILENAME=filename    CMSAVE, DATA=handles, NAMES=names,  FILENAME=filename    CMSAVE, DATA=structure,             FILENAME=filename   DESCRIPTION:     CMSAVE is a replacement for the built-in IDL procedure SAVE, with    more flexibility and increased capabilities.     CMSAVE produces output files that are compatible with the standard    save format of IDL versions 4 and 5 (and perhaps greater).    Variables may be restored by using either the built-in procedure    RESTORE, or CMRESTORE.  The CMSV utility library must be installed    in your IDL path to use CMSAVE and CMRESTORE.     The primary advantages to CMSAVE are the ability to append    additional variables to an existing SAVE file, and several    flexible ways to pass the data and variable names to be saved.    CMSAVE also attempts to run on all IDL versions.     To append variables to an existing file, simply specify the APPEND    keyword, and the filename of an existing writable SAVE file.    Variables will be appended to the end of the file.  It is possible    to append a variable with the same name as an existing variable in    a file.  Both data values are stored in the file.  However the    results upon restore are undefined.  There is also a limitation    that only one series of heap values -- pointed-to data -- may be    saved in a file.     By the normal convention of the built-in SAVE command, both the    data and variable names to be saved are passed as parameters on    the command line.  Each parameter must be a named variable; both    the name and value are saved.     This convention may be used in invoking CMSAVE as well.  However,    in addition to passing the data by positional parameter, the user    can pass the data using the DATA keyword.  If the DATA keyword is    used, then an array of pointers or handles may be passed, or a    structure of values may be passed.  (see below)  If both are    passed, then the positional parameters take precedence.     It is also possible to explicitly rename the saved variables: the    saved name does not need to be the name of the named variable.    Use the NAMES keyword to override the default name.  By default    the name is drawn from any named variables, or from the structure    tag names if the DATA keyword is used with a structure.  The NAMES    keyword takes precedence over these values.  NOTE: Values passed    by pointer or handle are not named by default, and so will not be    saved unless the NAMES keyword is used.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   COMPATIBILITY:     -- File Format --    Files written by CMSAVE should be readable with all known versions    of IDL at the time of this writing (version 4 - version 5.4).  It    is expected that this compatibility will persist.     CMSAVE cannot write objects, compressed files, or data sets larger    than 2 gigabytes.     Data types available in newer versions of IDL, such as pointers    and long integers, will not be readable in older versions of IDL    which do not have those data types.     -- Calling Interface --     For the most part, all capabilities of CMSAVE are available to the    user.  However, it should be noted that passing variables by    positional parameter is not available under IDL 4, unless NAMES is    used to name the variables explicitly.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     VAR{i} - The variables to be saved.  By default the save name is             taken from the named variables that are passed.  These             default names can be overridden by using the NAMES             keyword.              Variables can also be specified by passing an array of             handles or pointers in the DATA keyword.              If no variables are passed as positional parameters or             using DATA, then CMSAVE will assume that *all* variables             at the caller's level should be saved (this is similar             behavior to the built-in SAVE routine).  Note that system             variables cannot be saved with CMSAVE.   KEYWORDS:     ALL - for compatibility with the built-in SAVE routine.  Ignored.          Note that CMSAVE cannot save system variables.     FILENAME - the name of the output file.               Default: 'cmsave.sav'     DATA - A list of data elements to be saved to the output file.           The data elements can be one of the following.  The means           of extracting the data, and the method of naming each           variable, are also indicated.              * An array of pointers to the variables                     Data: pointed-to value     Name: from NAMES keyword             * An array of handles to the variables                     Data: pointed-to value     Name: from NAMES keyword             * A 1-element structure containing data to be saved.                     Data: tag value            Name: tag name            Data values are saved one by one, using the appropriate           name.  Note that any variables passed as positional           parameters will cause the DATA keyword to be ignored.            The calling routine is responsible for deallocating any           pointer or handle resources.     COMPATIBILITY - a string, which describes the format to be used in           the output file.  Possible values are:                    'IDL4' - format of IDL version 4;                   'IDL5' - format of IDL versions 5.0-5.3;                   'IDL6' - not supported yet, for versions 5.4-above;                   'RIVAL1' - same as 'IDL5', plus a directory entry is                             written to the file.            Note that files written in IDL5 format may still be            readable by IDL v.4.            Default: 'IDL5'     NAMES - a string array, giving the names for each variable.             If the data are passed by positional parameters, the names            are assigned according to the position of the parameter in            the procedure call.  This can be especially useful to            rename local variables, and to give names to expressions.             If the data are passed by an array of pointers or handles,            then the names are assigned according to the position of            the data in the array.  In this case there is no other way            to supply the variable name.  NAMES is required.             If the data are passed in a structure, then the names are            assigned according to the position of the data in the            structure.  The NAMES keyword values override the tag            names.     APPEND - if set, then the specified variables are appended to an             existing file.              Repeated variables will not cause an error, however they             may not be restored properly using the built-in RESTORE             procedure.  It may also not be permitted to append             variables that contain heap pointers, to a save file             which already contains heap data.     STATUS - upon return, an integer indicating the status of the             operation.  A value of 1 indicates success, while 0             indicates failure.  A failure condition does not             necessarily indicate that an individual variable could             not be written; use the VARSTATUS keyword to detect such             situations.     VARSTATUS - upon return, an integer array indicating the status of                the save operation for each variable.  A value of 1 at                position i in the array indicates success for the ith                variable, while a value of 0 indicates failure.     ERRMSG - upon return, a string indicating the status of the             operation.  The empty string indicates success, while a             non-empty string indicates failure and describes the             error condition.     QUIET - if set, then the error message is returned to the calling            routine.  By default an error condition causes execution            to stop and the message to be printed on the console.     VERBOSE - if set, then a short message is printed for each              variable.     XDR - for compatibility with the built-in SAVE routine.  Ignored.   EXAMPLE:     CMSAVE, VAR1, VAR2, FILENAME='test.sav'    CMSAVE, VAR1, VAR2, FILENAME='test.sav', NAMES=['A','B']       Save the data in VAR1 and VAR2 to the file test.sav.  In the      first case the saved variable names will be VAR1 and VAR2.  In      the second case the saved variable names will be A and B.     POINTERS = [ptr_new(VAR1), ptr_new(VAR2)]    CMSAVE, DATA=POINTERS, NAMES=['A','B'], FILENAME='test.sav'       Save the data in VAR1 and VAR2 to the file test.sav.  The saved      variable names will be A and B.  Data are passed by pointer.     STRUCTURE = {A: VAR1, B: VAR2}    CMSAVE, DATA=STRUCTURE, FILENAME='test.sav'       Save the data in VAR1 and VAR2 to the file test.sav.  The saved      variable names will be A and B.  Data are passed by structure.   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 14 May 2000    Documented, 22 Sep 2000    Made  more  compatible with SAVE; additional documentation, 11 Jan      2001, CM    Make version checks with correct precision, 19 Jul 2001, CM    Added notification about RSI License, 13 May 2002, CM   $Id: cmsave.pro,v 1.16 2009/11/22 23:26:19 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsave.html#cmsave_handle_value", "cmsave_handle_value", 'routine in <a href="gdl/cmsave.html">cmsave.pro</a>', "cmsave.pro", "", "cmsave_handle_value", "", "no_copyhandle", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsave.html#cmsave", "cmsave", 'routine in <a href="gdl/cmsave.html">cmsave.pro</a>', "cmsave.pro", "", "cmsave", "", "filenameverbosexdrcompatibleappendallstatusvarstatusmtimesnamesdatapass_methoderrmsgquietnocatchuseunitversionp0p1p2p3p4p5p6p7p8p9p10p11p12p13p14p15p16p17p18p19p20p21p22p23p24p25p26p27p28p29", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsavedir.html", "cmsavedir.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsavedir.pro", "", "", " NAME:    CMSAVEDIR   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Display a directory of the variables in an IDL SAVE file.   CALLING SEQUENCE:    CMSAVEDIR, filename [, /VERBOSE, /QUIET, ... ]   DESCRIPTION:     CMSAVEDIR will display a listing of the variables and other    objects stored in an IDL SAVE file.     For command-line users the primary function of CMSAVEDIR will be    to find out what data is stored in a file and when it was saved.    For that, they simply need to type: CMSAVEDIR, 'myfile.sav'     CMSAVEDIR also offers a number of features for programmers.    CMSAVEDIR essentially interrogates the save file and discovers the    numbers, names and types of each of the variables stored in the    file.  Programmers can use that information to decide whether or    how to open a file using the other routines in the CMSVLIB.    Various keyword parameters are used return this information, as    documented below.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   COMPATIBILITY:     -- File Format --     CMSAVEDIR cannot examine compressed save files, or files larger    than 2 gigabytes.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     FILENAME - a scalar string, the name of the file to be examined.   KEYWORDS:     VERBOSE - if set, print more detailed information about the input file.     QUIET - if set, then do not print any output.  Programmers can use            this keyword to allow CMSAVEDIR to return information            about the file silently.     STATUS - upon output, 1 for success, otherwise to indicate             failure.    ERRMSG - upon output, if a failure occurs, a message describing             the error condition.     N_VARIABLES - upon output, the number of variables in the file.    VAR_NAMES - upon output, contains a string array of the names of                the variables stored in the file.    TYPES - upon output, an 11xN_VARIABLES array containing the SIZE            information of each variable in the file.     N_PRO - upon output, the number of procedures stored in the file.    PRO_NAMES - upon output, the names of the procedures stored in the                file, as a string array.     N_FUNCTION - upon output, the number of functions stored in the                  file.    FUNC_NAMES - upon output, the names of the functions stored in the                 file, as a string array.     NAMED_STRUCTS - upon output, a string array listing any named                    structures which appear in the SAVE file.    NAMED_CLASSES - upon output, a string array listing any named                    class structures which appear in the SAVE file.     TIMESTAMP - upon output, contains the timestamp record information                in a structure.  The fields of the structure are:                     SAVE_DATE - string - date saved                     SAVE_USER - string - user who saved file                     SAVE_HOST - string - host name on which file                                          saved     VERSION - upon output, contains the version record information in              a structure.  The fields of the structure are:                     FORMAT_VERSION - integer - major format version                     ARCH    - string - saving host's !VERSION.ARCH                     OS      - string - saving host's !VERSION.OS                     RELEASE - string - saving host's !VERSION.RELEASE     NOTICE - upon output, contains any textual notice included within             the file.  The fields of the structure are:                     TEXT - string - text of the notice     FORCE - if set, will force CMSAVEDIR to open the file even if it            detects a potential incompatibility.   EXAMPLE:     IDL&gt; cmsavedir, 'int_str_intarr.sav'    ** int_str_intarr.sav    ** Sun Apr  9 20:28:25 2000 (craigm@beach.gsfc.nasa.gov)    ** IDL v5.2 (linux)      A               INT       =        0      B               STRING    = 'hello'      C               INT       = Array[3]    ** 3 variable(s), 0 heap value(s) and 0 procedure(s) in 1376 bytes   SEE ALSO:     CMRESTORE, CMSAVE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Documented, 12 Jan 2001, CM    Added USAGE message, 09 Jun 2001, CM    Fixed bug in printing common variables, 17 Mar 2002, CM    Added notification about RSI License, 13 May 2002, CM    Added NOTICE record type, 09 Jun 2003, CM   $Id: cmsavedir.pro,v 1.17 2003/06/28 22:21:07 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsavedir.html#cmsavedir", "cmsavedir", 'routine in <a href="gdl/cmsavedir.html">cmsavedir.pro</a>', "cmsavedir.pro", "", "cmsavedir", "", "typesforcestatusvar_namespro_namesfunc_namesn_variablesn_pron_functionerrmsgverboseread_heaprawtimestampversionquietnamed_structsnamed_classesnoticefilename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_open.html", "cmsv_open.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_open.pro", "", "", " NAME:    CMSV_OPEN   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Open IDL SAVE file for reading or writing   CALLING SEQUENCE:    CMSV_OPEN, UNIT, FILENAME, OFFSET, $           ACCESS=ACCESS, /FORCE, /GET_LUN, /REOPEN, $           COMPATIBILITY=COMPATIBILITY, $           STATUS=STATUS, ERRMSG=ERRMSG   DESCRIPTION:     CMSV_OPEN opens an IDL SAVE-formatted file for reading or writing.    The mode of operation is controlled by the ACCESS keyword, which    may be either 'R' for reading, 'W' for writing, or 'RW' for    read/write access.     'R': In the case of reading, the specified file is opened with    read-only access, and the first bytes are examined to verify that    it is indeed a valid IDL SAVE file.     'W': In the case of writing, the specified file is opened with    write access, and the initial file signature is written.     'RW': In the case of read-write access, the file must already    exist as a valid SAVE file.  Users are advised that every time    they switch between reading and writing operations, they must use    POINT_LUN to flush the file buffers.     The CMSVLIB routines do not support file sizes greater than 2 GB,    nor SAVE files created with the COMPRESS option.     Upon return, the file pointer is positioned at the start of the    first valid SAVE record.  The file offset is returned in OFFSET.    The user is responsible for reading or writing the remainder of    the file with other library routines.     The file unit is determined based on the following criteria.  This    behavior is similar to the OPEN family of procedures, except for    the REOPEN keyword.       * If REOPEN is set then it is assumed that UNIT is an        already-open file, and FILENAME is ignored.       * If GET_LUN is set then a file unit is allocated with GET_LUN,        and upon success this unit is returned in UNIT.       * Otherwise it is asssumed that UNIT is a valid but unopened        file unit.  Upon successful return, UNIT is opened.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   INPUTS:     UNIT - a logical unit number (a scalar).  In the case of GET_LUN,           a file unit will be allocated and returned in UNIT.  In the           default case, or REOPEN, UNIT must be a valid file unit           upon input.  For REOPEN the corresponding file must be           seekable.     FILENAME - a scalar string specifying the filename path (ignored               for REOPEN).     OFFSET - upon return, the file offset of the next available SAVE             record.   KEYWORDS:     ACCESS - a scalar string, case insensitive:                'R' - read-only access                'W' - write access (new file)                'RW' - read-write access (existing file)             Default: 'R' - read-only     GET_LUN - if set, the file unit is allocated using GET_LUN     FORCE - if set, then the file is opened despite a detected file            format inconsistency.     REOPEN - if set, then an already-opened file is manipulated.  The             valid file unit must be specified by UNIT, and FILENAME             is ignored.     COMPATIBILITY - a string, which describes the format to be used in           the output file.  Possible values are:                    'IDL4' - format of IDL version 4;                   'IDL5' - format of IDL versions 5.0-5.3;                   'IDL6' - not supported yet, for versions 5.4-above;                   'RIVAL1' - same as 'IDL5', plus a directory entry is                             written to the file.            Note that files written in IDL5 format may still be            readable by IDL v.4.            Default: 'IDL5'     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Change BLOCK to STREAM to support VMS properly, 14 Feb 2001, CM    Added notification about RSI License, 13 May 2002, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_open.pro,v 1.13 2009/11/22 22:50:49 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_open.html#cmsv_open", "cmsv_open", 'routine in <a href="gdl/cmsv_open.html">cmsv_open.pro</a>', "cmsv_open.pro", "", "cmsv_open", "", "accessforceget_lunstatuserrmsgreopencompatibilityquerycompressedunitfilenameoffset", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_ptrsum.html", "cmsv_ptrsum.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_ptrsum.pro", "", "", " NAME:    CMSV_PTRSUM   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Construct an inventory of heap data accessible to a variable   CALLING SEQUENCE:    CMSV_PTRSUM, VAR, LIST   DESCRIPTION:     This procedure constructs an inventory of heap data that is    accessible to a single variable.  It searches all array elements,    recursively through structure tags, and by dereferencing pointers.    Users can use this procedure to determine all heap variables that    need to be saved to disk.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   INPUTS:     VAR - the variable to be examined     LIST - upon output, an array of pointers, each of which points to           a heap variable accessible to VAR.  If there are no heap           data pointed to by VAR, then LIST returns a NULL value.   KEYWORDS:     NULL - if set, return the null value in LIST instead of the           pointer list.  VAR is ignored.     HAS_OBJECTS - upon return, the value is 1 if VAR contains or                  points to an object reference, and 0 if not.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Make version checks with correct precision, 19 Jul 2001, CM    Added notification about RSI License, 13 May 2002, CM   $Id: cmsv_ptrsum.pro,v 1.7 2002/05/13 06:41:10 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_ptrsum.html#cmsv_ptrsum", "cmsv_ptrsum", 'routine in <a href="gdl/cmsv_ptrsum.html">cmsv_ptrsum.pro</a>', "cmsv_ptrsum.pro", "", "cmsv_ptrsum", "", "nullhas_objectsdataresult", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_rdata.html", "cmsv_rdata.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_rdata.pro", "", "", " NAME:    CMSV_RDATA   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Read SAVE-formatted data variable record from input block or file unit   CALLING SEQUENCE:    CMSV_RDATA, BLOCK, POINTER, SIZE, DATA, UNIT=UNIT, $           TEMPLATE=TEMPLATE, /TEMPORARY, PTR_INDEX=PTR_INDEX, $           PTR_CALLBACK=PTR_CALLBACK, PTR_OFFSETS=PTR_OFFSETS, $           OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG   DESCRIPTION:     CMSV_RDATA reads the data portion of an IDL SAVE variable record.    An IDL variable is stored in two components: the type descriptor    which describes the name, type, and dimensions of the variable;    and the data record, which contains the raw data of the variable.    This procedure reads the raw data and returns it to the user.  The    initial type portion of the record must have already been read    using the CMSV_RVTYPE procedure.     CMSV_RDATA supports the following variable types:       BYTE(1),INT(2),LONG(3) - integer types      UINT(12),ULONG(13),LONG64(14),ULONG64(15) - integer types (IDL &gt;5.2 only)      FLOAT(4),DOUBLE(5),COMPLEX(6),DCOMPLEX(9) - float types      STRING(7) - string type      STRUCT(8) - structure type      POINTER(10) - pointer type - SEE BELOW      NOT SUPPORTED - OBJ(11) - object reference type - NOT SUPPORTED     Arrays and structures containing any of the supported types are    supported (including structures within structures).     For scalars and arrays of numeric or string types, the caller must    only supply the SIZE parameter, which specifies the type and    dimensions of the variable to be read.  This information can be    obtained from the CMSV_RVTYPE routine. The data is returned in the    output parameter DATA.     For structure data, in addition to specifying the SIZE array, the    user must also supply a  template  describing the structure into    which the data will be read.  This template is simply a  blank     form of the data structure, and is returned by CMSV_RVTYPE.     Thus, a simple way to read structure, numeric or string data is    the following code (with error checking removed)       CMSV_RVTYPE, block, pointer, name, size, template=template, unit=unit      CMSV_RDATA, block, pointer, size, data, template=template, unit=unit     [ This code assumes the record header has been read with    CMSV_RREC. ]   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   POINTER DATA     Pointer data stored in IDL SAVE files are particularly difficult    to manage, because the actual heap variables are stored in    separate records which *precede* the record of interest.  Thus, if    your application requires the reading of pointer data, you must    perform special processing in your own code in order to support    it.  In essence, you must maintain an inventory of heap variables    as they are encountered in the file.     If these procedures are not followed then pointer data will not be    read, and a LONG integer value appears in the pointers' places.    Under IDL 4, pointer data can never be read.     This is accomplished by placing some additional logic in your file    processing loop.  There are four separate components to this: (1)    loop initialization; (2) reading a HEAP_INDEX record; (3) parsing    a HEAP_DATA record; and (4) passing extra arguments to CMSV_RDATA.    The additional state information is maintained in two variables    named PTR_INDEX, which keeps track of the heap variable numbers,    and PTR_OFFSETS, which stores the file location of each variable.     (1) Loop initialization: is quite simple, use the following code:        ptr_index   = [0L]        ptr_offsets = [0L]        ptr_data    = [ptr_new()]     (2) Reading HEAP_INDEX, which is an array of values indicating        the heap variable numbers of each heap variables.  These        values are stored in PTR_INDEX:            CMSV_RHEAP, block, pointer, index, unit=unit           ptr_index   = [ptr_index, index]           ptr_offsets = [ptr_offsets, lonarr(n_elements(index))]           ptr_data    = [ptr_data, ptrarr(n_elements(index))]     (3) Parse the HEAP_DATA record.  Here were are interested in the        heap variable number, and the file offset.         opointer = pointer        CMSV_RVTYPE, block, pointer, vindex, /heap, unit=unit         vindex = floor(vindex(0))        wh = where(ptr_index EQ vindex)        ptr_offsets(wh(0)) = offset + opointer         Keep in mind that the file offset is OFFSET+POINTER.     (4) Pass extra parameters to CMSV_RDATA.  The user simply passes        these extra variables to the CMSV_RDATA procedure, which        automatically recognizes heap data and reads it from the        appropriate location.         CMSV_RVTYPE, block, pointer, name, size, unit=unit, template=tp        CMSV_RDATA, block, pointer, size, data, template=tp, $          unit=unit, ptr_offsets=ptr_offsets, $          ptr_index=ptr_index, ptr_data=ptr_data     If this technique is used properly, only those heap variables    which are needed are read.  Thus, there are never any lost or    dangling pointers.  Since each bit of heap data is stored in a    variable returned to the user, it is not necessary to    PTR_FREE(ptr_data); in fact, doing so would corrupt the input    data.   BLOCK, POINTER, OFFSET     This procedure can read data from a byte array, a file unit, or    both.  In fact, this procedure is designed to implement  lazy     reading from a file, which is to say, it normally reads from a    byte array of data.  However, if the requested data goes beyond    the end of the byte array, more data is read from the file on    demand.  This way the user gets the benefit of fast memory access    for small reads, but guaranteed file access for large reads.     The terminology is as follows: BLOCK is a byte array which    represents a portion of, or an entire, IDL SAVE file.  The block    may be a cached portion of an on-disk file, or an entire in-memory    SAVE file.  POINTER is the current file pointer within BLOCK    (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a    POINTER value of 0 refers to the start of the block.  OFFSET is    the file offset of the 0th byte of BLOCK; thus  POINT_LUN,    OFFSET+POINTER  should point to the same byte as BLOCK[POINTER].    The following diagram shows the meanings for BLOCK, POINTER and    OFFSET schematically:                   0 &lt;-  OFFSET  -&gt; |    FILE          |----------------|------*--------|---------&gt;     BLOCK                          |------*--------|                                   0      ^ POINTER     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     BLOCK - a byte array, a cache of the SAVE file.  Users will            usually not access this array directly.  Users are advised            to clear BLOCK after calling POINT_LUN.     POINTER - a long integer, a pointer to the next byte to be read              from BLOCK.  CMSVLIB routines will automatically              advance the pointer.     SIZE - an array of integers describing the type and dimensions of           the variable to be read, in the format returned by the           SIZE() routine.  This parameter is required.     DATA - upon output, the data variable.  If any heap data is read,           the user is ultimately responsible for freeing it.   KEYWORDS:     UNIT - a file unit.  If a library routine reads to the end of           BLOCK, or if BLOCK is undefined, then this file UNIT will           be accessed for more data.  If undefined, then BLOCK must           contain the entire file in memory.     TEMPLATE - for structure data (data type 8), a  blank  structure               containing the fields and data values to be read in.               This structure is returned by CMSV_RVTYPE.               This keyword is mandatory for structure data.     TEMPORARY - if set, BLOCK becomes undefined upon return.     PTR_OFFSETS - array of file offsets, as described above.  Default:                  pointer data is converted to an integer.     PTR_INDEX - array of heap variable indices, as described above.                Default:  pointer data is converted to an integer.     PTR_DATA - array of pointers, as described above.                Default:  pointer data is converted to an integer.     OFFSET - the file offset of byte zero of BLOCK.  Default: 0             (OFFSET is used by this routine)     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Added UNDEFINED data type for IDL &gt;5.3, CM, 21 Apr 2001    Fixed bug for pointers within structures, CM, 21 Apr 2001    Add support for IDL 4 byte-compiled strings, CM, 22 Apr 2001    Make version checks with correct precision, 19 Jul 2001, CM    Added notification about RSI License, 13 May 2002, CM    Clarify and speed some of the code, 22 Nov 2009, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_rdata.pro,v 1.11 2009/11/22 23:04:43 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rdata.html#cmsv_rconv", "cmsv_rconv", 'routine in <a href="gdl/cmsv_rdata.html">cmsv_rdata.pro</a>', "cmsv_rdata.pro", "", "cmsv_rconv", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rdata.html#cmsv_rhdata", "cmsv_rhdata", 'routine in <a href="gdl/cmsv_rdata.html">cmsv_rdata.pro</a>', "cmsv_rdata.pro", "", "cmsv_rhdata", "", "unitoffsetstatuserrmsgblockpointerdataindexoffsetspdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rdata.html#cmsv_rdata", "cmsv_rdata", 'routine in <a href="gdl/cmsv_rdata.html">cmsv_rdata.pro</a>', "cmsv_rdata.pro", "", "cmsv_rdata", "", "offsetunittemplatestatuserrmsgstarttemporarybytelongbcstring40ptr_offsetsptr_callbackptr_indexptr_datablockpointerszdata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_rraw.html", "cmsv_rraw.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_rraw.pro", "", "", " NAME:    CMSV_RRAW   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Read raw SAVE data from input block or file unit   CALLING SEQUENCE:    DATA = CMSV_RRAW( BLOCK, POINTER, NELT, UNIT=UNIT, $                      STRING=STRING, LONG=LONG, BYTE=BYTE, TYPE=TYPE, $                      OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG )   DESCRIPTION:     This function reads raw integer or string data from an IDL SAVE    file.  This is the lowest level reading function in the library,    intended for developers who are investigating new and existing    SAVE file formats.     The primary use of this function will be to read raw integer and    string data from the input.  By default, a single value is read as    a scalar; however a vector of values can be read using the NELT    parameter.  Special keywords are provided for the common data    types STRING, LONG and BYTE.  Other integer types can be read    using the TYPE keyword.  Users who want to read the data from an    IDL variable should use CMSV_RDATA, which can handle    multidimensional data, as well as floating point and structure    data.     A secondary use of this function is to buffer the data in BLOCK.    This will ensure that BLOCK contains enough data to convert NELT    integers without reading from disk.  CMSV_RRAW itself does not    convert any values so the return value should be ignored.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   BLOCK, POINTER, OFFSET     This procedure can read data from a byte array, a file unit, or    both.  In fact, this procedure is designed to implement  lazy     reading from a file, which is to say, it normally reads from a    byte array of data.  However, if the requested data goes beyond    the end of the byte array, more data is read from the file on    demand.  This way the user gets the benefit of fast memory access    for small reads, but guaranteed file access for large reads.     The terminology is as follows: BLOCK is a byte array which    represents a portion of, or an entire, IDL SAVE file.  The block    may be a cached portion of an on-disk file, or an entire in-memory    SAVE file.  POINTER is the current file pointer within BLOCK    (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a    POINTER value of 0 refers to the start of the block.  OFFSET is    the file offset of the 0th byte of BLOCK; thus  POINT_LUN,    OFFSET+POINTER  should point to the same byte as BLOCK[POINTER].    The following diagram shows the meanings for BLOCK, POINTER and    OFFSET schematically:                   0 &lt;-  OFFSET  -&gt; |    FILE          |----------------|------*--------|---------&gt;     BLOCK                          |------*--------|                                   0      ^ POINTER     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     BLOCK - a byte array, a cache of the SAVE file.  Users will            usually not access this array directly.  Users are advised            to clear BLOCK after calling POINT_LUN.     POINTER - a long integer, a pointer to the next byte to be read              from BLOCK.  CMSVLIB routines will automatically              advance the pointer.     NELT - optional parameter specifying the number of values to read.           If unspecified, then a scalar value is read and returned.           If specified, then a vector of NELT values is read and           returned.   KEYWORDS:     BUFFER - if set, CMSV_RRAW will ensure that BLOCK contains at             least NELT values without converting them.  The return             value should be ignored.  This keyword is ignored for             strings.     LONG - if set, the values are converted as LONG integers.     BYTE - if set, the values are converted as BYTEs.     STRING - if set, the values are converted as STRINGs.  Each string             may be of variable length.     TYPE - if none of the above keywords is set, then values of type           TYPE are read.  TYPE should be a string, one of 'BYTE',           'FIX', 'LONG', 'ULONG', 'LONG64', or 'ULONG64'.           If no type is specified then BYTEs are read.     UNIT - a file unit.  If a library routine reads to the end of           BLOCK, or if BLOCK is undefined, then this file UNIT will           be accessed for more data.  If undefined, then BLOCK must           contain the entire file in memory.     OFFSET - the file offset of byte zero of BLOCK.  Default: 0             (OFFSET is used by this routine)     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Added notification about RSI License, 13 May 2002, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_rraw.pro,v 1.7 2009/11/22 22:50:49 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rraw.html#cmsv_rbuf", "cmsv_rbuf", 'routine in <a href="gdl/cmsv_rraw.html">cmsv_rraw.pro</a>', "cmsv_rraw.pro", "", "cmsv_rbuf", "", "uniterrmsgstatusblockpointernbytes", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rraw.html#cmsv_rraw", "cmsv_rraw", 'routine in <a href="gdl/cmsv_rraw.html">cmsv_rraw.pro</a>', "cmsv_rraw.pro", "", "cmsv_rraw", "", "unitbufferstringbytelongtypestatuserrmsgoffsetblockpointernelt0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_rrec.html", "cmsv_rrec.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_rrec.pro", "", "", " NAME:    CMSV_RREC   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Read SAVE-formatted record header from input block or file unit   CALLING SEQUENCE:    CMSV_RREC, BLOCK, POINTER, DATA, UNIT=UNIT, $         BLOCK_TYPE=BLOCK_TYPE, BLOCK_NAME=BLOCK_NAME, NEXT_BLOCK=NEXT_BLOCK, $         INITIALIZE=INITIALIZE, FULL=FULL, PROMOTE64=PROMOTE64, $         OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG   DESCRIPTION:     This procedure reads the header of an IDL SAVE record.  The header    consists of four bytes at the beginning of each record which    indentifies the type and size of the record.  This procedure also    additionally reads many full records as noted below.     Users can determine the block type by examining the values    returned in the BLOCK_TYPE and BLOCK_NAME keywords.  The following    values are supported.  Some record types contain additional data.    CMSV_RREC reads some of these record types automatically (those    entries below marked with [this procedure]).  Other records do not    contain any additional data at all (those entries marked with an    [empty]), and thus require no further processing.      BLOCK_TYPE      BLOCK_TYPE         READ RECORD DATA WITH...         0         = 'START_MARKER'      [empty]        1         = 'COMMON_BLOCK'      [this procedure]        2         = 'VARIABLE'          CMSV_RVTYPE / CMSV_RDATA        3         = 'SYSTEM_VARIABLE'   CMSV_RVTYPE / CMSV_RDATA        6         = 'END_MARKER'        [empty]        10        = 'TIMESTAMP'         [this procedure]        12        = 'COMPILED'          no published procedure        13        = 'IDENTIFICATION'    [this procedure]        14        = 'VERSION'           [this procedure]        15        = 'HEAP_INDEX'        [this procedure]        16        = 'HEAP_DATA'         CMSV_RVTYPE        17        = 'PROMOTE64'         [empty]        19        = 'NOTICE'            [this procedure]     For records that contain variable data, the external procedures    CMSV_RVTYPE and CMSV_RDATA must be used, as noted above.    Otherwise CMSV_RREC will read and convert the appropriate data    automatically and return it in the DATA positional parameter.     The offset of the next record is returned in the NEXT_BLOCK    keyword.  For file input, the command,  POINT_LUN, UNIT,    NEXT_BLOCK  will position the file pointer to the next block.     Users should be aware that the SAVE files produced by IDL version    5.4 appear to have a different header format.  The new header size    is five bytes, and is incompatible with the older format.  In    order to activate the longer header size, the PROMOTE64 keyword    must be set.     By default the entire record is not read from the file at once.    Users that wish to operate on the entire record immediately should    set the FULL keyword.     After issuing a POINT_LUN the block cache in BLOCK must be reset    using the /INITIALIZE keyword.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   SPECIFIC RECORD TYPES     CMSV_RREC reads certain specific record types automatically and    returns the data in the positional parameter data.  Users should    pass a named variable in this parameter to retrieve the return    value.     When a record of type 'VERSION' (14) is encountered, it is read,    and returned as a structure. The returned data are of the form:           { FORMAT_VERSION: 0L, $   ; Format version number of file            ARCH: '', $             ; !VERSION.ARCH of creating host            OS: '', $               ; !VERSION.OS of creating host            RELEASE: '' }           ; !VERSION.RELEASE of creating host     When a record of type 'TIMESTAMP' (10) is encountered, it is read,    and returned as a structure. The returned data are of the form:            { SAVE_DATE: '', $  ; Date the save file was created             SAVE_USER: '', $  ; User name who  created file             SAVE_HOST: '' }   ; Host name that created file     Save files created by IDL version 4 do not contain a timestamp    record.     When a record of type 'IDENTIFICATION' (13) is encountered, it is    read, and returned as a structure.  The returned data are of the    form:            { AUTHOR: '', $  ; Author of SAVE file             TITLE:  '', $  ; Title of SAVE file             IDCODE: '' }   ; Identifying code for SAVE file     It appears that this record is not used in IDL version 5 or later.     When a record of type 'COMMON_BLOCK' (1) is encountered, it is    read and returned.  A common block descriptor consists of an array    of strings whose first element is the common block name, and whose    remaining elements are the common block variable names.  No    variable data are stored with the common block definition.     When a record of type 'HEAP_INDEX' (15) is encountered, it is read    and returned in DATA.  The heap index specifies a list of which    heap variables are stored in the current save file.  These indices    are simply numbers which identify each heap variable (i.e.,     &lt;PtrHeapVar2&gt;  would have an index of 2).  Users should note that    the heap index will not necessarily be sequentially increasing,    and may have gaps.     When a record of type 'NOTICE' (19) is encountered, it is read and    returned in DATA.  It is a structure with one field: {TEXT: ''},    where TEXT is the text content of the notice.     Users should consult CMSV_RDATA for instructions on how to read    heap data.   BLOCK, POINTER, OFFSET     This procedure can read data from a byte array, a file unit, or    both.  In fact, this procedure is designed to implement  lazy     reading from a file, which is to say, it normally reads from a    byte array of data.  However, if the requested data goes beyond    the end of the byte array, more data is read from the file on    demand.  This way the user gets the benefit of fast memory access    for small reads, but guaranteed file access for large reads.     The terminology is as follows: BLOCK is a byte array which    represents a portion of, or an entire, IDL SAVE file.  The block    may be a cached portion of an on-disk file, or an entire in-memory    SAVE file.  POINTER is the current file pointer within BLOCK    (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a    POINTER value of 0 refers to the start of the block.  OFFSET is    the file offset of the 0th byte of BLOCK; thus  POINT_LUN,    OFFSET+POINTER  should point to the same byte as BLOCK[POINTER].    The following diagram shows the meanings for BLOCK, POINTER and    OFFSET schematically:                   0 &lt;-  OFFSET  -&gt; |    FILE          |----------------|------*--------|---------&gt;     BLOCK                          |------*--------|                                   0      ^ POINTER     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     BLOCK - a byte array, a cache of the SAVE file.  Users will            usually not access this array directly.  Users are advised            to clear BLOCK after calling POINT_LUN.     POINTER - a long integer, a pointer to the next byte to be read              from BLOCK.  CMSVLIB routines will automatically              advance the pointer.   KEYWORDS:     UNIT - a file unit.  If a library routine reads to the end of           BLOCK, or if BLOCK is undefined, then this file UNIT will           be accessed for more data.  If undefined, then BLOCK must           contain the entire file in memory.     OFFSET - the file offset of byte zero of BLOCK.  Default: 0             (OFFSET is used by this routine)     BLOCK_TYPE - upon return, the numeric record type, as described                 above.     BLOCK_NAME - upon return, a scalar string specifying the record                 type, as specified above.     NEXT_BLOCK - upon return, file offset of the next record in the                 file.     INITIALIZE - if set, then BLOCK and POINTER are initialized to a                 pristine state.  All data in these two variables is                 lost before reading the next record.     FULL - if set, then the entire record will be read into BLOCK.     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Fix typo for RHEAP call, CM, 21 Apr 2001    Added notification about RSI License, 13 May 2002, CM    Added NOTICE record type, 09 Jun 2003, CM    Read record header as ULONG, 26 Sep 2009, CM    Bug fix to previous change, 22 Nov 2009, CM    Support for newer IDL 64-bit files which use a      standard  record header size and a previously unused     field, 11 Jan 2010, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_rrec.pro,v 1.15 2010/01/11 08:58:13 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rrec.html#cmsv_rcomm", "cmsv_rcomm", 'routine in <a href="gdl/cmsv_rrec.html">cmsv_rrec.pro</a>', "cmsv_rrec.pro", "", "cmsv_rcomm", "", "unitoffsetstatuserrmsgblockpointernames", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rrec.html#cmsv_rheap", "cmsv_rheap", 'routine in <a href="gdl/cmsv_rrec.html">cmsv_rrec.pro</a>', "cmsv_rrec.pro", "", "cmsv_rheap", "", "unitoffsetstatuserrmsgblockpointerindex", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rrec.html#cmsv_rstamp", "cmsv_rstamp", 'routine in <a href="gdl/cmsv_rrec.html">cmsv_rrec.pro</a>', "cmsv_rrec.pro", "", "cmsv_rstamp", "", "unitoffsetstatuserrmsgblockpointertstamp", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rrec.html#cmsv_rversion", "cmsv_rversion", 'routine in <a href="gdl/cmsv_rrec.html">cmsv_rrec.pro</a>', "cmsv_rrec.pro", "", "cmsv_rversion", "", "unitoffsetstatuserrmsgblockpointervers", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rrec.html#cmsv_rident", "cmsv_rident", 'routine in <a href="gdl/cmsv_rrec.html">cmsv_rrec.pro</a>', "cmsv_rrec.pro", "", "cmsv_rident", "", "unitoffsetstatuserrmsgblockpointerident", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rrec.html#cmsv_rnotice", "cmsv_rnotice", 'routine in <a href="gdl/cmsv_rrec.html">cmsv_rrec.pro</a>', "cmsv_rrec.pro", "", "cmsv_rnotice", "", "unitoffsetstatuserrmsgblockpointernotice", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rrec.html#cmsv_rrec", "cmsv_rrec", 'routine in <a href="gdl/cmsv_rrec.html">cmsv_rrec.pro</a>', "cmsv_rrec.pro", "", "cmsv_rrec", "", "unitoffsetstatuserrmsgcompressedblock_typeblock_namenext_blockinitializefullpromote64qblocknamesblockpointerdata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_rvtype.html", "cmsv_rvtype.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_rvtype.pro", "", "", " NAME:    CMSV_RVTYPE   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Read variable type information from input block or file unit   CALLING SEQUENCE:    CMSV_RVTYPE, BLOCK, POINTER, NAME, SIZE, UNIT=UNIT, $           TEMPLATE=TEMPLATE, SUFFIX=SUFFIX, $           /NO_CREATE, /NO_TYPE, /HEAP, /SYSTEM, $           STRUCTURE_NAME=STNAME, $           NAMED_STRUCTS=STRUCTS, NAMED_CLASSES=CLASSES, $           OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG   DESCRIPTION:     CMSV_RVTYPE reads the type portion of an IDL SAVE variable record.    An IDL variable is stored in two components: the type descriptor    which describes the name, type, and dimensions of the variable;    and the data record, which contains the raw data of the variable.    This procedure reads the type descriptor returns it to the user.    This procedure can also determine the name of a variable; the heap    index number of a heap variable; and other important information.    Once the type of the data has been determined, the data portion    can be read using the CMSV_RDATA procedure.     CMSV_RVTYPE should recognize and correctly return type descriptor    information about all known IDL data types, as of this writing.    It should be noted that CMSV_RDATA will not necessarily be capable    of reading all of these data types, but the description of the    data should still be readable.  Users can then use this    information to print a summary of the file contents for example.     The type information are normally returned in the SIZE parameter,    which gives the IDL variable type, and the dimensions of the    variable just as the IDL built-in function SIZE() would do.    However, in the case of structures, there is much more information    to convey.  To assist the user a blank template structure is    returned in the keyword parameter TEMPLATE, which they can then    pass on to CMSV_RDATA.     Users should be aware of structure and class name clashes.  The    problem arises because CMSV_RVTYPE must actually instantiate any    named structures or classes in the file.  If these named    structures clash with the definitions of the structures on the    user's local computer, then an error will result.  To prevent    this, the user can use the SUFFIX keyword.  If the SUFFIX keyword    contains a string, then this string is appended to any structure    names discovered in the save file, before instantiation.  Thus, as    long as the suffix is a unique string, there will be no clashes    with local structure definitions.  Users are advised to pick a    different suffix for *each* save file that they open.     CMSV_RVTYPE also provides some diagnostic information about the    variable.  Users can pass the NAMED_STRUCTS and NAMED_CLASSES    keywords in order to discover what named structures, classes and    superclasses are stored in the save file (this is especially    useful with the NO_TYPE keyword).  Since the contents of    NAMED_STRUCTS and NAMED_CLASSES are not destroyed, but appended to    instead, users are advised to clear these variables when opening    each new file.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   BLOCK, POINTER, OFFSET     This procedure can read data from a byte array, a file unit, or    both.  In fact, this procedure is designed to implement  lazy     reading from a file, which is to say, it normally reads from a    byte array of data.  However, if the requested data goes beyond    the end of the byte array, more data is read from the file on    demand.  This way the user gets the benefit of fast memory access    for small reads, but guaranteed file access for large reads.     The terminology is as follows: BLOCK is a byte array which    represents a portion of, or an entire, IDL SAVE file.  The block    may be a cached portion of an on-disk file, or an entire in-memory    SAVE file.  POINTER is the current file pointer within BLOCK    (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a    POINTER value of 0 refers to the start of the block.  OFFSET is    the file offset of the 0th byte of BLOCK; thus  POINT_LUN,    OFFSET+POINTER  should point to the same byte as BLOCK[POINTER].    The following diagram shows the meanings for BLOCK, POINTER and    OFFSET schematically:                   0 &lt;-  OFFSET  -&gt; |    FILE          |----------------|------*--------|---------&gt;     BLOCK                          |------*--------|                                   0      ^ POINTER     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     BLOCK - a byte array, a cache of the SAVE file.  Users will            usually not access this array directly.  Users are advised            to clear BLOCK after calling POINT_LUN.     POINTER - a long integer, a pointer to the next byte to be read              from BLOCK.  CMSVLIB routines will automatically              advance the pointer.     NAME - upon return, the identifier of the variable.  For named           variables, NAME is a string.  For heap variables, NAME is           an integer heap index.     SIZE - upon return, an integers array describing the variable type           and size, in the same format as returned by the built-in           function SIZE.   KEYWORDS:     TEMPLATE - upon return, if the variable is a structure, TEMPLATE               will contain a single blank template structure, which               can be used in calls to CMSV_RDATA.     NO_CREATE - if set, then do not create any template structures                (saves execution time and structure name clashes).     NO_TYPE - if set, do not read type information.  CMSV_RVTYPE              returns only the variable NAME or heap index.     HEAP - if set, then read the variable type assuming it is a heap           variable (a HEAP_DATA record).     SYSTEM - if set, then read the variable type assuming it is a             system variable (a SYSTEM_VARIABLE record).     SUFFIX - a scalar string, the suffix to be appended to any             structure names to force them to be unique.     STRUCTURE_NAME - upon return, if the variable is a named                     structure, STRUCTURE_NAME will contain the name                     of the structure as a string.     NAMED_CLASSES /    NAMED_STRUCTS - upon input, this keyword should contain an                    undefined or a string array value.                     If the variable contains any named structure/class                    definitions, CMSV_RVTYPE will append those names                    upon return, including any enclosed structures or                    superclasses.     UNIT - a file unit.  If a library routine reads to the end of           BLOCK, or if BLOCK is undefined, then this file UNIT will           be accessed for more data.  If undefined, then BLOCK must           contain the entire file in memory.     OFFSET - the file offset of byte zero of BLOCK.  Default: 0             (OFFSET is not used by this routine at this time)     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Added notification about RSI License, 13 May 2002, CM    Avoid using reserved word INHERITS, 07 Mar 2006, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_rvtype.pro,v 1.13 2009/11/22 22:50:49 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rvtype.html#cmsv_rarrdesc", "cmsv_rarrdesc", 'routine in <a href="gdl/cmsv_rvtype.html">cmsv_rvtype.pro</a>', "cmsv_rvtype.pro", "", "cmsv_rarrdesc", "", "statusuniterrmsgblockpointersz", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rvtype.html#cmsv_rstructdesc", "cmsv_rstructdesc", 'routine in <a href="gdl/cmsv_rvtype.html">cmsv_rvtype.pro</a>', "cmsv_rvtype.pro", "", "cmsv_rstructdesc", "", "unitstatuserrmsgsuffixstructure_nameno_createnamed_structsnamed_classesblockpointertemplate", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_rvtype.html#cmsv_rvtype", "cmsv_rvtype", 'routine in <a href="gdl/cmsv_rvtype.html">cmsv_rvtype.pro</a>', "cmsv_rvtype.pro", "", "cmsv_rvtype", "", "unitoffsetstatuserrmsgtemplateno_createno_typeheapsystemsuffixstructure_namenamed_structsnamed_classesblockpointerresultsz", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_test.html", "cmsv_test.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_test.pro", "", "", " NAME:    CMSV_TEST   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Test the CMSVLIB library   CALLING SEQUENCE:    CMSV_TEST, FILENAME, USER_VALUE=UVALUE   DESCRIPTION:     CMSV_TEST performs a standard test of the CMSVLIB library.  It    reads and writes a save file using several different methods in an    attempt to test the different ways that the library can be used.    The test procedure can be used to verify that the library is    functioning properly.     By default, this procedure provides standard values to be written,    but the user can provide one of them with the USER_VALUE keyword.    If the user's data contains pointers, they must expect tests    listed under CMSVREAD and CMSVWRITE to fail.     By default the file is written in the current directory, but this    can be changed with the FILENAME parameter.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   INPUTS:     FILENAME - a scalar string, the output path.               Default: 'CMSVTEST.SAV' in current directory   KEYWORDS:     USER_VALUE - any IDL variable to be saved, in place of variable                  C  in the test.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Resolve all routines at start, and add VMS keyword, 14 Feb 2001, CM    Make version checks with correct precision, 19 Jul 2001, CM    Added notification about RSI License, 13 May 2002, CM    Changed test so that 'DEADBEEF'XL is not used, which apparently      causes problems on 'FL', 01 Aug 2009    Add test for strings &gt;127 characters (v1.7), 2012-04-05, CM   $Id: cmsv_test.pro,v 1.11 2012/04/05 20:43:09 cmarkwar Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_test.html#cmsv_test_set", "cmsv_test_set", 'routine in <a href="gdl/cmsv_test.html">cmsv_test.pro</a>', "cmsv_test.pro", "", "cmsv_test_set", "", "setresetprintabcde", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_test.html#cmsv_test_undefine", "cmsv_test_undefine", 'routine in <a href="gdl/cmsv_test.html">cmsv_test.pro</a>', "cmsv_test.pro", "", "cmsv_test_undefine", "", "x", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_test.html#cmsv_test_unset", "cmsv_test_unset", 'routine in <a href="gdl/cmsv_test.html">cmsv_test.pro</a>', "cmsv_test.pro", "", "cmsv_test_unset", "", "abcde", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_test.html#cmsv_test_vcomp", "cmsv_test_vcomp", 'routine in <a href="gdl/cmsv_test.html">cmsv_test.pro</a>', "cmsv_test.pro", "", "cmsv_test_vcomp", "", "namex0xresultfailed", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_test.html#cmsv_test_comp", "cmsv_test_comp", 'routine in <a href="gdl/cmsv_test.html">cmsv_test.pro</a>', "cmsv_test.pro", "", "cmsv_test_comp", "", "abcderesultfailed", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_test.html#cmsv_test", "cmsv_test", 'routine in <a href="gdl/cmsv_test.html">cmsv_test.pro</a>', "cmsv_test.pro", "", "cmsv_test", "", "user_valuefilename0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_wdata.html", "cmsv_wdata.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_wdata.pro", "", "", " NAME:    CMSV_WDATA   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Write SAVE-formatted data variable record to output block or file   CALLING SEQUENCE:    CMSV_WDATA, BLOCK, POINTER, DATA, UNIT=UNIT, TEMPORARY=TEMPORARY, $                PTR_INDEX=PTR_INDEX, PTR_DATA=PTR_DATA, $                OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG   DESCRIPTION:     CMSV_WDATA writes the data portion of an IDL SAVE variable record.    An IDL variable is stored in two components: the type descriptor    which describes the name, type, and dimensions of the variable;    and the data record, which contains the raw data of the variable.    This procedure writes the raw data to the output.  The initial    type descriptor portion of the record must have already been    writtenusing the CMSV_WVTYPE procedure.     Under normal circumstances a user will write variable or heap data    using the CMSV_WREC procedure.     CMSV_WDATA supports the following variable types:       BYTE(1),INT(2),LONG(3) - integer types      UINT(12),ULONG(13),LONG64(14),ULONG64(15) - integer types (IDL &gt;5.2 only)      FLOAT(4),DOUBLE(5),COMPLEX(6),DCOMPLEX(9) - float types      STRING(7) - string type      STRUCT(8) - structure type      POINTER(10) - pointer type - SEE BELOW      NOT SUPPORTED - OBJ(11) - object reference type - NOT SUPPORTED     Arrays and structures containing any of the supported types are    supported (including structures within structures).     The caller must specify in the DATA parameter, the data to be    written to output.  The variable passed as DATA must have the same    type and dimensions as passed to CMSV_WVTYPE.     Unlike most of the other output routines, this procedure is able    to send its output to a file rather than to the BLOCK buffer.  If    the UNIT keyword is specified then output is sent to that file    UNIT, after any pending BLOCK data is first sent.  Users should    note that after such operations, the BLOCK POINTER and OFFSET    parameters may be modified (ie reset to new values).     See CMSV_WREC for instructions on how to write heap data.     [ This code assumes the record header and type descriptor have    been written with CMSV_WREC and CMSV_WVTYPE. ]   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   BLOCK, POINTER, OFFSET     This procedure writes data to a byte array or a file.  If the UNIT    keyword is specified then file is sent to the specified unit    number rather than to the buffer BLOCK.  However, the intent is    for users to accumulate a significant amount of data in a BLOCK    and then write it out with a single call to WRITEU.  Users should    be aware that the block can be larger than the buffered data, so    they should use something like the following:            WRITEU, UNIT, BLOCK(0:POINTER-1)     When library routines do indeed write buffered BLOCK data to disk,    they will appropriately reset the BLOCK and POINTER.  Namely,    BLOCK will be reset to empty, and POINTER will be reset to zero.    OFFSET will be advanced the according number of bytes.     The terminology is as follows: BLOCK is a byte array which    represents a portion of, or an entire, IDL SAVE file.  The block    may be a cached portion of an on-disk file, or an entire in-memory    SAVE file.  POINTER is the current file pointer within BLOCK    (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a    POINTER value of 0 refers to the start of the block.  OFFSET is    the file offset of the 0th byte of BLOCK; thus  POINT_LUN,    OFFSET+POINTER  should point to the same byte as BLOCK[POINTER].    The following diagram shows the meanings for BLOCK, POINTER and    OFFSET schematically:                   0 &lt;-  OFFSET  -&gt; |    FILE          |----------------|------*--------|---------&gt;     BLOCK                          |------*--------|                                   0      ^ POINTER     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     BLOCK - a byte array, a cache of the SAVE file.  Users will            usually not access this array directly.  Users are advised            to clear BLOCK after calling POINT_LUN or writing the            block to disk.     POINTER - a long integer, a pointer to the next byte to be read              from BLOCK.  CMSVLIB routines will automatically              advance the pointer.     DATA - the data to be written, of any save-able data type.   KEYWORDS:     TEMPORARY - if set, then the input DATA are discarded after being                written, as a memory economy provision.     PTR_INDEX - a heap index array for the data being written, if any                heap data records have been written.                Default: no pointers are written     PTR_DATA - an array of pointers, pointing to the heap values being               written.               Default: no pointers are written     UNIT - a file unit.  If specified then data are directed to the           file unit rather than to the buffer BLOCK.     OFFSET - the file offset of byte zero of BLOCK.             Upon output, if the file pointer is advanced, OFFSET will             also be changed.             (OFFSET is not currently used by this routine)             Default: 0     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Added notification about RSI License, 13 May 2002, CM    Added support for byte scalars and arrays (!), 27 Mar 2006, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_wdata.pro,v 1.10 2009/11/22 22:50:49 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wdata.html#cmsv_wconv", "cmsv_wconv", 'routine in <a href="gdl/cmsv_wdata.html">cmsv_wdata.pro</a>', "cmsv_wdata.pro", "", "cmsv_wconv", "", "data", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wdata.html#cmsv_wdata", "cmsv_wdata", 'routine in <a href="gdl/cmsv_wdata.html">cmsv_wdata.pro</a>', "cmsv_wdata.pro", "", "cmsv_wdata", "", "unittemporaryptr_indexptr_datastartstatuserrmsgblockpointervalue", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_wraw.html", "cmsv_wraw.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_wraw.pro", "", "", " NAME:    CMSV_WRAW   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Write raw SAVE data to output block   CALLING SEQUENCE:    CMSV_WRAW, BLOCK, POINTER, DATA, UNIT=UNIT, $               STRING=STRING, LONG=LONG, BYTE=BYTE, TYPE=TYPE, $               OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG   DESCRIPTION:     This procedure writes raw integer or string data to an IDL SAVE    block in memory.  This is the lowest level writing function in the    library, intended for developers who are investigating new and    existing SAVE file formats.     The data to be written is specified by the DATA parameter.  The    data must be of type BYTE, LONG or STRING, and the type is    determined automatically from the data itself.  [ The mnemonic    STRING LONG and BYTE keywords are accepted for programming clarity    but ignored. ]     This procedure accepts but currently ignores the UNIT keyword.  It    is the caller's responsibility to write the BLOCK data to disk    when appropriate.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   BLOCK, POINTER, OFFSET     This procedure writes data to a byte array only.  The intent is    for users to accumulate a significant amount of data in a BLOCK    and then write it out with a single call to WRITEU.  Users should    be aware that the block can be larger than the buffered data, so    they should use something like the following:            WRITEU, UNIT, BLOCK(0:POINTER-1)     When library routines do indeed write buffered BLOCK data to disk,    they will appropriately reset the BLOCK and POINTER.  Namely,    BLOCK will be reset to empty, and POINTER will be reset to zero.    OFFSET will be advanced the according number of bytes.     The terminology is as follows: BLOCK is a byte array which    represents a portion of, or an entire, IDL SAVE file.  The block    may be a cached portion of an on-disk file, or an entire in-memory    SAVE file.  POINTER is the current file pointer within BLOCK    (i.e., the next byte to be written is BLOCK[POINTER]).  Hence, a    POINTER value of 0 refers to the start of the block.  OFFSET is    the file offset of the 0th byte of BLOCK; thus  POINT_LUN,    OFFSET+POINTER  should point to the same byte as BLOCK[POINTER].    The following diagram shows the meanings for BLOCK, POINTER and    OFFSET schematically:                   0 &lt;-  OFFSET  -&gt; |    FILE          |----------------|------*--------|---------&gt;     BLOCK                          |------*--------|                                   0      ^ POINTER     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     BLOCK - a byte array, a cache of the SAVE file.  Users will            usually not access this array directly.  Users are advised            to clear BLOCK after calling POINT_LUN or writing the            block to disk.     POINTER - a long integer, a pointer to the next byte to be written              from BLOCK.  CMSVLIB routines will automatically advance              the pointer.     DATA - the data to be written.  Must of type STRING, BYTE or LONG.   KEYWORDS:     LONG - ignored (to be used for clarity)    BYTE - ignored (to be used for clarity)    STRING - ignored (to be used for clarity)     UNIT - a file unit.  Currently ignored.     OFFSET - the file offset of byte zero of BLOCK.             Upon output, if the file pointer is advanced, OFFSET will             also be changed.             (OFFSET is not currently used by this routine)             Default: 0     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Added notification about RSI License, 13 May 2002, CM    Fixed bug in writing of empty strings, 28 Mar 2006, CM    Fixed bug when writing strings &gt;128 characters, 2012-04-05, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_wraw.pro,v 1.9 2012/04/05 20:43:09 cmarkwar Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wraw.html#cmsv_enlarge", "cmsv_enlarge", 'routine in <a href="gdl/cmsv_wraw.html">cmsv_wraw.pro</a>', "cmsv_wraw.pro", "", "cmsv_enlarge", "", "statuserrmsgblockpointernbytes", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wraw.html#cmsv_wraw", "cmsv_wraw", 'routine in <a href="gdl/cmsv_wraw.html">cmsv_wraw.pro</a>', "cmsv_wraw.pro", "", "cmsv_wraw", "", "unitreplenbytelongstringstatuserrmsgblockpointervalue0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_wrec.html", "cmsv_wrec.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_wrec.pro", "", "", " NAME:    CMSV_WREC   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Write SAVE-formatted record header to output block or file   CALLING SEQUENCE:    CMSV_WDATA, BLOCK, POINTER, DATA, IDENT, UNIT=UNIT, $                INITIALIZE=INITIALIZE, NO_DATA=NO_DATA, $                NO_TYPE=NO_TYPE, COMPATIBILITY=COMPAT, $                BLOCK_TYPE=BLOCK_TYPE, BLOCK_NAME=BLOCK_NAME,                NEXT_BLOCK=NEXT_BLOCK, $                [ ... EXTRA KEYWORDS ... ]                OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG   DESCRIPTION:     This procedure writes most types of IDL SAVE record, including the    header and contents.  The header consists of four bytes at the    beginning of each record which indentifies the type and size of    the record.  This procedure also writes the contents of certain    records, as noted below.     Users can specify the block type by passing the BLOCK_TYPE or    BLOCK_NAME keywords.  The values listed in the following table are    supported.  CMSV_WREC writes the contents of essentially all    record types as well.  Some records do not contain any contents at    all (those entries marked with an [empty]) and thus require no    further processing.      BLOCK_TYPE      BLOCK_TYPE         WRITE RECORD CONTENTS WITH...         0         = 'START_MARKER'      [empty]        1         = 'COMMON_BLOCK'      [this procedure]        2         = 'VARIABLE'          [this procedure]        3         = 'SYSTEM_VARIABLE'   [this procedure]        6         = 'END_MARKER'        [empty]        10        = 'TIMESTAMP'         [this procedure]        12        = 'COMPILED'          no published procedure        13        = 'IDENTIFICATION'    [this procedure]        14        = 'VERSION'           [this procedure]        15        = 'HEAP_INDEX'        [this procedure]        16        = 'HEAP_DATA'         [this procedure]        17        = 'PROMOTE64'         [empty]        19        = 'NOTICE'            [this procedure]     For records that contain variable data, the external procedures    CMSV_WVTYPE and/or CMSV_WDATA may be used, however it is not    recommended, since the record header must finally be re-written by    the user.  Users can write the entire record with this procedure.     After issuing a POINT_LUN, or after writing the BLOCK to disk, the    block cache in BLOCK must be reset using the /INITIALIZE keyword.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   SPECIFIC RECORD TYPES     CMSV_WREC reads certain specific record types automatically based    on data passed in the DATA parameter.     Records of type 'VARIABLE' (2), 'SYSTEM_VARIABLE' (3) and    'HEAP_DATA' (16) require both the DATA and IDENT parameters.  For    the first two record types, the IDENT parameter is the name of the    variable, as a scalar string.  Variable names should be valid IDL    variable names, uppercase, and have no embedded spaces.  For the    'HEAP_DATA' record type, the IDENT parameter is the heap index    value, as described below.  The DATA itself can be any supported    IDL variable type (as described in CMSV_WVTYPE).     For records that accept data in the form of a structure, as listed    below, the listed structure tag entries are optional.  If the user    does not provide a value, then a suitable default will be computed    by this procedure (listed in parentheses).     A record of type 'VERSION' (14) has the following structure:           { FORMAT_VERSION: 0L, $   ; Format version number of file (5)            ARCH: '', $             ; !VERSION.ARCH of creating host            OS: '', $               ; !VERSION.OS of creating host            RELEASE: '' }           ; !VERSION.RELEASE of creating host     A record of type 'TIMESTAMP' (10) has the following structure:            { SAVE_DATE: '', $  ; Date the save file was created (SYSTIME(0))             SAVE_USER: '', $  ; User name who  created file ('UNKNOWN')             SAVE_HOST: '' }   ; Host name that created file ('UNKNOWN')     Save files created by IDL version 4 do not contain a timestamp    record.  Under Unix this procedure will attempt to discover the    user and host names automatically.     A record of type 'IDENTIFICATION' (13) has the following    structure:            { AUTHOR: '', $  ; Author of SAVE file ('')             TITLE:  '', $  ; Title of SAVE file  ('')             IDCODE: '' }   ; Identifying code for SAVE file ('')     It appears that this record is not used in IDL version 5 or later.     A record of type 'COMMON_BLOCK' (1) defines a named common block    and its variables.  A common block descriptor consists of an array    of strings whose first element is the common block name, and whose    remaining elements are the common block variable names.  Thus, a    common block descriptor must have at least two elements.  No    variable data are stored with the common block definition.     When a record of type 'NOTICE' (19) defines a notice to be    included in the save file.  It is a structure with one field:    {TEXT: ''}, where TEXT is the text content of the notice.     A record of type 'HEAP_INDEX' (15) defines the heap index in a    SAVE file.  The heap index specifies a list of which heap    variables are stored in the current save file.  These indices are    simply numbers which identify each heap variable (i.e.,     &lt;PtrHeapVar2&gt;  would have an index of 2).  The heap index can use    any numbers to identify the heap data; however it is required that    all index entries have corresponding heap data values.   WRITING HEAP DATA     If your data contains heap data and/or pointers, then users must    take special care in writing their data.  Writing heap data is    actually more straightforward than reading it.  There are several    steps involved which can be summarized as followed: (1) take    inventory of HEAP data; (2) write HEAP_INDEX record; (3) write one    HEAP_DATA record for each heap variable; and (4) write any other    variables using the heap index.     (1) Take inventory of heap data.  Before writing any data to the        SAVE file, use the CMSV_PTRSUM procedure to discover all        pointer variables in the data set, like so:            cmsv_ptrsum, var, ptrlist         PTRLIST contains an array of any heap variables pointed to by        VAR (including structures or pointed-to variables).  If        multiple variables are to be written, then the inventory must        contain the union of all heap variables.     (2) Write a HEAP_INDEX record.  The heap index is an array of long        integers which identify the heap variables.  In principle it        doesn't matter which integers are used, however there must be        a one-to-one correspondence between the entries in the heap        index and the heap identifiers used in the next step.  In this        example a simple LINDGEN is used:             index = lindgen(n_elements(ptrlist))            cmsv_wrec, block, pointer, index, block_name='HEAP_INDEX', $              offset=offset     (3) Write one HEAP_DATA record for each heap variable.  Issue one        CMSV_WREC call for each entry in PTRLIST, as follows for the        ith heap variable:             cmsv_wrec, block, pointer, ptrlist(i), block_name='HEAP_DATA', $              ptr_index=index, ptr_data=ptrlist, offset=offset         Note that the PTR_INDEX and PTR_DATA keywords are required        because heap data may itself contain pointers.  The PTR_INDEX        and PTR_DATA keywords enable the CMSV_WREC procedure to write        appropriate descriptors when it encounters pointers.     (4) Write remaining data.  For the ith variable, use:            cmsv_wrec, block, pointer, var(i), name(i), block_name='VARIABLE',$              ptr_index=index, ptr_data=ptrlist, offset=offset         As above, using the PTR_INDEX and PTR_DATA keywords will allow        the CMSV_WREC procedure to write the appropriate data.   BLOCK, POINTER, OFFSET     This procedure writes data to a byte array or a file.  If the UNIT    keyword is specified then file is sent to the specified unit    number rather than to the buffer BLOCK.  However, the intent is    for users to accumulate a significant amount of data in a BLOCK    and then write it out with a single call to WRITEU.  Users should    be aware that the block can be larger than the buffered data, so    they should use something like the following:            WRITEU, UNIT, BLOCK(0:POINTER-1)     When library routines do indeed write buffered BLOCK data to disk,    they will appropriately reset the BLOCK and POINTER.  Namely,    BLOCK will be reset to empty, and POINTER will be reset to zero.    OFFSET will be advanced the according number of bytes.     The terminology is as follows: BLOCK is a byte array which    represents a portion of, or an entire, IDL SAVE file.  The block    may be a cached portion of an on-disk file, or an entire in-memory    SAVE file.  POINTER is the current file pointer within BLOCK    (i.e., the next byte to be read is BLOCK[POINTER]).  Hence, a    POINTER value of 0 refers to the start of the block.  OFFSET is    the file offset of the 0th byte of BLOCK; thus  POINT_LUN,    OFFSET+POINTER  should point to the same byte as BLOCK[POINTER].    The following diagram shows the meanings for BLOCK, POINTER and    OFFSET schematically:                   0 &lt;-  OFFSET  -&gt; |    FILE          |----------------|------*--------|---------&gt;     BLOCK                          |------*--------|                                   0      ^ POINTER     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     BLOCK - a byte array, a cache of the SAVE file.  Users will            usually not access this array directly.  Users are advised            to clear BLOCK after calling POINT_LUN or writing the            block to disk.     POINTER - a long integer, a pointer to the next byte to be read              from BLOCK.  CMSVLIB routines will automatically              advance the pointer.     DATA - the record contents to be written, as describe above.     IDENT - for record types 'VARIABLE' (2) and 'SYSTEM_VARIABLE' (3),            the name of the variable as a scalar string.  For record            type 'HEAP_DATA' (16), the heap index identifier as a            scalar long integer.   KEYWORDS:     BLOCK_NAME - a scalar string specifying the record type, as                 described above.  The BLOCK_TYPE keyword takes                 precedence over BLOCK_NAME.     BLOCK_TYPE - a scalar integer specifying the record type, as                 described above.     NEXT_BLOCK - if specified, the file offset of the next record                 location.                 Default: the offset will be computed automatically.     INITIALIZE - if the keyword is set, then the BLOCK is emptied and                 the POINTER is reset before any new data is written.     NO_TYPE - if set, no type descriptor or data are written for              variable records.     NO_DATA - if set, no data are written for variable records.     TEMPORARY - if set, then the input DATA are discarded after being                written, as a memory economy provision.     PTR_INDEX - a heap index array for the data being written, if any                heap data records have been written.                Default: no pointers are written     PTR_DATA - an array of pointers, pointing to the heap values being               written.               Default: no pointers are written     UNIT - a file unit.  If specified then data are directed to the           file unit rather than to the buffer BLOCK.     OFFSET - the file offset of byte zero of BLOCK.             Upon output, if the file pointer is advanced, OFFSET will             also be changed.             (OFFSET is not currently used by this routine)             Default: 0     COMPATIBILITY - a string, which describes the format to be used in           the output file.  Possible values are:                    'IDL4' - format of IDL version 4;                   'IDL5' - format of IDL versions 5.0-5.3;                   'IDL6' - not supported yet, for versions 5.4-above;                   'RIVAL1' - same as 'IDL5', plus a directory entry is                             written to the file.            Note that files written in IDL5 format may still be            readable by IDL v.4.            Default: 'IDL5'     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Added notification about RSI License, 13 May 2002, CM    Added NOTICE record type, 09 Jun 2003, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_wrec.pro,v 1.10 2009/11/22 22:50:49 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wrec.html#cmsv_wcomm", "cmsv_wcomm", 'routine in <a href="gdl/cmsv_wrec.html">cmsv_wrec.pro</a>', "cmsv_wrec.pro", "", "cmsv_wcomm", "", "statuserrmsgblockpointernames", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wrec.html#cmsv_wheap", "cmsv_wheap", 'routine in <a href="gdl/cmsv_wrec.html">cmsv_wrec.pro</a>', "cmsv_wrec.pro", "", "cmsv_wheap", "", "statuserrmsgblockpointerindices", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wrec.html#cmsv_wstamp", "cmsv_wstamp", 'routine in <a href="gdl/cmsv_wrec.html">cmsv_wrec.pro</a>', "cmsv_wrec.pro", "", "cmsv_wstamp", "", "offsetstatuserrmsgsave_datesave_usersave_host_extrablockpointer", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wrec.html#cmsv_wversion", "cmsv_wversion", 'routine in <a href="gdl/cmsv_wrec.html">cmsv_wrec.pro</a>', "cmsv_wrec.pro", "", "cmsv_wversion", "", "statuserrmsgformat_versionarchosreleasecompatible_extrablockpointer", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wrec.html#cmsv_wident", "cmsv_wident", 'routine in <a href="gdl/cmsv_wrec.html">cmsv_wrec.pro</a>', "cmsv_wrec.pro", "", "cmsv_wident", "", "statuserrmsgauthortitleidcode_EXTRAblockpointer", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wrec.html#cmsv_wnotice", "cmsv_wnotice", 'routine in <a href="gdl/cmsv_wrec.html">cmsv_wrec.pro</a>', "cmsv_wrec.pro", "", "cmsv_wnotice", "", "statuserrmsgtext_EXTRAblockpointer", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wrec.html#cmsv_wrec", "cmsv_wrec", 'routine in <a href="gdl/cmsv_wrec.html">cmsv_wrec.pro</a>', "cmsv_wrec.pro", "", "cmsv_wrec", "", "unitoffsetinitializefinishno_datano_typeblock_typeblock_namenext_blockcompatibilitystatuserrmsg_EXTRAblockpointerdataname", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsv_wvtype.html", "cmsv_wvtype.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsv_wvtype.pro", "", "", " NAME:    CMSV_WVTYPE   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Write variable type information to output block   CALLING SEQUENCE:    CMSV_WVTYPE, BLOCK, DATA, IDENT, $                 HEAP=HEAP, SYSTEM=SYSTEM, UNIT=UNIT, $                 OFFSET=OFFSET, STATUS=STATUS, ERRMSG=ERRMSG   DESCRIPTION:     CMSV_WVTYPE writes the type portion of an IDL SAVE variable    record.  An IDL variable is stored in two components: the type    descriptor which describes the name, type, and dimensions of the    variable; and the data record, which contains the raw data of the    variable.  This procedure writes the type descriptor based on a    variable passed by the user.  Once the type descriptor has been    written, the data portion can be written using the CMSV_WDATA    procedure.     CMSV_WVTYPE should recognize and correctly output type descriptors    for all currently known IDL data types, except for object    references.  Type information is inferred from the DATA parameter    passed by the user.     Heap data is a special case, since the data itself are stored    separately from the pointer in the SAVE file.  Three steps must be    satisfied: a HEAP_INDEX record must be written; a valid HEAP_DATA    record must be written containing a type descriptor (written with    this procedure) and the heap data; and the named pointer itself    must be written.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   BLOCK, POINTER, OFFSET     This procedure writes data to a byte array only.  The intent is    for users to accumulate a significant amount of data in a BLOCK    and then write it out with a single call to WRITEU.  Users should    be aware that the block can be larger than the buffered data, so    they should use something like the following:            WRITEU, UNIT, BLOCK(0:POINTER-1)     When library routines do indeed write buffered BLOCK data to disk,    they will appropriately reset the BLOCK and POINTER.  Namely,    BLOCK will be reset to empty, and POINTER will be reset to zero.    OFFSET will be advanced the according number of bytes.     The terminology is as follows: BLOCK is a byte array which    represents a portion of, or an entire, IDL SAVE file.  The block    may be a cached portion of an on-disk file, or an entire in-memory    SAVE file.  POINTER is the current file pointer within BLOCK    (i.e., the next byte to be written is BLOCK[POINTER]).  Hence, a    POINTER value of 0 refers to the start of the block.  OFFSET is    the file offset of the 0th byte of BLOCK; thus  POINT_LUN,    OFFSET+POINTER  should point to the same byte as BLOCK[POINTER].    The following diagram shows the meanings for BLOCK, POINTER and    OFFSET schematically:                   0 &lt;-  OFFSET  -&gt; |    FILE          |----------------|------*--------|---------&gt;     BLOCK                          |------*--------|                                   0      ^ POINTER     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     BLOCK - a byte array, a cache of the SAVE file.  Users will            usually not access this array directly.  Users are advised            to clear BLOCK after calling POINT_LUN or writing the            block to disk.     POINTER - a long integer, a pointer to the next byte to be written              from BLOCK.  CMSVLIB routines will automatically advance              the pointer.     DATA - the data to be written, of any save-able data type.     IDENT - for variables, the name of the variable as a string; for            heap data, the heap index as an integer.   KEYWORDS:     HEAP - if set, the data is treated as heap data, and IDENT must be           an integer heap index.     SYSTEM - if set, the data is assumed to be a system variable.     UNIT - a file unit.  Currently ignored.     OFFSET - the file offset of byte zero of BLOCK.             Upon output, if the file pointer is advanced, OFFSET will             also be changed.             (OFFSET is not currently used by this routine)             Default: 0     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Added notification about RSI License, 13 May 2002, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsv_wvtype.pro,v 1.14 2009/11/22 22:50:49 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wvtype.html#cmsv_warrdesc", "cmsv_warrdesc", 'routine in <a href="gdl/cmsv_wvtype.html">cmsv_wvtype.pro</a>', "cmsv_wvtype.pro", "", "cmsv_warrdesc", "", "statuslengtherrmsgblockpointersz", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wvtype.html#cmsv_wstructdesc", "cmsv_wstructdesc", 'routine in <a href="gdl/cmsv_wvtype.html">cmsv_wvtype.pro</a>', "cmsv_wvtype.pro", "", "cmsv_wstructdesc", "", "statustemplateerrmsgnocatchblockpointer", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/cmsv_wvtype.html#cmsv_wvtype", "cmsv_wvtype", 'routine in <a href="gdl/cmsv_wvtype.html">cmsv_wvtype.pro</a>', "cmsv_wvtype.pro", "", "cmsv_wvtype", "", "heapsystemoffsetunitstatuserrmsgblockpointerdataident", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsvlib.html", "cmsvlib.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsvlib.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsvlib.html#cmsvlib", "cmsvlib", 'routine in <a href="gdl/cmsvlib.html">cmsvlib.pro</a>', "cmsvlib.pro", "", "cmsvlib", " NAME:    CMSVLIB   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Initialize the CMSVLIB save library   CALLING SEQUENCE:    VALUE = CMSVLIB(/QUERY, VERSION=version)   DESCRIPTION:     This function initializes the CMSVLIB library to read, write and    interrogate IDL save files.  Use the QUERY keyword to determine    whether the full CMSVLIB library is present.     The VERSION keyword allows the user to query the version number of    the CMSVLIB library.  The library version number will be returned    as a string of the form  X.Y  where X is the major version number    and Y is the minor version number.  Callers can use this version    number to decide whether this particular version of the library is    compatible with their usage.     The procedures in the library are:      High-level       CMSAVE - save variables to a save file       CMRESTORE - restore variables from a save file       CMSAVEDIR - list contents of a save file       CMSVLIB (function) - this file      Mid-level       CMSV_OPEN - open a save file for reading or writing       CMSVREAD - read non-pointer data from file       CMSVWRITE - write non-pointer data to file      Low-level       CMSV_RREC - read record from save file       CMSV_RVTYPE - read variable type information from file       CMSV_RDATA - read variable data from file       CMSV_WREC - write record to save file       CMSV_WVTYPE - write variable type information to file       CMSV_WDATA - write variable data to file      Utility       CMSV_RRAW (function) - read raw integer or string data from file       CMSV_WRAW - write raw integer or string data to file       CMSV_PTRSUM - create a heap data inventory       CMSV_TEST - test the library       TAGSIZE (function) - determine the types of all tags in a structure       HELPFORM (function) - create HELP-like string describing a variable     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   INPUTS:     None   KEYWORDS:     QUERY - if set, determine whether the CMSVLIB library is            installed.  Function returns 1 upon success, 0 upon            failure.     VERSION - upon return, the VERSION keyword will be set to a string              describing the version number of the CMSVLIB library.   EXAMPLE:   SEE ALSO:     CMRESTORE, SAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written, 2000    Documented, 24 Jan 2001    Added notification about RSI License, 13 May 2002, CM    Documented the VERSION keyword, 22 Nov 2009, CM   LIBRARY MODIFICATIONS    1.0 - initial release    1.1 - 2003-06-28 - CMSV_RREC - added NOTICE record type    1.2 - 2006-03-07 - CMSV_RVTYPE - avoid reserved word INHERITS    1.3 - 2006-03-27 - CMSV_WDATA - add support to write bytes & empty          strings    1.4 - 2009-11-16 - CMSV_RREC - NEXTREC field is ULONG    1.5 - 2009-11-22 - CMSV_RDATA - clarify & speed some code    1.6 - 2010-01-11 - CMSV_RREC - read 64-bit files    1.7 - 2012-04-05 - CMSV_WRAW - writing strings &gt;128 fixed   $Id: cmsvlib.pro,v 1.7 2012/04/05 20:43:10 cmarkwar Exp $   ", "versionquery", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsvread.html", "cmsvread.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsvread.pro", "", "", " NAME:    CMSVREAD   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Read a single variable from an open SAVE file   CALLING SEQUENCE:     CMSVREAD, UNIT, DATA [, NAME=NAME, /NO_DATA, VERSION=VERSION,                            TIMESTAMP=TIMESTAMP ]   DESCRIPTION:     CMSVREAD reads a single IDL variable from an open IDL SAVE file.    The file should already have been opened as a normal file using    OPENR.     CMSVREAD is a simplified version of the CMSVLIB package, and as    such is not capable of reading heap data (pointers) or object    data.  Strings, structures, and all array types are supported.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   INPUTS:     UNIT - the open file unit.     DATA - a named variable, into which the new data is to be read.   KEYWORDS:     NAME - upon output, the name of the saved variable is returned in           this keyword.  If a failure or end of file condition           occurs, name will be undefined upon return.     STRUCTURE_NAME - if the data to be read is a structure, upon                     output, this keyword will contain the name of the                     structure.  A value of '' indicates an anonymous                     structure.     SIZE - upon output, the SIZE type of the data is returned in this           keyword.     NO_DATA - if set, no data is read from the file, only the variable             name and type.     TIMESTAMP - after the first call to CMSVREAD on a newly opened                file, this keyword will contain the file timestamp                structure.     VERSION - after the first call to CMSVREAD on a newly opened file,              this keyword will contain the file version information,              if available.     QUIET - if set, error messages are not printed.            Default: an error causes errors to be printed with MESSAGE     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:     Read all variables from a file, and print help on them.     openr, 50, 'test.sav'    name = ''    while n_elements(name) GT 0 do begin   ;; EOF signalled by NAME undefined       cmsvread, 50, data, name=name       help, name, data    end    close, 50   SEE ALSO:     CMSVWRITE, CMRESTORE, CMSAVE, RESTORE, CMSVLIB   MODIFICATION HISTORY:    Written and documented, 11 Jan 2001, CM    Added notification about RSI License, 13 May 2002, CM    Remove support for undocumented AUTOPROMOTE64 keyword,       11 Jan 2010, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsvread.pro,v 1.9 2010/01/11 08:58:13 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsvread.html#cmsvread", "cmsvread", 'routine in <a href="gdl/cmsvread.html">cmsvread.pro</a>', "cmsvread.pro", "", "cmsvread", "", "timestampversionnamesizeno_datastructure_namepromote64quietstatuserrmsgunit0data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/cmsvwrite.html", "cmsvwrite.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "cmsvwrite.pro", "", "", " NAME:    CMSVWRITE   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Write a single variable to an open SAVE file   CALLING SEQUENCE:     CMSVWRITE, UNIT, DATA [ , NAME=NAME, COMPATIBILITY=COMPAT ]   DESCRIPTION:     CMSVWRITE writes a single IDL variable to an open IDL SAVE file.    The file should already have been opened for writing as a normal    file using OPENW or OPENU.     CMSVWRITE is a simplified version of the CMSVLIB package, and as    such is not capable of writing heap data (pointers) or object    data, or structures that contain them.  Strings, structures, and    all array types are supported.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   ==================================================================    Research Systems, Inc. has issued a separate license intended    to resolve any potential conflict between this software and the    IDL End User License Agreement. The text of that license    can be found in the file LICENSE.RSI, included with this    software library.  ==================================================================   INPUTS:     UNIT - the open file unit.     DATA - the data to be written.   KEYWORDS:     NAME - the optional name of the variable to be written (must be a           valid variable name).           Default: CMSVWRITE automatically creates a valid name.     COMPATIBILITY - a string, which describes the format to be used in           the output file.  Possible values are:                    'IDL4' - format of IDL version 4;                   'IDL5' - format of IDL versions 5.0-5.3;                   'IDL6' - not supported yet, for versions 5.4-above;                   'RIVAL1' - same as 'IDL5'            Note that files written in IDL5 format may still be            readable by IDL v.4.            Default: 'IDL5'     NO_END - a save file must terminate with an  end  record.  By             default, CMSVWRITE will append such a record after the             variable is written, and then rewind the file pointer.             The end record must be written after the last variable,             but is optional otherwise.  Set this keyword to disable             writing the end record (for performance reasons).     QUIET - if set, error messages are not printed.            Default: an error causes errors to be printed with MESSAGE     STATUS - upon return, this keyword will contain 1 for success and             0 for failure.     ERRMSG - upon return with a failure, this keyword will contain the             error condition as a string.   EXAMPLE:     Write variables A, B, C and D to a file.     openw, 50, 'test.sav'       ;; Add /STREAM under VMS !    cmsvwrite, 50, a, name='a'    cmsvwrite, 50, b, name='b'    cmsvwrite, 50, c, name='c'    close, 50   SEE ALSO:     CMSVREAD, CMRESTORE, CMSAVE, SAVE, CMSVLIB   MODIFICATION HISTORY:    Written and documented, 11 Jan 2001, CM    Make version checks with correct precision, 19 Jul 2001, CM    Added notification about RSI License, 13 May 2002, CM    NOTE: remember to modify CMSVLIB.PRO when changing library!   $Id: cmsvwrite.pro,v 1.12 2009/11/22 22:50:49 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/cmsvwrite.html#cmsvwrite", "cmsvwrite", 'routine in <a href="gdl/cmsvwrite.html">cmsvwrite.pro</a>', "cmsvwrite.pro", "", "cmsvwrite", "", "namecompatno_endquietstatuserrmsgunit0data", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/compare_dimitri_cnes_sade.html", "compare_dimitri_cnes_sade.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "compare_dimitri_cnes_sade.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/compare_dimitri_cnes_sade.html#COMPARE_DIMITRI_CNES_SADE", "COMPARE_DIMITRI_CNES_SADE", 'routine in <a href="sade/compare_dimitri_cnes_sade.html">compare_dimitri_cnes_sade.pro</a>', "compare_dimitri_cnes_sade.pro", "", "COMPARE_DIMITRI_CNES_SADE", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/compile_common.html", "compile_common.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "compile_common.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/compile_common.html#COMPILE_COMMON", "COMPILE_COMMON", 'routine in <a href="hmi/compile_common.html">compile_common.pro</a>', "compile_common.pro", "", "COMPILE_COMMON", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("doublet/compute_amc_routines.html", "compute_amc_routines.pro", '.pro file in <a href="doublet/dir-overview.html">doublet/ directory</a>', "compute_amc_routines.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("doublet/compute_amc_routines.html#COMPUTE_AMC", "COMPUTE_AMC", 'routine in <a href="doublet/compute_amc_routines.html">compute_amc_routines.pro</a>', "compute_amc_routines.pro", "", "COMPUTE_AMC", "", "VERBOSESZA_AVZA_ARAA_ASZA_BVZA_BRAA_B", "          -1", "");
  
  libdata[libdataItem++] = new Array("doublet/compute_amc_routines.html#COMPUTE_AMC_THRESHOLD", "COMPUTE_AMC_THRESHOLD", 'routine in <a href="doublet/compute_amc_routines.html">compute_amc_routines.pro</a>', "compute_amc_routines.pro", "", "COMPUTE_AMC_THRESHOLD", "", "VERBOSEDIFF_SZADIFF_VZADIFF_RAA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/compute_parasol_viewing_geometries.html", "compute_parasol_viewing_geometries.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "compute_parasol_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/compute_parasol_viewing_geometries.html#COMPUTE_PARASOL_VIEWING_GEOMETRIES", "COMPUTE_PARASOL_VIEWING_GEOMETRIES", 'routine in <a href="sade/compute_parasol_viewing_geometries.html">compute_parasol_viewing_geometries.pro</a>', "compute_parasol_viewing_geometries.pro", "", "COMPUTE_PARASOL_VIEWING_GEOMETRIES", "", "ORDERPVZAPRAAPDVZCPDVZS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/compute_parasol_viewing_geometries.html", "compute_parasol_viewing_geometries.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "compute_parasol_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/compute_parasol_viewing_geometries.html#compute_parasol_viewing_geometries", "compute_parasol_viewing_geometries", 'routine in <a href="validation/compute_parasol_viewing_geometries.html">compute_parasol_viewing_geometries.pro</a>', "compute_parasol_viewing_geometries.pro", "", "compute_parasol_viewing_geometries", "", "orderpvzapraapdvzcpdvzs", "          -1", "");
  
  

libdata[libdataItem++] = new Array("toa_simulation/compute_transmission.html", "compute_transmission.pro", '.pro file in <a href="toa_simulation/dir-overview.html">toa_simulation/ directory</a>', "compute_transmission.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("toa_simulation/compute_transmission.html#COMPUTE_TRANSMISSION", "COMPUTE_TRANSMISSION", 'routine in <a href="toa_simulation/compute_transmission.html">compute_transmission.pro</a>', "compute_transmission.pro", "", "COMPUTE_TRANSMISSION", "", "VERBOSETO3O3TH2OWVTGASTHETASTHETAV", "          -1", "");
  
  

libdata[libdataItem++] = new Array("recal/concatenate_toa_reflectance.html", "concatenate_toa_reflectance.pro", '.pro file in <a href="recal/dir-overview.html">recal/ directory</a>', "concatenate_toa_reflectance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("recal/concatenate_toa_reflectance.html#CONCATENATE_TOA_REFLECTANCE", "CONCATENATE_TOA_REFLECTANCE", 'routine in <a href="recal/concatenate_toa_reflectance.html">concatenate_toa_reflectance.pro</a>', "concatenate_toa_reflectance.pro", "", "CONCATENATE_TOA_REFLECTANCE", "", "VERBOSEOFOLDERSS_REGIONREF_SENSORREF_PROC_VER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/congrid.html", "congrid.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "congrid.pro", "", "", " NAME:    CONGRID   PURPOSE:        Shrink or expand the size of an array by an arbitrary amount.        This IDL procedure simulates the action of the VAX/VMS        CONGRID/CONGRIDI function.     This function is similar to  REBIN  in that it can resize a        one, two, or three dimensional array.    REBIN , however,        requires that the new array size must be an integer multiple        of the original size.   CONGRID will resize an array to any        arbitrary size (REBIN is somewhat faster, however).        REBIN averages multiple points when shrinking an array,        while CONGRID just resamples the array.   CATEGORY:        Array Manipulation.   CALLING SEQUENCE:    array = CONGRID(array, x, y, z)   INPUTS:        array:  A 1, 2, or 3 dimensional array to resize.                Data Type : Any type except string or structure.         x:      The new X dimension of the resized array.                Data Type : Int or Long (greater than or equal to 2).   OPTIONAL INPUTS:        y:      The new Y dimension of the resized array.   If the original                array has only 1 dimension then y is ignored.   If the                original array has 2 or 3 dimensions then y MUST be present.         z:      The new Z dimension of the resized array.   If the original                array has only 1 or 2 dimensions then z is ignored.   If the                original array has 3 dimensions then z MUST be present.   KEYWORD PARAMETERS:     CENTER: If this keyword is set, shift the interpolation so that points        in the input and output arrays are assumed to lie at the midpoint        of their coordinates rather than at their lower-left corner.     INTERP: If set, causes linear interpolation to be used.        Otherwise, the nearest-neighbor method is used.     CUBIC:  If specified and non-zero,  Cubic convolution         interpolation is used.  This is a more        accurate, but more time-consuming, form of interpolation.        CUBIC has no effect when used with 3 dimensional arrays.        If this parameter is negative and non-zero, it specifies the        value of the cubic interpolation parameter as described        in the INTERPOLATE function.  Valid ranges are -1 &lt;= Cubic &lt; 0.        Positive non-zero values of CUBIC (e.g. specifying /CUBIC)        produce the default value of the interpolation parameter        which is -1.0.         MINUS_ONE:                If set, will prevent CONGRID from extrapolating one row or                column beyond the bounds of the input array.   For example,                If the input array has the dimensions (i, j) and the                output array has the dimensions (x, y), then by                default the array is resampled by a factor of (i/x)                in the X direction and (j/y) in the Y direction.                If MINUS_ONE is present (AND IS NON-ZERO) then the array                will be resampled by the factors (i-1)/(x-1) and (j-1)/(y-1).   OUTPUTS:    The returned array has the same number of dimensions as the original        array and is of the same data type.   The returned array will have        the dimensions (x), (x, y), or (x, y, z) depending on how many        dimensions the input array had.   PROCEDURE:        IF the input array has three dimensions, or if INTERP is set,        then the IDL interpolate function is used to interpolate the        data values.        If the input array has two dimensions, and INTERP is NOT set,        then the IDL POLY_2D function is used for nearest neighbor sampling.        If the input array has one dimension, and INTERP is NOT set,        then nearest neighbor sampling is used.   EXAMPLE:        ; vol is a 3-D array with the dimensions (80, 100, 57)        ; Resize vol to be a (90, 90, 80) array        vol = CONGRID(vol, 90, 90, 80)   MODIFICATION HISTORY:        DMS, Sept. 1988.        DMS, Added the MINUS_ONE keyword, Sept. 1992.    Daniel Carr. Re-wrote to handle one and three dimensional arrays                     using INTERPOLATE function.    DMS, RSI, Nov, 1993.  Added CUBIC keyword.        SJL, Nov, 1997.  Formatting, conform to IDL style guide.        CT, RSI, April 2001. Added /CENTER keyword. Correct POLY_2D interp.  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/congrid.html#CONGRID", "CONGRID", 'routine in <a href="gdl/congrid.html">congrid.pro</a>', "congrid.pro", "", "CONGRID", "", "CENTERCUBICINTERPMINUS_ONEarrxyz", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/convert_emissive_to_btemp.html", "convert_emissive_to_btemp.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "convert_emissive_to_btemp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/convert_emissive_to_btemp.html#CONVERT_EMISSIVE_TO_BTEMP", "CONVERT_EMISSIVE_TO_BTEMP", 'routine in <a href="modisa/convert_emissive_to_btemp.html">convert_emissive_to_btemp.pro</a>', "convert_emissive_to_btemp.pro", "", "CONVERT_EMISSIVE_TO_BTEMP", "", "VERBOSEEMM_DATABAND_ID", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/convert_index_to_wavelength.html", "convert_index_to_wavelength.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "convert_index_to_wavelength.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/convert_index_to_wavelength.html#CONVERT_INDEX_TO_WAVELENGTH", "CONVERT_INDEX_TO_WAVELENGTH", 'routine in <a href="misc/convert_index_to_wavelength.html">convert_index_to_wavelength.pro</a>', "convert_index_to_wavelength.pro", "", "CONVERT_INDEX_TO_WAVELENGTH", "", "VERBOSEIDXIW_SENSOR", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/convert_sade_to_dimitri.html", "convert_sade_to_dimitri.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "convert_sade_to_dimitri.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/convert_sade_to_dimitri.html#CONVERT_SADE_TO_DIMITRI", "CONVERT_SADE_TO_DIMITRI", 'routine in <a href="sade/convert_sade_to_dimitri.html">convert_sade_to_dimitri.pro</a>', "convert_sade_to_dimitri.pro", "", "CONVERT_SADE_TO_DIMITRI", "", "SADEFILESENSOR", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/convert_time_to_jday.html", "convert_time_to_jday.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "convert_time_to_jday.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/convert_time_to_jday.html#CONVERT_TIME_TO_JDAY", "CONVERT_TIME_TO_JDAY", 'routine in <a href="misc/convert_time_to_jday.html">convert_time_to_jday.pro</a>', "convert_time_to_jday.pro", "", "CONVERT_TIME_TO_JDAY", "", "ELAUNCHY2000VERBOSEIDATE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/convert_timeseries_to_sade.html", "convert_timeseries_to_sade.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "convert_timeseries_to_sade.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/convert_timeseries_to_sade.html#CONVERT_TIMESERIES_TO_SADE", "CONVERT_TIMESERIES_TO_SADE", 'routine in <a href="sade/convert_timeseries_to_sade.html">convert_timeseries_to_sade.pro</a>', "convert_timeseries_to_sade.pro", "", "CONVERT_TIMESERIES_TO_SADE", "", "SENSORPROC_VERSENSOR_DATANUMPIXSBANDS_INDEXSITEPRODNAMESPFLAG", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/convert_timeseries_to_sade.html", "convert_timeseries_to_sade.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "convert_timeseries_to_sade.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/convert_timeseries_to_sade.html#CONVERT_TIMESERIES_TO_SADE", "CONVERT_TIMESERIES_TO_SADE", 'routine in <a href="validation/convert_timeseries_to_sade.html">convert_timeseries_to_sade.pro</a>', "convert_timeseries_to_sade.pro", "", "CONVERT_TIMESERIES_TO_SADE", "", "SENSORproc_verSENSOR_DATANUMPIXSBANDS_INDEXSITEprodnamesPFLAG", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/convert_wavelength_to_dindex.html", "convert_wavelength_to_dindex.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "convert_wavelength_to_dindex.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/convert_wavelength_to_dindex.html#CONVERT_WAVELENGTH_TO_DINDEX", "CONVERT_WAVELENGTH_TO_DINDEX", 'routine in <a href="misc/convert_wavelength_to_dindex.html">convert_wavelength_to_dindex.pro</a>', "convert_wavelength_to_dindex.pro", "", "CONVERT_WAVELENGTH_TO_DINDEX", "", "VERBOSEWAVELENGTH", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/create_dimitri_folders.html", "create_dimitri_folders.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "create_dimitri_folders.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/create_dimitri_folders.html#create_new_tar", "create_new_tar", 'routine in <a href="validation/create_dimitri_folders.html">create_dimitri_folders.pro</a>', "create_dimitri_folders.pro", "", "create_new_tar", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/create_dimitri_folders.html#create_dimitri_folders", "create_dimitri_folders", 'routine in <a href="validation/create_dimitri_folders.html">create_dimitri_folders.pro</a>', "create_dimitri_folders.pro", "", "create_dimitri_folders", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/create_dimitri_folders.html#move_dimitri_jpegs", "move_dimitri_jpegs", 'routine in <a href="validation/create_dimitri_folders.html">create_dimitri_folders.pro</a>', "create_dimitri_folders.pro", "", "move_dimitri_jpegs", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/create_dimitri_folders.html#move_dimitri_savs", "move_dimitri_savs", 'routine in <a href="validation/create_dimitri_folders.html">create_dimitri_folders.pro</a>', "create_dimitri_folders.pro", "", "move_dimitri_savs", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/create_dimitri_folders.html#move_vgt_jpegs", "move_vgt_jpegs", 'routine in <a href="validation/create_dimitri_folders.html">create_dimitri_folders.pro</a>', "create_dimitri_folders.pro", "", "move_vgt_jpegs", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/create_new_dimitri_tar.html", "create_new_dimitri_tar.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "create_new_dimitri_tar.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/create_new_dimitri_tar.html#CREATE_NEW_DIMITRI_TAR", "CREATE_NEW_DIMITRI_TAR", 'routine in <a href="misc/create_new_dimitri_tar.html">create_new_dimitri_tar.pro</a>', "create_new_dimitri_tar.pro", "", "CREATE_NEW_DIMITRI_TAR", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("cloudscreening/cs_band_info.html", "cs_band_info.pro", '.pro file in <a href="cloudscreening/dir-overview.html">cloudscreening/ directory</a>', "cs_band_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("cloudscreening/cs_band_info.html#CS_BAND_INFO", "CS_BAND_INFO", 'routine in <a href="cloudscreening/cs_band_info.html">cs_band_info.pro</a>', "cs_band_info.pro", "", "CS_BAND_INFO", "", "VERBOSECS_ALGO", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dhmi_cloud_screening.html", "dhmi_cloud_screening.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dhmi_cloud_screening.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dhmi_cloud_screening.html#DHMI_CLOUD_SCREENING_TOOLBAR", "DHMI_CLOUD_SCREENING_TOOLBAR", 'routine in <a href="hmi/dhmi_cloud_screening.html">dhmi_cloud_screening.pro</a>', "dhmi_cloud_screening.pro", "", "DHMI_CLOUD_SCREENING_TOOLBAR", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_cloud_screening.html#DHMI_CLOUD_SCREENING_CHANGE_IMAGE", "DHMI_CLOUD_SCREENING_CHANGE_IMAGE", 'routine in <a href="hmi/dhmi_cloud_screening.html">dhmi_cloud_screening.pro</a>', "dhmi_cloud_screening.pro", "", "DHMI_CLOUD_SCREENING_CHANGE_IMAGE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_cloud_screening.html#DHMI_CLOUD_SCREENING", "DHMI_CLOUD_SCREENING", 'routine in <a href="hmi/dhmi_cloud_screening.html">dhmi_cloud_screening.pro</a>', "dhmi_cloud_screening.pro", "", "DHMI_CLOUD_SCREENING", "", "GROUP_LEADERVERBOSEDB_IDX", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dhmi_configuration.html", "dhmi_configuration.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dhmi_configuration.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dhmi_configuration.html#DHMI_CONFIGURATION_QL", "DHMI_CONFIGURATION_QL", 'routine in <a href="hmi/dhmi_configuration.html">dhmi_configuration.pro</a>', "dhmi_configuration.pro", "", "DHMI_CONFIGURATION_QL", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_configuration.html#DHMI_CONFIGURATION_SAVE", "DHMI_CONFIGURATION_SAVE", 'routine in <a href="hmi/dhmi_configuration.html">dhmi_configuration.pro</a>', "dhmi_configuration.pro", "", "DHMI_CONFIGURATION_SAVE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_configuration.html#DHMI_CONFIGURATION_EXIT", "DHMI_CONFIGURATION_EXIT", 'routine in <a href="hmi/dhmi_configuration.html">dhmi_configuration.pro</a>', "dhmi_configuration.pro", "", "DHMI_CONFIGURATION_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_configuration.html#DHMI_CONFIGURATION", "DHMI_CONFIGURATION", 'routine in <a href="hmi/dhmi_configuration.html">dhmi_configuration.pro</a>', "dhmi_configuration.pro", "", "DHMI_CONFIGURATION", "", "GROUP_LEADERVERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dhmi_cs_setup.html", "dhmi_cs_setup.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dhmi_cs_setup.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dhmi_cs_setup.html#DHMI_CS_SETUP_EXIT", "DHMI_CS_SETUP_EXIT", 'routine in <a href="hmi/dhmi_cs_setup.html">dhmi_cs_setup.pro</a>', "dhmi_cs_setup.pro", "", "DHMI_CS_SETUP_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_cs_setup.html#DHMI_CS_SETUP_START", "DHMI_CS_SETUP_START", 'routine in <a href="hmi/dhmi_cs_setup.html">dhmi_cs_setup.pro</a>', "dhmi_cs_setup.pro", "", "DHMI_CS_SETUP_START", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_cs_setup.html#DHMI_CS_SETUP_CHANGE", "DHMI_CS_SETUP_CHANGE", 'routine in <a href="hmi/dhmi_cs_setup.html">dhmi_cs_setup.pro</a>', "dhmi_cs_setup.pro", "", "DHMI_CS_SETUP_CHANGE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_cs_setup.html#DHMI_CS_SETUP", "DHMI_CS_SETUP", 'routine in <a href="hmi/dhmi_cs_setup.html">dhmi_cs_setup.pro</a>', "dhmi_cs_setup.pro", "", "DHMI_CS_SETUP", "", "GROUP_LEADERVERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dhmi_ingest.html", "dhmi_ingest.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dhmi_ingest.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dhmi_ingest.html#DHMI_INGEST_EXIT", "DHMI_INGEST_EXIT", 'routine in <a href="hmi/dhmi_ingest.html">dhmi_ingest.pro</a>', "dhmi_ingest.pro", "", "DHMI_INGEST_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_ingest.html#DHMI_INGEST_PROCESS", "DHMI_INGEST_PROCESS", 'routine in <a href="hmi/dhmi_ingest.html">dhmi_ingest.pro</a>', "dhmi_ingest.pro", "", "DHMI_INGEST_PROCESS", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_ingest.html#DHMI_INGEST_CHANGE", "DHMI_INGEST_CHANGE", 'routine in <a href="hmi/dhmi_ingest.html">dhmi_ingest.pro</a>', "dhmi_ingest.pro", "", "DHMI_INGEST_CHANGE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_ingest.html#DHMI_INGEST", "DHMI_INGEST", 'routine in <a href="hmi/dhmi_ingest.html">dhmi_ingest.pro</a>', "dhmi_ingest.pro", "", "DHMI_INGEST", "", "GROUP_LEADERVERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html", "dhmi_process_1.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dhmi_process_1.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1_START", "DHMI_PROCESS_1_START", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1_START", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1_EXIT", "DHMI_PROCESS_1_EXIT", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1_UPDATE_AMC", "DHMI_PROCESS_1_UPDATE_AMC", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1_UPDATE_AMC", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1_LIST1", "DHMI_PROCESS_1_LIST1", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1_LIST1", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1_LIST2", "DHMI_PROCESS_1_LIST2", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1_LIST2", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1_UPDATE_SCS", "DHMI_PROCESS_1_UPDATE_SCS", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1_UPDATE_SCS", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1_UPDATE_ROI", "DHMI_PROCESS_1_UPDATE_ROI", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1_UPDATE_ROI", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1_UPDATE_RCFIG", "DHMI_PROCESS_1_UPDATE_RCFIG", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1_UPDATE_RCFIG", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_1.html#DHMI_PROCESS_1", "DHMI_PROCESS_1", 'routine in <a href="hmi/dhmi_process_1.html">dhmi_process_1.pro</a>', "dhmi_process_1.pro", "", "DHMI_PROCESS_1", "", "GROUP_LEADERVERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html", "dhmi_process_2.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dhmi_process_2.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_START", "DHMI_PROCESS_2_START", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_START", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_EXIT", "DHMI_PROCESS_2_EXIT", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_PLOTS", "DHMI_PROCESS_2_PLOTS", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_PLOTS", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_UPDATE_MFOLDER", "DHMI_PROCESS_2_UPDATE_MFOLDER", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_UPDATE_MFOLDER", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_UPDATE_AFOLDER", "DHMI_PROCESS_2_UPDATE_AFOLDER", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_UPDATE_AFOLDER", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_UPDATE_MERIS", "DHMI_PROCESS_2_UPDATE_MERIS", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_UPDATE_MERIS", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_UPDATE_AATSR", "DHMI_PROCESS_2_UPDATE_AATSR", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_UPDATE_AATSR", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_UPDATE_VGT", "DHMI_PROCESS_2_UPDATE_VGT", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_UPDATE_VGT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2_UPDATE_SITE", "DHMI_PROCESS_2_UPDATE_SITE", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2_UPDATE_SITE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_process_2.html#DHMI_PROCESS_2", "DHMI_PROCESS_2", 'routine in <a href="hmi/dhmi_process_2.html">dhmi_process_2.pro</a>', "dhmi_process_2.pro", "", "DHMI_PROCESS_2", "", "GROUP_LEADERVERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dhmi_rsr.html", "dhmi_rsr.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dhmi_rsr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dhmi_rsr.html#DHMI_RSR_START", "DHMI_RSR_START", 'routine in <a href="hmi/dhmi_rsr.html">dhmi_rsr.pro</a>', "dhmi_rsr.pro", "", "DHMI_RSR_START", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_rsr.html#DHMI_RSR_CHANGE", "DHMI_RSR_CHANGE", 'routine in <a href="hmi/dhmi_rsr.html">dhmi_rsr.pro</a>', "dhmi_rsr.pro", "", "DHMI_RSR_CHANGE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_rsr.html#DHMI_RSR", "DHMI_RSR", 'routine in <a href="hmi/dhmi_rsr.html">dhmi_rsr.pro</a>', "dhmi_rsr.pro", "", "DHMI_RSR", "", "GROUP_LEADERVERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dhmi_visu.html", "dhmi_visu.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dhmi_visu.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dhmi_visu.html#DHMI_VISU_DROPLIST", "DHMI_VISU_DROPLIST", 'routine in <a href="hmi/dhmi_visu.html">dhmi_visu.pro</a>', "dhmi_visu.pro", "", "DHMI_VISU_DROPLIST", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_visu.html#DHMI_VISU_EXIT", "DHMI_VISU_EXIT", 'routine in <a href="hmi/dhmi_visu.html">dhmi_visu.pro</a>', "dhmi_visu.pro", "", "DHMI_VISU_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_visu.html#DHMI_VISU_START", "DHMI_VISU_START", 'routine in <a href="hmi/dhmi_visu.html">dhmi_visu.pro</a>', "dhmi_visu.pro", "", "DHMI_VISU_START", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_visu.html#DHMI_VISU_CHANGE", "DHMI_VISU_CHANGE", 'routine in <a href="hmi/dhmi_visu.html">dhmi_visu.pro</a>', "dhmi_visu.pro", "", "DHMI_VISU_CHANGE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dhmi_visu.html#DHMI_VISU", "DHMI_VISU", 'routine in <a href="hmi/dhmi_visu.html">dhmi_visu.pro</a>', "dhmi_visu.pro", "", "DHMI_VISU", "", "GROUP_LEADERVERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/dimitri_angle_corrector.html", "dimitri_angle_corrector.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "dimitri_angle_corrector.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/dimitri_angle_corrector.html#DIMITRI_ANGLE_CORRECTOR", "DIMITRI_ANGLE_CORRECTOR", 'routine in <a href="misc/dimitri_angle_corrector.html">dimitri_angle_corrector.pro</a>', "dimitri_angle_corrector.pro", "", "DIMITRI_ANGLE_CORRECTOR", "", "VERBOSEVZAVAASZASAA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("cloudscreening/dimitri_cloud_screening.html", "dimitri_cloud_screening.pro", '.pro file in <a href="cloudscreening/dir-overview.html">cloudscreening/ directory</a>', "dimitri_cloud_screening.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("cloudscreening/dimitri_cloud_screening.html#DIMITRI_CLOUD_SCREENING", "DIMITRI_CLOUD_SCREENING", 'routine in <a href="cloudscreening/dimitri_cloud_screening.html">dimitri_cloud_screening.pro</a>', "dimitri_cloud_screening.pro", "", "DIMITRI_CLOUD_SCREENING", "", "VERBOSESENSORSITE_TYPETOA_RHOTOA_GEOCS_ALGO", "          -1", "");
  
  

libdata[libdataItem++] = new Array("cloudscreening/dimitri_cloud_screening_bright_rho.html", "dimitri_cloud_screening_bright_rho.pro", '.pro file in <a href="cloudscreening/dir-overview.html">cloudscreening/ directory</a>', "dimitri_cloud_screening_bright_rho.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("cloudscreening/dimitri_cloud_screening_bright_rho.html#DIMITRI_CLOUD_SCREENING_BRIGHT_RHO", "DIMITRI_CLOUD_SCREENING_BRIGHT_RHO", 'routine in <a href="cloudscreening/dimitri_cloud_screening_bright_rho.html">dimitri_cloud_screening_bright_rho.pro</a>', "dimitri_cloud_screening_bright_rho.pro", "", "DIMITRI_CLOUD_SCREENING_BRIGHT_RHO", "", "VERBOSETOA_REFTOA_GEOBRIGHT_RHO", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_database_plots_wd.html", "dimitri_database_plots_wd.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_database_plots_wd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_plots_wd.html#PLOT_OBJECT_OPTION", "PLOT_OBJECT_OPTION", 'routine in <a href="hmi/dimitri_database_plots_wd.html">dimitri_database_plots_wd.pro</a>', "dimitri_database_plots_wd.pro", "", "PLOT_OBJECT_OPTION", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_plots_wd.html#PLOT_OBJECT_EXPORT", "PLOT_OBJECT_EXPORT", 'routine in <a href="hmi/dimitri_database_plots_wd.html">dimitri_database_plots_wd.pro</a>', "dimitri_database_plots_wd.pro", "", "PLOT_OBJECT_EXPORT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_plots_wd.html#PLOT_OBJECT_EXIT", "PLOT_OBJECT_EXIT", 'routine in <a href="hmi/dimitri_database_plots_wd.html">dimitri_database_plots_wd.pro</a>', "dimitri_database_plots_wd.pro", "", "PLOT_OBJECT_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_plots_wd.html#PLOTS_OBJECT_PLOT", "PLOTS_OBJECT_PLOT", 'routine in <a href="hmi/dimitri_database_plots_wd.html">dimitri_database_plots_wd.pro</a>', "dimitri_database_plots_wd.pro", "", "PLOTS_OBJECT_PLOT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_plots_wd.html#DIMITRI_DATABASE_PLOTS_WD", "DIMITRI_DATABASE_PLOTS_WD", 'routine in <a href="hmi/dimitri_database_plots_wd.html">dimitri_database_plots_wd.pro</a>', "dimitri_database_plots_wd.pro", "", "DIMITRI_DATABASE_PLOTS_WD", "", "VERBOSEVAL_SITELEADER_ID", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_database_stats_wd.html", "dimitri_database_stats_wd.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_database_stats_wd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_stats_wd.html#STATS_OBJECT_SAVE", "STATS_OBJECT_SAVE", 'routine in <a href="hmi/dimitri_database_stats_wd.html">dimitri_database_stats_wd.pro</a>', "dimitri_database_stats_wd.pro", "", "STATS_OBJECT_SAVE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_stats_wd.html#STATS_OBJECT_EXIT", "STATS_OBJECT_EXIT", 'routine in <a href="hmi/dimitri_database_stats_wd.html">dimitri_database_stats_wd.pro</a>', "dimitri_database_stats_wd.pro", "", "STATS_OBJECT_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_stats_wd.html#STATS_OBJECT_PLOT", "STATS_OBJECT_PLOT", 'routine in <a href="hmi/dimitri_database_stats_wd.html">dimitri_database_stats_wd.pro</a>', "dimitri_database_stats_wd.pro", "", "STATS_OBJECT_PLOT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_database_stats_wd.html#DIMITRI_DATABASE_STATS_WD", "DIMITRI_DATABASE_STATS_WD", 'routine in <a href="hmi/dimitri_database_stats_wd.html">dimitri_database_stats_wd.pro</a>', "dimitri_database_stats_wd.pro", "", "DIMITRI_DATABASE_STATS_WD", "", "VERBOSEGROUP_LEADER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_download_wd.html", "dimitri_download_wd.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_download_wd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_download_wd.html#DOWNLOAD_MOD_SITE", "DOWNLOAD_MOD_SITE", 'routine in <a href="hmi/dimitri_download_wd.html">dimitri_download_wd.pro</a>', "dimitri_download_wd.pro", "", "DOWNLOAD_MOD_SITE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_download_wd.html#DOWNLOAD_MOD_OPTION", "DOWNLOAD_MOD_OPTION", 'routine in <a href="hmi/dimitri_download_wd.html">dimitri_download_wd.pro</a>', "dimitri_download_wd.pro", "", "DOWNLOAD_MOD_OPTION", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_download_wd.html#DIMITRI_DOWNLOAD_WD", "DIMITRI_DOWNLOAD_WD", 'routine in <a href="hmi/dimitri_download_wd.html">dimitri_download_wd.pro</a>', "dimitri_download_wd.pro", "", "DIMITRI_DOWNLOAD_WD", "", "VERBOSEGROUP_LEADER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("doublet/dimitri_interface_doublet.html", "dimitri_interface_doublet.pro", '.pro file in <a href="doublet/dir-overview.html">doublet/ directory</a>', "dimitri_interface_doublet.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("doublet/dimitri_interface_doublet.html#DIMITRI_INTERFACE_DOUBLET", "DIMITRI_INTERFACE_DOUBLET", 'routine in <a href="doublet/dimitri_interface_doublet.html">dimitri_interface_doublet.pro</a>', "dimitri_interface_doublet.pro", "", "DIMITRI_INTERFACE_DOUBLET", "", "VERBOSEOUTPUT_FOLDERED_REGIONSENSOR1PROC_VER1SENSOR2PROC_VER2CHI_THRESHOLDDAY_OFFSETCLOUD_PERCENTAGEROI_PERCENTAGEVZA_MINVZA_MAXVAA_MINVAA_MAXSZA_MINSZA_MAXSAA_MINSAA_MAX", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/dimitri_interface_extract_toa_ncdf.html", "dimitri_interface_extract_toa_ncdf.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "dimitri_interface_extract_toa_ncdf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/dimitri_interface_extract_toa_ncdf.html#DIMITRI_INTERFACE_EXTRACT_TOA_NCDF", "DIMITRI_INTERFACE_EXTRACT_TOA_NCDF", 'routine in <a href="misc/dimitri_interface_extract_toa_ncdf.html">dimitri_interface_extract_toa_ncdf.pro</a>', "dimitri_interface_extract_toa_ncdf.pro", "", "DIMITRI_INTERFACE_EXTRACT_TOA_NCDF", "", "VERBOSESENSOR_TOA_DATANCDF_FILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("ingest/dimitri_interface_ingest.html", "dimitri_interface_ingest.pro", '.pro file in <a href="ingest/dir-overview.html">ingest/ directory</a>', "dimitri_interface_ingest.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("ingest/dimitri_interface_ingest.html#DIMITRI_INTERFACE_INGEST", "DIMITRI_INTERFACE_INGEST", 'routine in <a href="ingest/dimitri_interface_ingest.html">dimitri_interface_ingest.pro</a>', "dimitri_interface_ingest.pro", "", "DIMITRI_INTERFACE_INGEST", "", "ALLYEARCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZEENDIAN_SIZEVERBOSEINGEST_REGIONINGEST_SENSORINGEST_PROC_VER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("intercal/dimitri_interface_intercalibration.html", "dimitri_interface_intercalibration.pro", '.pro file in <a href="intercal/dir-overview.html">intercal/ directory</a>', "dimitri_interface_intercalibration.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("intercal/dimitri_interface_intercalibration.html#DIMITRI_INTERFACE_INTERCALIBRATION", "DIMITRI_INTERFACE_INTERCALIBRATION", 'routine in <a href="intercal/dimitri_interface_intercalibration.html">dimitri_interface_intercalibration.pro</a>', "dimitri_interface_intercalibration.pro", "", "DIMITRI_INTERFACE_INTERCALIBRATION", "", "ALLVERBOSEOUTPUT_FOLDERII_REGIONREF_SENSORSREF_PROC_VERSCAL_SENSORSCAL_PROC_VERSDIMITRI_BAND_IDS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("recal/dimitri_interface_recalibration.html", "dimitri_interface_recalibration.pro", '.pro file in <a href="recal/dir-overview.html">recal/ directory</a>', "dimitri_interface_recalibration.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("recal/dimitri_interface_recalibration.html#DIMITRI_INTERFACE_RECALIBRATION", "DIMITRI_INTERFACE_RECALIBRATION", 'routine in <a href="recal/dimitri_interface_recalibration.html">dimitri_interface_recalibration.pro</a>', "dimitri_interface_recalibration.pro", "", "DIMITRI_INTERFACE_RECALIBRATION", "", "ALLVERBOSEOUTPUT_FOLDERIC_REGIONREF_SENSORSREF_PROC_VERSCAL_SENSORSCAL_PROC_VERSCLOUD_PERCENTAGEROI_PERCENTAGEVZA_MINVZA_MAXVAA_MINVAA_MAXSZA_MINSZA_MAXSAA_MINSAA_MAX", "          -1", "");
  
  

libdata[libdataItem++] = new Array("brdf/dimitri_interface_roujean.html", "dimitri_interface_roujean.pro", '.pro file in <a href="brdf/dir-overview.html">brdf/ directory</a>', "dimitri_interface_roujean.pro", "", "", " NAME:       DIMITRI_INTERFACE_ROUJEAN   PURPOSE: *      INTERFACES BETWEEN THE DIMITRI HMI AND THE ROUJEAN_BRDF FUNCTION *  CALLING SEQUENCE: *      RES = DIMITRI_INTERFACE_ROUJEAN(OUTPUT_FOLDER,IB_REGIONS,IB_REF_SENSORS,IB_REF_VERS) *  INPUTS: *      OUTPUT_FOLDER     - THE FULL PATH OF THE OUTPUT FOLDER *      IB_REGION         - A STRING ARRAY OF VALIDAITON SITE NAMES (E.G. ['Uyuni'])] *      REF_SENSORS       - A STRING ARRAY CONTAINING THE SENSOR NAMES TO BE TREATED AS *                          REFERENCE SENSORS DURING BRDF COMPUTATION *      REF_PROC_VERS     - A STRING ARRAY OF THE REFERENCE SENSOR PROCESSING VERSIONS *  KEYWORDS: *      BRDF_BIN          - AN INTEGER OF THE BINNING PERIOD REQUIRED (E.G. 5 = 5 DAY BINS) *      NO_PLOTS          - SET TO STOP THE ROUTINE GENERATING BRDF PLOTS FOR EACH BAND AND EACH BIN *      ALL               - SET TO RUN BRDF COMPUTATION ON ALL COMBINATIONS OF REF-CAL *                          SENSOR PROVIDED. IF NOT SET THEN REF_SENSORS AND CAL_SENSORS *                          MUST BE THE SAME DIMENSIONS *      VERBOSE           - PROCESSING STATUS OUTPUTS *  OUTPUTS: *      STATUS            - 1: NO ERRORS REPORTED, (-1) OR 0: ERRORS DURING INGESTION *  COMMON BLOCKS: *      NONE *  MODIFICATION HISTORY: *                    - M BOUVET  - PROTOTYPE DIMITRI VERSION *        25 JAN 2011 - C KENT    - DIMITRI-2 V1.0 *        22 MAR 2011 - C KENT    - ADDED CONFIGURAITON FILE DEPENDENCE *        15 APR 2011 - C KENT    - MINOR BUG FIXES *  VALIDATION HISTORY: *        15 APR 2011 - C KENT    - WINDOWS 32-BIT IDL 7.1 AND LINUX 64-BIT IDL 8.0 NOMINAL *                                  COMPILATION AND OPERATION. TESTED ON MERIS 2ND REPROCESSING *                                  WITH MERIS 3RD REPROCESSING AND MODISA COLLECTION 5  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("brdf/dimitri_interface_roujean.html#DIMITRI_INTERFACE_ROUJEAN", "DIMITRI_INTERFACE_ROUJEAN", 'routine in <a href="brdf/dimitri_interface_roujean.html">dimitri_interface_roujean.pro</a>', "dimitri_interface_roujean.pro", "", "DIMITRI_INTERFACE_ROUJEAN", "", "BRDF_BINBRDF_LIMNO_PLOTSALLVERBOSEOUTPUT_FOLDERIB_REGIONSIB_REF_SENSORSIB_REF_VERS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_new_site_wd.html", "dimitri_new_site_wd.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_new_site_wd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_new_site_wd.html#NEW_SITE_TYPE_CHANGE", "NEW_SITE_TYPE_CHANGE", 'routine in <a href="hmi/dimitri_new_site_wd.html">dimitri_new_site_wd.pro</a>', "dimitri_new_site_wd.pro", "", "NEW_SITE_TYPE_CHANGE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_new_site_wd.html#NEW_SITE_EVENT_GO", "NEW_SITE_EVENT_GO", 'routine in <a href="hmi/dimitri_new_site_wd.html">dimitri_new_site_wd.pro</a>', "dimitri_new_site_wd.pro", "", "NEW_SITE_EVENT_GO", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_new_site_wd.html#NEW_SITE_EVENT_EXIT", "NEW_SITE_EVENT_EXIT", 'routine in <a href="hmi/dimitri_new_site_wd.html">dimitri_new_site_wd.pro</a>', "dimitri_new_site_wd.pro", "", "NEW_SITE_EVENT_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_new_site_wd.html#DIMITRI_NEW_SITE_WD", "DIMITRI_NEW_SITE_WD", 'routine in <a href="hmi/dimitri_new_site_wd.html">dimitri_new_site_wd.pro</a>', "dimitri_new_site_wd.pro", "", "DIMITRI_NEW_SITE_WD", "", "VERBOSEGROUP_LEADER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("intercal/dimitri_polynomial_fit_function.html", "dimitri_polynomial_fit_function.pro", '.pro file in <a href="intercal/dir-overview.html">intercal/ directory</a>', "dimitri_polynomial_fit_function.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("intercal/dimitri_polynomial_fit_function.html#DIMITRI_POLYNOMIAL_FIT_FUNCTION", "DIMITRI_POLYNOMIAL_FIT_FUNCTION", 'routine in <a href="intercal/dimitri_polynomial_fit_function.html">dimitri_polynomial_fit_function.pro</a>', "dimitri_polynomial_fit_function.pro", "", "DIMITRI_POLYNOMIAL_FIT_FUNCTION", "", "VERBOSEXPYMOD", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_rsr_colours.html", "dimitri_rsr_colours.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_rsr_colours.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_rsr_colours.html#DIMITRI_RSR_COLOURS", "DIMITRI_RSR_COLOURS", 'routine in <a href="hmi/dimitri_rsr_colours.html">dimitri_rsr_colours.pro</a>', "dimitri_rsr_colours.pro", "", "DIMITRI_RSR_COLOURS", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/dimitri_sade_interface_routines_p1.html", "dimitri_sade_interface_routines_p1.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "dimitri_sade_interface_routines_p1.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/dimitri_sade_interface_routines_p1.html#DIMITRI_SADE_INTERFACE_ROUTINES_P1", "DIMITRI_SADE_INTERFACE_ROUTINES_P1", 'routine in <a href="sade/dimitri_sade_interface_routines_p1.html">dimitri_sade_interface_routines_p1.pro</a>', "dimitri_sade_interface_routines_p1.pro", "", "DIMITRI_SADE_INTERFACE_ROUTINES_P1", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/dimitri_sade_interface_routines_p2.html", "dimitri_sade_interface_routines_p2.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "dimitri_sade_interface_routines_p2.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/dimitri_sade_interface_routines_p2.html#DIMITRI_SADE_INTERFACE_ROUTINES_P2", "DIMITRI_SADE_INTERFACE_ROUTINES_P2", 'routine in <a href="sade/dimitri_sade_interface_routines_p2.html">dimitri_sade_interface_routines_p2.pro</a>', "dimitri_sade_interface_routines_p2.pro", "", "DIMITRI_SADE_INTERFACE_ROUTINES_P2", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_v2.html", "dimitri_v2.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_v2.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_v2.html#DHMI_OBJECT_EVENT", "DHMI_OBJECT_EVENT", 'routine in <a href="hmi/dimitri_v2.html">dimitri_v2.pro</a>', "dimitri_v2.pro", "", "DHMI_OBJECT_EVENT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_v2.html#DHMI_BUTTON_EVENT", "DHMI_BUTTON_EVENT", 'routine in <a href="hmi/dimitri_v2.html">dimitri_v2.pro</a>', "dimitri_v2.pro", "", "DHMI_BUTTON_EVENT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_v2.html#DHMI_EXIT_EVENT", "DHMI_EXIT_EVENT", 'routine in <a href="hmi/dimitri_v2.html">dimitri_v2.pro</a>', "dimitri_v2.pro", "", "DHMI_EXIT_EVENT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_v2.html#DIMITRI_V2", "DIMITRI_V2", 'routine in <a href="hmi/dimitri_v2.html">dimitri_v2.pro</a>', "dimitri_v2.pro", "", "DIMITRI_V2", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation.html", "dimitri_visualisation.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation.html#VISU_OBJECT_EVENT", "VISU_OBJECT_EVENT", 'routine in <a href="hmi/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "VISU_OBJECT_EVENT", "", "VERBOSEEVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation.html#STATS_TABLE_EVENT", "STATS_TABLE_EVENT", 'routine in <a href="hmi/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "STATS_TABLE_EVENT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation.html#STATS_TABLE_RESIZE", "STATS_TABLE_RESIZE", 'routine in <a href="hmi/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "STATS_TABLE_RESIZE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation.html#VISU_OBJECT_OPTION", "VISU_OBJECT_OPTION", 'routine in <a href="hmi/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "VISU_OBJECT_OPTION", "", "VERBOSEEVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation.html#VISU_OBJECT_EXPORT", "VISU_OBJECT_EXPORT", 'routine in <a href="hmi/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "VISU_OBJECT_EXPORT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation.html#VISU_OBJECT_EXIT", "VISU_OBJECT_EXIT", 'routine in <a href="hmi/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "VISU_OBJECT_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation.html#DIMITRI_VISUALISATION", "DIMITRI_VISUALISATION", 'routine in <a href="hmi/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "DIMITRI_VISUALISATION", "", "VERBOSEGROUP_LEADEROUTPUTFOLDERREGIONDIMITRI_BANDREF_SENSORREF_PROC_VER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/old_visu/dimitri_visualisation.html", "dimitri_visualisation.pro", '.pro file in <a href="hmi/old_visu/dir-overview.html">hmi/old_visu/ directory</a>', "dimitri_visualisation.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/old_visu/dimitri_visualisation.html#VISU_OBJECT_EVENT", "VISU_OBJECT_EVENT", 'routine in <a href="hmi/old_visu/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "VISU_OBJECT_EVENT", "", "VERBOSEEVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/old_visu/dimitri_visualisation.html#STATS_TABLE_EVENT", "STATS_TABLE_EVENT", 'routine in <a href="hmi/old_visu/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "STATS_TABLE_EVENT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/old_visu/dimitri_visualisation.html#STATS_TABLE_RESIZE", "STATS_TABLE_RESIZE", 'routine in <a href="hmi/old_visu/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "STATS_TABLE_RESIZE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/old_visu/dimitri_visualisation.html#VISU_OBJECT_OPTION", "VISU_OBJECT_OPTION", 'routine in <a href="hmi/old_visu/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "VISU_OBJECT_OPTION", "", "VERBOSEEVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/old_visu/dimitri_visualisation.html#VISU_OBJECT_EXPORT", "VISU_OBJECT_EXPORT", 'routine in <a href="hmi/old_visu/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "VISU_OBJECT_EXPORT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/old_visu/dimitri_visualisation.html#VISU_OBJECT_EXIT", "VISU_OBJECT_EXIT", 'routine in <a href="hmi/old_visu/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "VISU_OBJECT_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/old_visu/dimitri_visualisation.html#DIMITRI_VISUALISATION", "DIMITRI_VISUALISATION", 'routine in <a href="hmi/old_visu/dimitri_visualisation.html">dimitri_visualisation.pro</a>', "dimitri_visualisation.pro", "", "DIMITRI_VISUALISATION", "", "VERBOSEGROUP_LEADEROUTPUTFOLDERREGIONDIMITRI_BANDREF_SENSORREF_PROC_VER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_angles.html", "dimitri_visualisation_angles.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation_angles.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_angles.html#DIMITRI_VISUALISATION_ANGLES", "DIMITRI_VISUALISATION_ANGLES", 'routine in <a href="hmi/dimitri_visualisation_angles.html">dimitri_visualisation_angles.pro</a>', "dimitri_visualisation_angles.pro", "", "DIMITRI_VISUALISATION_ANGLES", "", "VERBOSEED_FOLDERVA_REGIONREF_SENSORREF_PROC_VER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_brdf_rho.html", "dimitri_visualisation_brdf_rho.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation_brdf_rho.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_brdf_rho.html#DIMITRI_VISUALISATION_BRDF_RHO", "DIMITRI_VISUALISATION_BRDF_RHO", 'routine in <a href="hmi/dimitri_visualisation_brdf_rho.html">dimitri_visualisation_brdf_rho.pro</a>', "dimitri_visualisation_brdf_rho.pro", "", "DIMITRI_VISUALISATION_BRDF_RHO", "", "SR_FOLDERSR_REGIONREF_SENSORREF_PROC_VERDIMITRI_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_old.html", "dimitri_visualisation_old.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation_old.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_old.html#VISU_OBJECT_EVENT", "VISU_OBJECT_EVENT", 'routine in <a href="hmi/dimitri_visualisation_old.html">dimitri_visualisation_old.pro</a>', "dimitri_visualisation_old.pro", "", "VISU_OBJECT_EVENT", "", "VERBOSEEVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_old.html#STATS_TABLE_EVENT", "STATS_TABLE_EVENT", 'routine in <a href="hmi/dimitri_visualisation_old.html">dimitri_visualisation_old.pro</a>', "dimitri_visualisation_old.pro", "", "STATS_TABLE_EVENT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_old.html#STATS_TABLE_RESIZE", "STATS_TABLE_RESIZE", 'routine in <a href="hmi/dimitri_visualisation_old.html">dimitri_visualisation_old.pro</a>', "dimitri_visualisation_old.pro", "", "STATS_TABLE_RESIZE", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_old.html#VISU_OBJECT_OPTION", "VISU_OBJECT_OPTION", 'routine in <a href="hmi/dimitri_visualisation_old.html">dimitri_visualisation_old.pro</a>', "dimitri_visualisation_old.pro", "", "VISU_OBJECT_OPTION", "", "VERBOSEEVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_old.html#VISU_OBJECT_EXPORT", "VISU_OBJECT_EXPORT", 'routine in <a href="hmi/dimitri_visualisation_old.html">dimitri_visualisation_old.pro</a>', "dimitri_visualisation_old.pro", "", "VISU_OBJECT_EXPORT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_old.html#VISU_OBJECT_EXIT", "VISU_OBJECT_EXIT", 'routine in <a href="hmi/dimitri_visualisation_old.html">dimitri_visualisation_old.pro</a>', "dimitri_visualisation_old.pro", "", "VISU_OBJECT_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_old.html#DIMITRI_VISUALISATION", "DIMITRI_VISUALISATION", 'routine in <a href="hmi/dimitri_visualisation_old.html">dimitri_visualisation_old.pro</a>', "dimitri_visualisation_old.pro", "", "DIMITRI_VISUALISATION", "", "VERBOSEGROUP_LEADEROUTPUTFOLDERREGIONDIMITRI_BANDREF_SENSORREF_PROC_VER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_polynomial.html", "dimitri_visualisation_polynomial.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation_polynomial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_polynomial.html#DIMITRI_VISUALISATION_POLYNOMIAL", "DIMITRI_VISUALISATION_POLYNOMIAL", 'routine in <a href="hmi/dimitri_visualisation_polynomial.html">dimitri_visualisation_polynomial.pro</a>', "dimitri_visualisation_polynomial.pro", "", "DIMITRI_VISUALISATION_POLYNOMIAL", "", "VERBOSEIC_FOLDERIC_REGIONDIMITRI_WLREF_SENSORREF_PROC_VERNEW_X_INFOSENS_CONFIGS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_recalibration.html", "dimitri_visualisation_recalibration.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation_recalibration.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_recalibration.html#DIMITRI_VISUALISATION_RECALIBRATION", "DIMITRI_VISUALISATION_RECALIBRATION", 'routine in <a href="hmi/dimitri_visualisation_recalibration.html">dimitri_visualisation_recalibration.pro</a>', "dimitri_visualisation_recalibration.pro", "", "DIMITRI_VISUALISATION_RECALIBRATION", "", "VERBOSERC_FOLDERVR_REGIONDIMITRI_BANDREF_SENSORREF_PROC_VERSENS_CONFIGS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_reflectance.html", "dimitri_visualisation_reflectance.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation_reflectance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_reflectance.html#DIMITRI_VISUALISATION_REFLECTANCE", "DIMITRI_VISUALISATION_REFLECTANCE", 'routine in <a href="hmi/dimitri_visualisation_reflectance.html">dimitri_visualisation_reflectance.pro</a>', "dimitri_visualisation_reflectance.pro", "", "DIMITRI_VISUALISATION_REFLECTANCE", "", "VERBOSEED_FOLDERVR_REGIONDIMITRI_BANDREF_SENSORREF_PROC_VER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_super_rho.html", "dimitri_visualisation_super_rho.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation_super_rho.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_super_rho.html#DIMITRI_VISUALISATION_SUPER_RHO", "DIMITRI_VISUALISATION_SUPER_RHO", 'routine in <a href="hmi/dimitri_visualisation_super_rho.html">dimitri_visualisation_super_rho.pro</a>', "dimitri_visualisation_super_rho.pro", "", "DIMITRI_VISUALISATION_SUPER_RHO", "", "VERBOSERC_FOLDERRC_REGIONREF_SENSORREF_PROC_VERDIMITRI_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_vgt_rho.html", "dimitri_visualisation_vgt_rho.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "dimitri_visualisation_vgt_rho.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/dimitri_visualisation_vgt_rho.html#DIMITRI_VISUALISATION_VGT_RHO", "DIMITRI_VISUALISATION_VGT_RHO", 'routine in <a href="hmi/dimitri_visualisation_vgt_rho.html">dimitri_visualisation_vgt_rho.pro</a>', "dimitri_visualisation_vgt_rho.pro", "", "DIMITRI_VISUALISATION_VGT_RHO", "", "VERBOSESL_FOLDERSL_REGIONDIMITRI_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/distance_from_land.html", "distance_from_land.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "distance_from_land.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/distance_from_land.html#DISTANCE_FROM_LAND", "DISTANCE_FROM_LAND", 'routine in <a href="validation/distance_from_land.html">distance_from_land.pro</a>', "distance_from_land.pro", "", "DISTANCE_FROM_LAND", "", "PIXEL_LATPIXEL_LON", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/envisat.html", "envisat.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "envisat.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_DEFINE_CONSTANTS", "ENVISAT_DEFINE_CONSTANTS", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_DEFINE_CONSTANTS", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_MJD__DEFINE", "ENVISAT_MJD__DEFINE", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_MJD__DEFINE", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_BILINEAR", "ENVISAT_BILINEAR", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_BILINEAR", "", "EXTRAPOLATEPIXJY", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_GET_VALUE", "ENVISAT_GET_VALUE", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_GET_VALUE", "", "TOKEN", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_GET_HEADER", "ENVISAT_GET_HEADER", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_GET_HEADER", "", "NAMEN_TAGSUNITLENGTHOFFSET", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_INDEX_DSD", "ENVISAT_INDEX_DSD", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_INDEX_DSD", "", "N_TAGSADSGADSMDSREFERENCENAMEDSD", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_LEAPYEAR", "ENVISAT_LEAPYEAR", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_LEAPYEAR", "", "YEAR", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_JDAY_TO_DAY", "ENVISAT_JDAY_TO_DAY", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_JDAY_TO_DAY", "", "YEARJDAYMONTHDAY", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_MJD_TO_JDAY", "ENVISAT_MJD_TO_JDAY", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_MJD_TO_JDAY", "", "INTEGERMJDYEARJDAY", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_MJD_TO_TIME", "ENVISAT_MJD_TO_TIME", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_MJD_TO_TIME", "", "DECIMAL_PLACESMJDDATETIME", "          -1", "");
  
  libdata[libdataItem++] = new Array("aatsr/envisat.html#ENVISAT_READ_DS", "ENVISAT_READ_DS", 'routine in <a href="aatsr/envisat.html">envisat.pro</a>', "envisat.pro", "", "ENVISAT_READ_DS", "", "OFFSETSIZEUNITDSDRECORD", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/extract_dimitri_rsr.html", "extract_dimitri_rsr.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "extract_dimitri_rsr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/extract_dimitri_rsr.html#EXTRACT_DIMITRI_RSR", "EXTRACT_DIMITRI_RSR", 'routine in <a href="misc/extract_dimitri_rsr.html">extract_dimitri_rsr.pro</a>', "extract_dimitri_rsr.pro", "", "EXTRACT_DIMITRI_RSR", "", "VERBOSEDATAWL_ARRAY", "          -1", "");
  
  

libdata[libdataItem++] = new Array("doublet/extract_doublets.html", "extract_doublets.pro", '.pro file in <a href="doublet/dir-overview.html">doublet/ directory</a>', "extract_doublets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("doublet/extract_doublets.html#EXTRACT_DOUBLETS", "EXTRACT_DOUBLETS", 'routine in <a href="doublet/extract_doublets.html">extract_doublets.pro</a>', "extract_doublets.pro", "", "EXTRACT_DOUBLETS", "", "VERBOSESADE1SADE2SADEOUTPUTOFOLDERED_REGIONSENSOR1PROC_VER1SENSOR2PROC_VER2AMC_THRESHOLDDAY_OFFSETCLOUD_PERCENTAGEROI_PERCENTAGEVZA_MINVZA_MAXVAA_MINVAA_MAXSZA_MINSZA_MAXSAA_MINSAA_MAX", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/fileinfo.html", "fileinfo.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "fileinfo.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/fileinfo.html#FILEINFO", "FILEINFO", 'routine in <a href="misc/fileinfo.html">fileinfo.pro</a>', "fileinfo.pro", "", "FILEINFO", " NAME:     FILEINFO   PURPOSE:     Return information about a file.   CATEGORY:     File utilities.   CALLING SEQUENCE:     RESULT = FILEINFO(FILE)   INPUTS:     FILE    Name of file   OPTIONAL INPUTS:     None.   KEYWORD PARAMETERS:     None.   OUTPUTS:     An anonymous structure containing information about the file.     The fields in the structure are as follows:     NAME     String containing the name of the file     EXIST    1 if file exists, 0 otherwise.     READ     1 if file can be read, 0 otherwise.     WRITE    1 if file can be written, 0 otherwise.     HDF      1 if file is HDF format, 0 otherwise              (0 if HDF API is not available).     NETCDF   1 if file is netCDF format, 0 otherwise              (0 if netCDF API is not available).     SIZE     File size in bytes              (-1 if file does not exist, or if file cannot be read).   OPTIONAL OUTPUTS:     None   COMMON BLOCKS:     None   SIDE EFFECTS:     None.   RESTRICTIONS:     Requires IDL 5.0 or higher (square bracket array syntax).   EXAMPLE:  ;- Check an existing file file = filepath('hurric.dat', subdir='examples/data') help, fileinfo(file), /structure  ;- Check a new file file = 'zztest.dat' help, fileinfo(file), /structure   MODIFICATION HISTORY:  Liam.Gumley@ssec.wisc.edu  http://cimss.ssec.wisc.edu/~gumley  $Id: fileinfo.pro,v 1.1 2003/06/30 20:27:21 gumley Exp $   Copyright (C) 1999, 2000 Liam E. Gumley   This program is free software; you can redistribute it and/or  modify it under the terms of the GNU General Public License  as published by the Free Software Foundation; either version 2  of the License, or (at your option) any later version.   This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License for more details.   You should have received a copy of the GNU General Public License  along with this program; if not, write to the Free Software  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  ", "FILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/fsc_field.html", "fsc_field.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "fsc_field.pro", "", "", " NAME:    FSC_FIELD   PURPOSE:     The purpose of this compound widget is to provide an alternative    to the CW_FIELD widget offered in the IDL distribution. One weakness    of the CW_FIELD compound widget is that the text widgets do not    look editable to the users on Windows platforms. This program    corrects that deficiency and adds some features that I think    will be helpful. For example, you can now assign an event handler    to the compound widget, ask for positive numbers only, and limit    the number of digits in a number, or the number of digits to the    right of a decimal point. The program is written as a widget object,    which allows the user to call object methods directly, affording    even more flexibility in use. This program replaces the earlier    programs FSC_INPUTFIELD and COYOTE_FIELD.     The program consists of a label widget next to a one-line text widget.    The  value  of the compound widget is shown in the text widget. If the    value is a number, it will not be possible (generally) to type    alphanumeric values in the text widget. String values behave like    strings in any one-line text widget.   AUTHOR:     FANNING SOFTWARE CONSULTING    David Fanning, Ph.D.    1645 Sheely Drive    Fort Collins, CO 80526 USA    Phone: 970-221-0438    E-mail: davidf@dfanning.com    Coyote's Guide to IDL Programming: http://www.dfanning.com/   CATEGORY:     General programming.   TYPICAL CALLING SEQUENCE:     fieldID = FSC_FIELD(parent, Title= X Size: , Value=256, Object=fieldObject, Digits=3)   INPUT PARAMETERS:     parent -- The parent widget ID of the compound widget. Required.   INPUT KEYWORDS:     COLUMN        Set this keyword to have the Label widget above the Text widget.                  The default is to have the Label widget in a row with the Text widget.     CR_ONLY       Set this keyword if you only want Carriage Return events returned to                  your event handler. If this keyword is not set, all events are returned.                  Setting this keyword has no effect unless either the EVENT_PRO or                  EVENT_FUNC keyword is used.     DECIMAL       Set this keyword to the number of digits to the right of the decimal                  point in floating point or double precision numbers. Ignored for STRING values.     DIGITS        Set this keyword to the number of digits permitted in integer numbers.     EVENT_FUNC    Set this keyword to the name of an event handler function. If this                  keyword is undefined and the Event_Pro keyword is undefined,                  all compound widget events are handled internally and not                  passed on to the parent widget.     EVENT_PRO     Set this keyword to the name of an event handler procedure. If this                  keyword is undefined and the Event_Func keyword is undefined,                  all compound widget events are handled internally and not                  passed on to the parent widget.     FIELDFONT     The font name for the text in the text widget.     FRAME         Set this keyword to put a frame around the compound widget.     FOCUS_EVENTS  Set this keyword to enable event generation for keyboard focus                  events. Ignored unless EVENT_FUNC or EVENT_PRO keywords are specified.     HIGHLIGHT     Set this keyword to highlight the existing text if the widget gain                  the keyboard focus. This keyword MUST be set for tabbing to work naturally                  in IDL 6.2 and higher.     LABEL_LEFT    Set this keyword to align the text on the label to the left.     LABEL_RIGHT   Set this keyword to align the text on the label to the right.     LABELFONT     The font name for the text in the label widget.     LABELSIZE     The X screen size of the label widget.     NAME          A string containing the name of the object. The default is ''.     NOEDIT        Set this keyword to allow no user editing of the input text widget.     NONSENSITIVE  Set this keyword to make the input text widget non-sensitive.     POSITIVE      Set this keyword if you want only positive numbers allowed.     SCR_XSIZE     The X screen size of the compound widget.     SCR_YSIZE     The Y screen size of the compound widget.     TITLE         The string text placed on the label widget.     UNDEFINED     Set this keyword to the value to use for  undefined  values. If                  not set, then !Value.F_NAN is used for numerical fields and a                  NULL string is used for string fields. This applies to values                  obtained with the GET_VALUE method or the GET_VALUE function.     UVALUE        A user value for any purpose.     VALUE         The  value  of the compound widget. Any type of integer, floating, or string                  variable is allowed. The data  type  is determined automatically from the                  value supplied with this keyword. Be sure you set the type appropriately for                  your intended use of the value.     XSIZE         The X size of the text widget in the usual character units.   OUTPUT KEYWORDS:     OBJECT        Set this keyword to a named variable to receive the compound widget's                  object reference. This is required if you wish to call methods on the object.                  Note that the object reference is also available in the event structure                  generated by the widget object. Note that the object reference will be                  necessary if you want to get or set values in the compound widget.   COMMON BLOCKS:     None.   RESTRICTIONS:     Requires DBLTOSTR from the Coyote Library:       http://www.dfanning.com/programs/dbltostr.pro   EVENT STRUCTURE:     All events are handled internally unless either the Event_Pro or Event_Func    keywords are used to assign an event handler to the compound widget. By    default all events generated by the text widget are passed to the assigned    event handler. If you wish to receive only Carriage Return events, set the    CR_Only keyword.     event = { FSC_FIELD_EVENT, $   ; The name of the event structure.              ID: 0L, $            ; The ID of the compound widget's top-level base.              TOP: 0L, $           ; The widget ID of the top-level base of the hierarchy.              HANDLER: 0L, $       ; The event handler ID. Filled out by IDL.              OBJECT: Obj_New(), $ ; The  self  object reference. Provided so you can call methods.              VALUE: Ptr_New(), $  ; A pointer to the widget value.              TYPE:                ; A string indicating the type of data in the VALUE field.            }     Note that if the field is  empty , the VALUE will be a pointer    to an undefined variable. You should check this value before you    use it. You code will look something like this:       IF N_Elements(*event.value) EQ 0 THEN $          Print, 'Current Value UNDEFINED.' ELSE $          Print, 'Current Value: ', *event.value   GETTING and SETTING VALUES:     Almost all the properties of the widget can be obtained or set via    the object's GetProperty and SetProperty methods (described below).    Traditional compound widgets have the ability to get and set the  value     of the compound widget identifier (e.g., fieldID in the calling    sequence above). Unfortunately, it is impossible to retreive a variable    in this way when the variable is undefined. In practical terms, this    means that the undefined variable must be set to *something*. You can    determine what that something is with the UNDEFINED keyword, or I will set    it to !VALUES.F_NAN for numerical fields and to the null string for string    fields. In any case, you will have to check for undefined variables before    you try to do something with the value. For a numerical field, the code    might look something like this:        fieldID = FSC_FIELD(parent, Title= X Size: , Value=256, Object=fieldObject, Digits=3)       currentValue = fieldObject-&gt;Get_Value()       IF Finite(currentValue) EQ 0 THEN Print, 'Value is Undefined' ELSE Print, currentValue     Additional examples are provided in the numerical example fields in Example Program below.     Setting the value of the compound widget is the same as calling the Set_Value    method on the object reference. In other words, these two statements are equivalent.          fieldObject-&gt;Set_Value, 45.4         Widget_Control, fieldID, Set_Value=45.4     The data type of the value is determined from the value itself. Be sure you set it appropriately.   OBJECT PROCEDURE METHODS:     GetProperty -- This method allows various properties of the widget to be        returned via output keywords. The keywords that are available are:         CR_Only -- A flag, if set, means only report carriage return events.        DataType -- The data type of the field variable.        Decimal -- Set this keyword to the number of digits to the right of the decimal               point in FLOATVALUE and DOUBLEVALUE numbers.        Digits -- Set this keyword to the number of digits permitted in INTERGERVALUE and LONGVALUE numbers.        Event_Func -- The name of the event handler function.        Event_Pro -- The name of the event handler function.        Has_Focus -- Set to 1 if the text widget currently has the keyboard focus.        Highlight -- The highlight flag.        NoEdit -- The NoEdit flag.        NonSensitive -- The NonSensitive flag.        Undefined -- The  value  of any undefined value.        UValue -- The user value assigned to the compound widget.        Value -- The  value  of the compound widget.      Name -- A scalar string name of the object.     Resize -- This method allows you to resize the compound widget's text field.         The value parameter is an X screen size for the entire widget. The text         widget is sized by using the value obtained from this value minus the         X screen size of the label widget.            objectRef-&gt;Resize, screen_xsize_value     Set_Value -- This method allows you to set the  value  of the field. It takes        one positional parameter, which is the value.            objectRef-&gt;Set_Value, 5     SetProperty -- This method allows various properties of the widget to be        set via input keywords. The keywords that are available are:         CR_Only -- Set this keyword if you only want Carriage Return events.        Decimal -- Set this keyword to the number of digits to the right of the decimal               point in FLOAT and DOUBLE numbers.        Digits -- Set this keyword to the number of digits permitted in INTERGER and LONG numbers.        Event_Func -- Set this keyword to the name of an Event Function.        Event_Pro -- Set this keyword to the name of an Event Procedure.        Highlight -- Set this keyword to highlight the existing text                     when the widget gets the keyboard focus        LabelSize --  The X screen size of the Label Widget.        Name -- A scalar string name of the object. (default = '')        NoEdit -- Set this keyword to make the text widget uneditable        NonSensitive -- Set this keyword to make the widget nonsensitive        Scr_XSize -- The X screen size of the text widget.        Scr_YSize -- The Y screen size of the text widget.        Title -- The text to go on the Label Widget.        UValue -- A user value for any purpose.        Value -- The  value  of the compound widget.        XSize -- The X size of the Text Widget.     SetTabNext -- This method allows you to specify which field to go to when a TAB character       is typed in the text widget. See the Example program below for an example of how to       use this method.   OBJECT FUNCTIONS METHODS:        Get_Value -- Returns the  value  of the field. No parameters. Will be undefined           if a  number  field is blank. Should be checked before using:            IF N_Elements(objectRef-&gt;Get_Value()) NE 0 THEN Print, Value is: ', objectRef-&gt;Get_Value()        GetID -- Returns the widget identifier of the compound widget's top-level base.          (The first child of the parent widget.) No parameters.        GetLabelSize -- Returns the X screen size of the label widget. No parameters.        GetTextID -- Returns the widget identifier of the compound widget's text widget.          No parameters.        GetTextSize -- Returns the X screen size of the text widget. No parameters.   PRIVATE OBJECT METHODS:     Although there is really no such thing as a  private  method in IDL's    object implementation, some methods are used internally and not meant to    be acessed publicly. Here are a few of those methods. I list them because    it may be these private methods are ones you wish to override in subclassed    objects.        MoveTab -- This method moves the focus to the widget identified in the  next  field,         which must be set with the SetTabNext method. No parameters. Called automatically         when a TAB character is typed in the text widget.        Text_Events -- The main event handler method for the compound widget. All         text widget events are processed here.        ReturnValue -- This function method accepts a string input value and converts         it to the type of data requested by the user.        Validate -- This function method examines all text input and removes unwanted         characters, depending upon the requested data type for the field. It makes it         impossible, for example, to type alphanumeric characters in an INTEGER field.   EXAMPLE:     An example program is provided at the end of the FSC_FIELD code. To run it,    type these commands:        IDL&gt; .Compile FSC_Field       IDL&gt; Example   MODIFICATION HISTORY:     Written by: David W. Fanning, 18 October 2000. Based heavily on an earlier       FSC_INPUTFIELD program and new ideas about the best way to write       widget objects.    Added LABEL_LEFT, LABEL_RIGHT, and UNDEFINED keywords. 29 Dec 2000. DWF.    Modified the way the value is returned in the GET_VALUE method and the       GET_VALUE function. Modified Example program to demonstrate. 30 Dec 2000. DWF.    Added NOEDIT and NONSENSITIVE keywords, with corresponding SETEDIT and SETSENNSITIVE       methods. 19 Jan 2001. DWF.    Actually followed through with the changes I _said_  I made 29 Dec 2000. (Don't ask....) 13 June 2001. DWF.    Added GetTextSize and GetLabelSize methods for obtaining the X screen       size of the text and label widgets, respectively. 21 July 2001. DWF.    Fixed a problem in SetProperty method where I was setting self.xsize, which doesn't exist. 24 April 2002. DWF.    Small modification to the SetEdit method. 6 August 2003. DWF.    Added Highlight keyword. Ported Focus_Events keyword from       fsc_inputfield.pro. Updated documentation. 17 November       2004. DWF and Benjamin Hornberger    Added Has_Focus keyword to the GetProperty method. 18 November       2004. Benjamin Hornberger    Fixed bug in GetProperty method (set value to *self.undefined if       *self.value is undefined. 24 Feb 2004. Benjamin Hornberger    Modified FOCUS_EVENTS keyword handling so that *all* focus events are now       passed to specified event handlers. Check event.select to see if the       widget is gaining or losing focus. 10 August 2005. DWF.    Added new tabbing functionality, introduced in IDL 6.2. To use tabbing       functionality natually, the HIGHTLIGHT keywords must be set.       See included EXAMPLE program for details. 10 August 2005. DWF.    Added functionality to covert double precision values to strings properly. 30 Nov 2005. DWF.    Set the default fonts to be the current widget font, rather than the default widget font. 4 Oct 2008. DWF.    Fixed a problem with validating a float or double value when it was written with       exponential notation. 2 April 2010. DWF.  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field_WidgetFont", "FSC_Field_WidgetFont", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field_WidgetFont", "", "DEFAULT", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field_Error_Message", "FSC_Field_Error_Message", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field_Error_Message", "", "TracebackNoName_ExtratheMessage", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::GetLabelSize", "FSC_Field::GetLabelSize", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::GetLabelSize", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::GetTextSize", "FSC_Field::GetTextSize", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::GetTextSize", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::MoveTab", "FSC_Field::MoveTab", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::MoveTab", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::SetTabNext", "FSC_Field::SetTabNext", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::SetTabNext", "", "nextID", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::GetTextID", "FSC_Field::GetTextID", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::GetTextID", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::Resize", "FSC_Field::Resize", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::Resize", "", "newsize", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::GetID", "FSC_Field::GetID", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::GetID", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::Geometry", "FSC_Field::Geometry", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::Geometry", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::Get_Value", "FSC_Field::Get_Value", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::Get_Value", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::Set_Value", "FSC_Field::Set_Value", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::Set_Value", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::Validate", "FSC_Field::Validate", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::Validate", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::ReturnValue", "FSC_Field::ReturnValue", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::ReturnValue", "", "inputValue", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::TextEvents", "FSC_Field::TextEvents", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::TextEvents", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::GetProperty", "FSC_Field::GetProperty", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::GetProperty", "", "CR_OnlyDataTypeDecimalDigitsEvent_FuncEvent_ProFocus_EventsHas_FocusHighlightNameNoEditNonSensitiveUndefinedUValueValue", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::SetProperty", "FSC_Field::SetProperty", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::SetProperty", "", "CR_OnlyDecimalDigitsEvent_FuncEvent_ProFocus_EventsHighlightLabelSizeNameNoEditNonSensitiveScr_XSizeScr_YSizeTitleUndefinedUValueValueXSize", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::SetEdit", "FSC_Field::SetEdit", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::SetEdit", "", "editvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::SetSensitive", "FSC_Field::SetSensitive", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::SetSensitive", "", "value", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::INIT", "FSC_Field::INIT", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::INIT", "", "ColumnCR_OnlyDecimalDigitsEvent_FuncEvent_Pro_ExtraFieldFontFocus_EventsFrameHighlightLabel_LeftLabel_RightLabelFontLabelSizeNameNoEditNonSensitivePositiveScr_XSizeScr_YSizeTitleUndefinedUValueValueXSizeparent", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field::CLEANUP", "FSC_Field::CLEANUP", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field::CLEANUP", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field_Event_Handler", "FSC_Field_Event_Handler", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field_Event_Handler", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field_Event__Define", "FSC_Field_Event__Define", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field_Event__Define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field_Set_Compound_Widget_Value", "FSC_Field_Set_Compound_Widget_Value", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field_Set_Compound_Widget_Value", "", "tlbvalue", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field_Get_Compound_Widget_Value", "FSC_Field_Get_Compound_Widget_Value", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field_Get_Compound_Widget_Value", "", "tlb", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field_Kill_Notify", "FSC_Field_Kill_Notify", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field_Kill_Notify", "", "textID", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_Field__Define", "FSC_Field__Define", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_Field__Define", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#FSC_FIELD", "FSC_FIELD", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "FSC_FIELD", "", "ColumnCR_OnlyDecimalDigitsEvent_FuncEvent_Pro_ExtraFieldFontFocus_EventsFrameHighlightLabel_LeftLabel_RightLabelFontLabelSizeNameNoEditNonSensitiveObjectPositiveScr_XSizeScr_YSizeTitleUndefinedUValueValueXSizeparent", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#Example_Event", "Example_Event", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "Example_Event", "", "event", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/fsc_field.html#Example", "Example", 'routine in <a href="misc/fsc_field.html">fsc_field.pro</a>', "fsc_field.pro", "", "Example", "", "field1field2field3", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/get_aatsr_aux_files.html", "get_aatsr_aux_files.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "get_aatsr_aux_files.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/get_aatsr_aux_files.html#GET_AATSR_AUX_FILES", "GET_AATSR_AUX_FILES", 'routine in <a href="aatsr/get_aatsr_aux_files.html">get_aatsr_aux_files.pro</a>', "get_aatsr_aux_files.pro", "", "GET_AATSR_AUX_FILES", "* NAME: *      GET_AATSR_AUX_FILES * * PURPOSE: *      RETURNS A STRING ARRAY OF AATSR L1B AUXILIARY FILES * * CALLING SEQUENCE: *      RES = GET_AATSR_AUX_FILES(FILENAME,/VERBOSE) * * INPUTS: *      FILENAME - FULL PATH OF THE FILE TO BE ANALYSED * * KEYWORDS: *      VERBOSE - PROCESSING STATUS OUTPUTS * * OUTPUTS: *      AUX_FILES - A STRING ARRAY CONTAINING THE AUXILIARY FILENAME INFORMATION * * COMMON BLOCKS: *      None * * MODIFICATION HISTORY: *      10 DEC 2010 - C KENT    - DIMITRI-2 V1.0 * * VALIDATION HISTORY: *      13 DEC 2010 - C KENT    - WINDOWS 32-BIT MACHINE IDL 7.1: COMPILATION SUCCESSFUL, *                                AUX FILE DATA NOMINAL FOR AATSR L1B PRODUCT *                                (VALIDATED AGAINST BEAM and TEXTPAD) *      06 JAN 2010 - C KENT    - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL, *                                VALUES EQUAL TO WINDOWS 32-BIT MACHINE * ************************************************************************************** **************************************************************************************  ", "VERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/get_aatsr_l1b_reflectance.html", "get_aatsr_l1b_reflectance.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "get_aatsr_l1b_reflectance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/get_aatsr_l1b_reflectance.html#GET_AATSR_L1B_REFLECTANCE", "GET_AATSR_L1B_REFLECTANCE", 'routine in <a href="aatsr/get_aatsr_l1b_reflectance.html">get_aatsr_l1b_reflectance.pro</a>', "get_aatsr_l1b_reflectance.pro", "", "GET_AATSR_L1B_REFLECTANCE", "* NAME: *      GET_AATSR_L1B_RADIANCE * * PURPOSE: *      RETURNS THE L1B RADIANCE FOR A SPECIFIC AATSR BAND AND DIRECTION * * CALLING SEQUENCE: *      RES = GET_AATSR_L1B_REFLECTANCE(FILENAME,IN_BAND,L1B_DIR) * * INPUTS: *      FILENAME - A SCALAR CONTAINING THE FILENAME OF THE PRODUCT FOR RADIANCE EXTRACTION *      IN_BAND  - THE INDEX OF RADIANCE BAND TO BE RETURNED, STARTS FROM 0 *      L1B_DIR  - A STRING OF THE DIRECTION REQUIRED, EITHER 'NADIR' OR 'FWARD' * * KEYWORDS: *      ENDIAN_SIZE - MACHINE ENDIAN SIZE (0: LITTLE, 1: BIG) *      VERBOSE     - PROCESSING STATUS OUTPUTS * * OUTPUTS: *      L1B_REF     - TOA REFLECTANCE FOR IN_BAND. NOTE, THE REFLECTANCE AT POINT [0,0] *                    IS EQUAL TO THE TOP RIGHT PIXEL IN BEAM. * * COMMON BLOCKS: *      NONE * * MODIFICATION HISTORY: *      17 NOV 2005 - M BOUVET - PROTOTYPE DIMITRI VERSION *      10 DEC 2010 - C KENT   - DIMITRI-2 V1.0 *      14 DEC 2010 - C KENT   - MINOR TIDYING OF CODE, REMOVAL OF OLD COMMENTS * * VALIDATION HISTORY: *      12 DEC 2010 - C KENT    - WINDOWS 32-BIT MACHINE IDL 7.1: COMPILATION SUCCESSFUL, *                                BAND REFLECTANCE EQUAL TO BEAM VISAT FOR AATSR L1B DATA *      06 JAN 2010 - C KENT    - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL, *                                VALUES EQUAL TO WINDOWS 32-BIT MACHINE * ************************************************************************************** **************************************************************************************  ", "ENDIAN_SIZEVERBOSEFILENAMEIN_BANDL1B_DIR", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/get_aatsr_lat_lon.html", "get_aatsr_lat_lon.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "get_aatsr_lat_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/get_aatsr_lat_lon.html#GET_AATSR_LAT_LON", "GET_AATSR_LAT_LON", 'routine in <a href="aatsr/get_aatsr_lat_lon.html">get_aatsr_lat_lon.pro</a>', "get_aatsr_lat_lon.pro", "", "GET_AATSR_LAT_LON", "* NAME: *      GET_AATSR_LAT_LON * * PURPOSE: *      RETURNS THE LATITUDE AND LONGITUDE OF A AATSR IMAGE * * CALLING SEQUENCE: *      RES = GET_AATSR_LAT_LON(FILENAME,GEO_DIR) * * INPUTS: *      FILENAME - A SCALAR CONTAINING THE FILENAME OF THE PRODUCT FOR GEOLOCATION EXTRACTION *      GEO_DIR  - A STRING OF THE VEWING DIRECTION REQUIRED: 'NADIR' OR 'FWARD' * * KEYWORDS: *      VERBOSE  - PROCESSING STATUS OUTPUTS * * OUTPUTS: *      STRUCT.LATITUDE   - LATITUDE IN DEGREES FOR L1B PRODUCT *      STRUCT.LONGITUDE  - LONGITUDE IN DEGREES FOR L1B PRODUCT *      NOTE, THE DATA AT POINT [0,0] IS EQUAL TO THE TOP RIGHT PIXEL IN BEAM. * * COMMON BLOCKS: *      NONE * * MODIFICATION HISTORY: *      04 APR 2005 - M BOUVET - PROTOTYPE DIMITRI VERSION *      12 DEC 2010 - C KENT   - DIMITRI-2 V1.0 *      14 DEC 2010 - C KENT   - UPDATED HEADER INFORMATION *      12 JUL 2011 - C KENT   - FIXED LAT/LON EXTRACTION BUG * * VALIDATION HISTORY: *      13 DEC 2010 - C KENT    - WINDOWS 32-BIT MACHINE IDL 7.1: COMPILATION SUCCESSFUL, *                                SLIGHT DIFFERENCES TO BEAM VISAT POSSIBLY DUE TO INTERPOLATION TECHNIQUES *      06 JAN 2010 - C KENT    - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL, *                                VALUES EQUAL TO WINDOWS 32-BIT MACHINE * ************************************************************************************** ************************************************************************************** NOTE, NEEDS ENVISAT AND AATSR TO BE COMPILED  ", "VERBOSEFILENAMEGEO_DIRLENGTHWIDTH", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/get_aatsr_quicklook.html", "get_aatsr_quicklook.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "get_aatsr_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/get_aatsr_quicklook.html#GET_AATSR_QUICKLOOK", "GET_AATSR_QUICKLOOK", 'routine in <a href="aatsr/get_aatsr_quicklook.html">get_aatsr_quicklook.pro</a>', "get_aatsr_quicklook.pro", "", "GET_AATSR_QUICKLOOK", "* NAME: *      GET_AATSR_QUICKLOOK * * PURPOSE: *      OUTPUTS A GRAYSCALE/RGB AATSR QUICKLOOK WITH ROI OVERLAY IF REQUESTED * * CALLING SEQUENCE: *      RES = GET_AATSR_QUICKLOOK(FILENAME) * * INPUTS: *      FILENAME - A SCALAR CONTAINING THE FILENAME OF THE PRODUCT FOR QUICKLOOK GENERATION * * KEYWORDS: *     RGB          -  PROGRAM GENERATES AN RGB COLOUR QUICKLOOK (DEFAULT IS GRAYSCALE) *     ROI          -  OVERLAY COORDINATES OF AN ROI IN RED (REQUIRES ICOORDS) *     ICOORDS      -  A 4-ELEMENT ARRAY OF ROI GEOLOCATION (N,S,E,W) *     QL_QUALITY   -  QUALITY OF JPEG GENERATED (100 = MAX, 0 = LOWEST) *     ENDIAN_SIZE  -  MACHINE ENDIAN SIZE (0: LITTLE, 1: BIG) *     VERBOSE      -  PROCESSING STATUS OUTPUTS * * OUTPUTS: *     STATUS       - 1: NOMINAL, (-1) OR 0: ERROR *     JPESG ARE AUTOMATICALLY SAVED IN FILENAME FOLDER * * COMMON BLOCKS: *     NONE * * MODIFICATION HISTORY: *      01 DEC 2005 - M BOUVET - PROTOTYPE DIMITRI VERSION *      10 DEC 2010 - C KENT   - DIMITRI-2 V1.0 * * VALIDATION HISTORY: *      10 DEC 2010 - C KENT   - WINDOWS 32-BIT MACHINE IDL 7.1: COMPILATION SUCCESSFUL. ALL KEYWORD *                               COMBINATIONS TESTED FOR A PRODUCT OVER UYUNI *      06 JAN 2010 - C KENT   - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL, *                               VALUES EQUAL TO WINDOWS 32-BIT MACHINE * ************************************************************************************** **************************************************************************************  ", "RGBROIICOORDSQL_QUALITYENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/get_aatsr_timeseries_plots.html", "get_aatsr_timeseries_plots.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "get_aatsr_timeseries_plots.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/get_aatsr_timeseries_plots.html#GET_AATSR_TIMESERIES_PLOTS", "GET_AATSR_TIMESERIES_PLOTS", 'routine in <a href="aatsr/get_aatsr_timeseries_plots.html">get_aatsr_timeseries_plots.pro</a>', "get_aatsr_timeseries_plots.pro", "", "GET_AATSR_TIMESERIES_PLOTS", "* NAME: *      GET_AATSR_TIMESERIES_PLOTS * * PURPOSE: *      GENERATES PLOTS FROM THE SUPPLIED TIME SERIES OF DIMITRI AATSR DATA. * * CALLING SEQUENCE: *      RES = GET_AATSR_TIMESERIES_PLOTS(OUTPUT_SAV) * * INPUTS: *      OUTPUT_SAV  -  STRING OF THE SENSOR/PROCESSING OUTPUT SAV * * KEYWORDS: *      COLOUR_TABLE      - USER DEFINED IDL COLOUR TABLE INDEX (DEFAULT IS 39) *      PLOT_XSIZE        - WIDTH OF GENERATED PLOTS (DEFAULT IS 700PX) *      PLOT_YSIZE        - HEIGHT OF GENERATED PLOTS (DEFAULT IS 400PX) *      NO_ZBUFF          - IF SET THEN PLOTS ARE GENERATED IN WINDOWS AND NOT *                          WITHIN THE Z-BUFFER. *      VERBOSE           - PROCESSING STATUS OUTPUTS * * OUTPUTS: *      PLOTS OF TOA REFLECTANCE, REFLECTANCE EVOLUTION, SOLAR ZENITH ANGLE AND SENSOR *      ZENITH ANGLE AUTOMATICALLY SAVED. * * COMMON BLOCKS: *      NONE * * MODIFICATION HISTORY: *      13 DEC 2010 - C KENT   - DIMITRI-2 V1.0 *      06 JAN 2011 - C KENT   - MODIFIED TOA REF PLOTS TO INCLUDE BOTH DIRECTIONS *                               SEPERATELY *      07 JAN 2011 - C KENT   - DIMITRI-2 V2.0, MAJOR REVISION, ADDEDD FOR LOOP TO PROVIDE *                               ANALYSIS FOR BOTH DIRECTIONS *      10 JAN 2011 - C KENT   - CHANGED INPUT VARIABLE TO SENSOR_L1B_REF *      12 JAN 2011 - C KENT   - UPDATED TO REFLECT CHANGES IN SENSORS_L1B_REF (INCLUDES VAA AND SAA) *      22 MAR 2011 - C KENT   - ADDED CONFIGURAITON FILE DEPENDENCE *      04 JUL 2011 - C KENT   - ADDED AUX INFO TO OUTPUT SAV * * VALIDATION HISTORY: *      13 DEC 2010 - C KENT   - WINDOWS 32-BIT MACHINE IDL 7.1: COMPILATION SUCCESSFUL, *                               ZBUFFER AND NOMINAL PLOTS PRODUCED OK. *      06 JAN 2010 - C KENT   - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL, *                               VALUES EQUAL TO WINDOWS 32-BIT MACHINE * ************************************************************************************** **************************************************************************************  ", "NO_ZBUFFCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZEVERBOSEOUTPUT_SAV", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/get_aatsr_viewing_geometries.html", "get_aatsr_viewing_geometries.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "get_aatsr_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/get_aatsr_viewing_geometries.html#GET_AATSR_VIEWING_GEOMETRIES", "GET_AATSR_VIEWING_GEOMETRIES", 'routine in <a href="aatsr/get_aatsr_viewing_geometries.html">get_aatsr_viewing_geometries.pro</a>', "get_aatsr_viewing_geometries.pro", "", "GET_AATSR_VIEWING_GEOMETRIES", "* NAME: *      GET_AATSR_VIEWING_GEOMETRIES * * PURPOSE: *      RETURNS THE VIEWING GEOMETRIES OF A AATSR IMAGE * * CALLING SEQUENCE: *      RES = GET_AATSR_VIEWING_GEOMETRIES(FILENAME,GEO_DIR) * * INPUTS: *      FILENAME - A SCALAR CONTAINING THE FILENAME OF THE PRODUCT FOR EXTRACTION *      GEO_DIR  - A STRING CONTAINING THE DIRECTION TO BE RETIREVED, MUST BE EITHER 'NADIR' OR 'FWARD' * * KEYWORDS: *     ENDIAN_SIZE  - MACHINE ENDIAN SIZE (0: LITTLE, 1: BIG) *     VERBOSE      - PROCESSING STATUS OUTPUTS * * OUTPUTS: *     STRUCT.SZA   - SOLAR ZENITH ANGLE IN DEGREES *     STRUCT.SAA   - SOLAR AZIMUTH ANGLE IN DEGREES *     STRUCT.VZA   - SENSOR ZENITH ANGLE IN DEGREES *     STRUCT.VAA   - SENSOR AZIMUTH ANGLE IN DEGREES * * COMMON BLOCKS: *     NONE * * MODIFICATION HISTORY: *      17 NOV 2005 - M BOUVET - PROTOTYPE DIMITRI VERSION *      10 DEC 2010 - C KENT   - DIMITRI-2 V1.0 *      12 JUL 2011 - C KENT   - FIXED ANGLE EXTRACTION BUG * * VALIDATION HISTORY: *      13 DEC 2010 - C KENT    - WINDOWS 32-BIT MACHINE 7.1: COMPILATION SUCCESSFUL, *                                VIEWING GEOMETRY RETIREVAL NOMINAL, IT APPEARS BEAM PROVIDES ELEVATION ANGLE (90 IS NADIR), *                                INSTEAD OF ZENITH ANGLE (0 IS NADIR). VALUES ARE EQUAL TO 90-BEAM VALUE *      06 JAN 2010 - C KENT    - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL, *                                VALUES EQUAL TO WINDOWS 32-BIT MACHINE * ************************************************************************************** **************************************************************************************  ", "VERBOSEFILENAMEGEO_DIRLENGTHWIDTH", "          -1", "");
  
  

libdata[libdataItem++] = new Array("atsr2/get_atsr2_aux_files.html", "get_atsr2_aux_files.pro", '.pro file in <a href="atsr2/dir-overview.html">atsr2/ directory</a>', "get_atsr2_aux_files.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("atsr2/get_atsr2_aux_files.html#GET_ATSR2_AUX_FILES", "GET_ATSR2_AUX_FILES", 'routine in <a href="atsr2/get_atsr2_aux_files.html">get_atsr2_aux_files.pro</a>', "get_atsr2_aux_files.pro", "", "GET_ATSR2_AUX_FILES", "", "VERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("atsr2/get_atsr2_l1b_reflectance.html", "get_atsr2_l1b_reflectance.pro", '.pro file in <a href="atsr2/dir-overview.html">atsr2/ directory</a>', "get_atsr2_l1b_reflectance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("atsr2/get_atsr2_l1b_reflectance.html#GET_ATSR2_L1B_REFLECTANCE", "GET_ATSR2_L1B_REFLECTANCE", 'routine in <a href="atsr2/get_atsr2_l1b_reflectance.html">get_atsr2_l1b_reflectance.pro</a>', "get_atsr2_l1b_reflectance.pro", "", "GET_ATSR2_L1B_REFLECTANCE", "", "ENDIAN_SIZEVERBOSEFILENAMEIN_BANDL1B_DIR", "          -1", "");
  
  

libdata[libdataItem++] = new Array("atsr2/get_atsr2_lat_lon.html", "get_atsr2_lat_lon.pro", '.pro file in <a href="atsr2/dir-overview.html">atsr2/ directory</a>', "get_atsr2_lat_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("atsr2/get_atsr2_lat_lon.html#GET_ATSR2_LAT_LON", "GET_ATSR2_LAT_LON", 'routine in <a href="atsr2/get_atsr2_lat_lon.html">get_atsr2_lat_lon.pro</a>', "get_atsr2_lat_lon.pro", "", "GET_ATSR2_LAT_LON", "", "VERBOSEFILENAMEGEO_DIRLENGTHWIDTH", "          -1", "");
  
  

libdata[libdataItem++] = new Array("atsr2/get_atsr2_quicklook.html", "get_atsr2_quicklook.pro", '.pro file in <a href="atsr2/dir-overview.html">atsr2/ directory</a>', "get_atsr2_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("atsr2/get_atsr2_quicklook.html#GET_ATSR2_QUICKLOOK", "GET_ATSR2_QUICKLOOK", 'routine in <a href="atsr2/get_atsr2_quicklook.html">get_atsr2_quicklook.pro</a>', "get_atsr2_quicklook.pro", "", "GET_ATSR2_QUICKLOOK", "", "RGBROIICOORDSQL_QUALITYENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("atsr2/get_atsr2_timeseries_plots.html", "get_atsr2_timeseries_plots.pro", '.pro file in <a href="atsr2/dir-overview.html">atsr2/ directory</a>', "get_atsr2_timeseries_plots.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("atsr2/get_atsr2_timeseries_plots.html#GET_ATSR2_TIMESERIES_PLOTS", "GET_ATSR2_TIMESERIES_PLOTS", 'routine in <a href="atsr2/get_atsr2_timeseries_plots.html">get_atsr2_timeseries_plots.pro</a>', "get_atsr2_timeseries_plots.pro", "", "GET_ATSR2_TIMESERIES_PLOTS", "", "NO_ZBUFFCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZEVERBOSEOUTPUT_SAV", "          -1", "");
  
  

libdata[libdataItem++] = new Array("atsr2/get_atsr2_viewing_geometries.html", "get_atsr2_viewing_geometries.pro", '.pro file in <a href="atsr2/dir-overview.html">atsr2/ directory</a>', "get_atsr2_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("atsr2/get_atsr2_viewing_geometries.html#GET_ATSR2_VIEWING_GEOMETRIES", "GET_ATSR2_VIEWING_GEOMETRIES", 'routine in <a href="atsr2/get_atsr2_viewing_geometries.html">get_atsr2_viewing_geometries.pro</a>', "get_atsr2_viewing_geometries.pro", "", "GET_ATSR2_VIEWING_GEOMETRIES", "", "VERBOSEFILENAMEGEO_DIRLENGTHWIDTH", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_band_index_template.html", "get_dimitri_band_index_template.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_band_index_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_band_index_template.html#GET_DIMITRI_BAND_INDEX_TEMPLATE", "GET_DIMITRI_BAND_INDEX_TEMPLATE", 'routine in <a href="misc/get_dimitri_band_index_template.html">get_dimitri_band_index_template.pro</a>', "get_dimitri_band_index_template.pro", "", "GET_DIMITRI_BAND_INDEX_TEMPLATE", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_band_name_template.html", "get_dimitri_band_name_template.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_band_name_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_band_name_template.html#GET_DIMITRI_BAND_NAME_TEMPLATE", "GET_DIMITRI_BAND_NAME_TEMPLATE", 'routine in <a href="misc/get_dimitri_band_name_template.html">get_dimitri_band_name_template.pro</a>', "get_dimitri_band_name_template.pro", "", "GET_DIMITRI_BAND_NAME_TEMPLATE", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_configuration.html", "get_dimitri_configuration.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_configuration.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_configuration.html#GET_DIMITRI_CONFIGURATION", "GET_DIMITRI_CONFIGURATION", 'routine in <a href="misc/get_dimitri_configuration.html">get_dimitri_configuration.pro</a>', "get_dimitri_configuration.pro", "", "GET_DIMITRI_CONFIGURATION", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_configuration_template.html", "get_dimitri_configuration_template.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_configuration_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_configuration_template.html#GET_DIMITRI_CONFIGURATION_TEMPLATE", "GET_DIMITRI_CONFIGURATION_TEMPLATE", 'routine in <a href="misc/get_dimitri_configuration_template.html">get_dimitri_configuration_template.pro</a>', "get_dimitri_configuration_template.pro", "", "GET_DIMITRI_CONFIGURATION_TEMPLATE", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_extract_ncdf_data_structure.html", "get_dimitri_extract_ncdf_data_structure.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_extract_ncdf_data_structure.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_extract_ncdf_data_structure.html#GET_DIMITRI_EXTRACT_NCDF_DATA_STRUCTURE", "GET_DIMITRI_EXTRACT_NCDF_DATA_STRUCTURE", 'routine in <a href="misc/get_dimitri_extract_ncdf_data_structure.html">get_dimitri_extract_ncdf_data_structure.pro</a>', "get_dimitri_extract_ncdf_data_structure.pro", "", "GET_DIMITRI_EXTRACT_NCDF_DATA_STRUCTURE", "", "VERBOSENPRODNBANDSNVIEWS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_extract_toa_ncdf_names.html", "get_dimitri_extract_toa_ncdf_names.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_extract_toa_ncdf_names.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_extract_toa_ncdf_names.html#GET_DIMITRI_EXTRACT_TOA_NCDF_NAMES", "GET_DIMITRI_EXTRACT_TOA_NCDF_NAMES", 'routine in <a href="misc/get_dimitri_extract_toa_ncdf_names.html">get_dimitri_extract_toa_ncdf_names.pro</a>', "get_dimitri_extract_toa_ncdf_names.pro", "", "GET_DIMITRI_EXTRACT_TOA_NCDF_NAMES", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_location.html", "get_dimitri_location.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_location.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_location.html#GET_DIMITRI_LOCATION", "GET_DIMITRI_LOCATION", 'routine in <a href="misc/get_dimitri_location.html">get_dimitri_location.pro</a>', "get_dimitri_location.pro", "", "GET_DIMITRI_LOCATION", "", "VERBOSELOCATION", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_rsr_template.html", "get_dimitri_rsr_template.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_rsr_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_rsr_template.html#GET_DIMITRI_RSR_TEMPLATE", "GET_DIMITRI_RSR_TEMPLATE", 'routine in <a href="misc/get_dimitri_rsr_template.html">get_dimitri_rsr_template.pro</a>', "get_dimitri_rsr_template.pro", "", "GET_DIMITRI_RSR_TEMPLATE", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_sensor_data_template.html", "get_dimitri_sensor_data_template.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_sensor_data_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_sensor_data_template.html#GET_DIMITRI_SENSOR_DATA_TEMPLATE", "GET_DIMITRI_SENSOR_DATA_TEMPLATE", 'routine in <a href="misc/get_dimitri_sensor_data_template.html">get_dimitri_sensor_data_template.pro</a>', "get_dimitri_sensor_data_template.pro", "", "GET_DIMITRI_SENSOR_DATA_TEMPLATE", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_dimitri_site_data_template.html", "get_dimitri_site_data_template.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_dimitri_site_data_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_dimitri_site_data_template.html#GET_DIMITRI_SITE_DATA_TEMPLATE", "GET_DIMITRI_SITE_DATA_TEMPLATE", 'routine in <a href="misc/get_dimitri_site_data_template.html">get_dimitri_site_data_template.pro</a>', "get_dimitri_site_data_template.pro", "", "GET_DIMITRI_SITE_DATA_TEMPLATE", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("database/get_dimitri_template.html", "get_dimitri_template.pro", '.pro file in <a href="database/dir-overview.html">database/ directory</a>', "get_dimitri_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("database/get_dimitri_template.html#GET_DIMITRI_TEMPLATE", "GET_DIMITRI_TEMPLATE", 'routine in <a href="database/get_dimitri_template.html">get_dimitri_template.pro</a>', "get_dimitri_template.pro", "", "GET_DIMITRI_TEMPLATE", "", "DBHDRTEMPLATEFORMATVERBOSENB_FILES", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/get_dimitri_visualisation_colours.html", "get_dimitri_visualisation_colours.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "get_dimitri_visualisation_colours.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/get_dimitri_visualisation_colours.html#GET_DIMITRI_VISUALISATION_COLOURS", "GET_DIMITRI_VISUALISATION_COLOURS", 'routine in <a href="hmi/get_dimitri_visualisation_colours.html">get_dimitri_visualisation_colours.pro</a>', "get_dimitri_visualisation_colours.pro", "", "GET_DIMITRI_VISUALISATION_COLOURS", "", "VERBOSEN_CONFIGS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/get_dimitri_visualisation_colours_brdf.html", "get_dimitri_visualisation_colours_brdf.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "get_dimitri_visualisation_colours_brdf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/get_dimitri_visualisation_colours_brdf.html#GET_DIMITRI_VISUALISATION_COLOURS_BRDF", "GET_DIMITRI_VISUALISATION_COLOURS_BRDF", 'routine in <a href="hmi/get_dimitri_visualisation_colours_brdf.html">get_dimitri_visualisation_colours_brdf.pro</a>', "get_dimitri_visualisation_colours_brdf.pro", "", "GET_DIMITRI_VISUALISATION_COLOURS_BRDF", "", "VERBOSEN_CONFIGS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_endian_size.html", "get_endian_size.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_endian_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_endian_size.html#GET_ENDIAN_SIZE", "GET_ENDIAN_SIZE", 'routine in <a href="misc/get_endian_size.html">get_endian_size.pro</a>', "get_endian_size.pro", "", "GET_ENDIAN_SIZE", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("toa_simulation/get_gaseous_transmission.html", "get_gaseous_transmission.pro", '.pro file in <a href="toa_simulation/dir-overview.html">toa_simulation/ directory</a>', "get_gaseous_transmission.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("toa_simulation/get_gaseous_transmission.html#GET_GASEOUS_TRANSMISSION", "GET_GASEOUS_TRANSMISSION", 'routine in <a href="toa_simulation/get_gaseous_transmission.html">get_gaseous_transmission.pro</a>', "get_gaseous_transmission.pro", "", "GET_GASEOUS_TRANSMISSION", "", "VERBOSEWAVELENGTHS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_histogram.html", "get_histogram.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_histogram.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_histogram.html#GET_HISTOGRAM", "GET_HISTOGRAM", 'routine in <a href="misc/get_histogram.html">get_histogram.pro</a>', "get_histogram.pro", "", "GET_HISTOGRAM", "", "HTITLEHX_TITLEHY_TITLENO_ZBUFFPLOT_XSIZEPLOT_YSOZEVERBOSEHFILEHDATANBINS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_aux_files.html", "get_meris_aux_files.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_aux_files.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_aux_files.html#GET_MERIS_AUX_FILES", "GET_MERIS_AUX_FILES", 'routine in <a href="meris/get_meris_aux_files.html">get_meris_aux_files.pro</a>', "get_meris_aux_files.pro", "", "GET_MERIS_AUX_FILES", "", "VERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_ecmwf_humidity.html", "get_meris_ecmwf_humidity.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_ecmwf_humidity.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_ecmwf_humidity.html#GET_MERIS_ECMWF_HUMIDITY", "GET_MERIS_ECMWF_HUMIDITY", 'routine in <a href="meris/get_meris_ecmwf_humidity.html">get_meris_ecmwf_humidity.pro</a>', "get_meris_ecmwf_humidity.pro", "", "GET_MERIS_ECMWF_HUMIDITY", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_ecmwf_ozone.html", "get_meris_ecmwf_ozone.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_ecmwf_ozone.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_ecmwf_ozone.html#GET_MERIS_ECMWF_OZONE", "GET_MERIS_ECMWF_OZONE", 'routine in <a href="meris/get_meris_ecmwf_ozone.html">get_meris_ecmwf_ozone.pro</a>', "get_meris_ecmwf_ozone.pro", "", "GET_MERIS_ECMWF_OZONE", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_ecmwf_pressure.html", "get_meris_ecmwf_pressure.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_ecmwf_pressure.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_ecmwf_pressure.html#GET_MERIS_ECMWF_PRESSURE", "GET_MERIS_ECMWF_PRESSURE", 'routine in <a href="meris/get_meris_ecmwf_pressure.html">get_meris_ecmwf_pressure.pro</a>', "get_meris_ecmwf_pressure.pro", "", "GET_MERIS_ECMWF_PRESSURE", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_ecmwf_wind.html", "get_meris_ecmwf_wind.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_ecmwf_wind.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_ecmwf_wind.html#GET_MERIS_ECMWF_WIND", "GET_MERIS_ECMWF_WIND", 'routine in <a href="meris/get_meris_ecmwf_wind.html">get_meris_ecmwf_wind.pro</a>', "get_meris_ecmwf_wind.pro", "", "GET_MERIS_ECMWF_WIND", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_l1b_detector_index.html", "get_meris_l1b_detector_index.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_l1b_detector_index.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_l1b_detector_index.html#GET_MERIS_L1B_DETECTOR_INDEX", "GET_MERIS_L1B_DETECTOR_INDEX", 'routine in <a href="meris/get_meris_l1b_detector_index.html">get_meris_l1b_detector_index.pro</a>', "get_meris_l1b_detector_index.pro", "", "GET_MERIS_L1B_DETECTOR_INDEX", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_l1b_f0.html", "get_meris_l1b_f0.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_l1b_f0.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_l1b_f0.html#GET_MERIS_L1B_F0", "GET_MERIS_L1B_F0", 'routine in <a href="meris/get_meris_l1b_f0.html">get_meris_l1b_f0.pro</a>', "get_meris_l1b_f0.pro", "", "GET_MERIS_L1B_F0", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_l1b_radiance.html", "get_meris_l1b_radiance.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_l1b_radiance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_l1b_radiance.html#GET_MERIS_L1B_RADIANCE", "GET_MERIS_L1B_RADIANCE", 'routine in <a href="meris/get_meris_l1b_radiance.html">get_meris_l1b_radiance.pro</a>', "get_meris_l1b_radiance.pro", "", "GET_MERIS_L1B_RADIANCE", "", "ENDIAN_SIZEVERBOSEFILENAMEIN_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_l1b_radiance_sf.html", "get_meris_l1b_radiance_sf.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_l1b_radiance_sf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_l1b_radiance_sf.html#GET_MERIS_L1B_RADIANCE_SF", "GET_MERIS_L1B_RADIANCE_SF", 'routine in <a href="meris/get_meris_l1b_radiance_sf.html">get_meris_l1b_radiance_sf.pro</a>', "get_meris_l1b_radiance_sf.pro", "", "GET_MERIS_L1B_RADIANCE_SF", "", "ENDIAN_SIZEVERBOSEFILENAMEIN_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_lat_lon.html", "get_meris_lat_lon.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_lat_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_lat_lon.html#GET_MERIS_LAT_LON", "GET_MERIS_LAT_LON", 'routine in <a href="meris/get_meris_lat_lon.html">get_meris_lat_lon.pro</a>', "get_meris_lat_lon.pro", "", "GET_MERIS_LAT_LON", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_quicklook.html", "get_meris_quicklook.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_quicklook.html#GET_MERIS_QUICKLOOK", "GET_MERIS_QUICKLOOK", 'routine in <a href="meris/get_meris_quicklook.html">get_meris_quicklook.pro</a>', "get_meris_quicklook.pro", "", "GET_MERIS_QUICKLOOK", "", "RGBROIICOORDSQL_QUALITYENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_solar_flux_rr.html", "get_meris_solar_flux_rr.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_solar_flux_rr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_solar_flux_rr.html#GET_MERIS_SOLAR_FLUX_RR", "GET_MERIS_SOLAR_FLUX_RR", 'routine in <a href="meris/get_meris_solar_flux_rr.html">get_meris_solar_flux_rr.pro</a>', "get_meris_solar_flux_rr.pro", "", "GET_MERIS_SOLAR_FLUX_RR", "", "FRVERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_timeseries_plots.html", "get_meris_timeseries_plots.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_timeseries_plots.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_timeseries_plots.html#GET_MERIS_TIMESERIES_PLOTS", "GET_MERIS_TIMESERIES_PLOTS", 'routine in <a href="meris/get_meris_timeseries_plots.html">get_meris_timeseries_plots.pro</a>', "get_meris_timeseries_plots.pro", "", "GET_MERIS_TIMESERIES_PLOTS", "", "NO_ZBUFFCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZEVERBOSEOUTPUT_SAV", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/get_meris_viewing_geometries.html", "get_meris_viewing_geometries.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "get_meris_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/get_meris_viewing_geometries.html#GET_MERIS_VIEWING_GEOMETRIES", "GET_MERIS_VIEWING_GEOMETRIES", 'routine in <a href="meris/get_meris_viewing_geometries.html">get_meris_viewing_geometries.pro</a>', "get_meris_viewing_geometries.pro", "", "GET_MERIS_VIEWING_GEOMETRIES", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_aux_files.html", "get_modisa_aux_files.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_aux_files.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_aux_files.html#GET_MODISA_AUX_FILES", "GET_MODISA_AUX_FILES", 'routine in <a href="modisa/get_modisa_aux_files.html">get_modisa_aux_files.pro</a>', "get_modisa_aux_files.pro", "", "GET_MODISA_AUX_FILES", "", "VERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_date_info.html", "get_modisa_date_info.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_date_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_date_info.html#GET_MODISA_DATE_INFO", "GET_MODISA_DATE_INFO", 'routine in <a href="modisa/get_modisa_date_info.html">get_modisa_date_info.pro</a>', "get_modisa_date_info.pro", "", "GET_MODISA_DATE_INFO", "", "VERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_emissive.html", "get_modisa_l1b_emissive.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_l1b_emissive.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_emissive.html#GET_MODISA_L1B_EMISSIVE", "GET_MODISA_L1B_EMISSIVE", 'routine in <a href="modisa/get_modisa_l1b_emissive.html">get_modisa_l1b_emissive.pro</a>', "get_modisa_l1b_emissive.pro", "", "GET_MODISA_L1B_EMISSIVE", "", "VERBOSEFILENAMEIN_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_emissive_linux.html", "get_modisa_l1b_emissive_linux.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_l1b_emissive_linux.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_emissive_linux.html#GET_MODISA_L1B_EMISSIVE_LINUX", "GET_MODISA_L1B_EMISSIVE_LINUX", 'routine in <a href="modisa/get_modisa_l1b_emissive_linux.html">get_modisa_l1b_emissive_linux.pro</a>', "get_modisa_l1b_emissive_linux.pro", "", "GET_MODISA_L1B_EMISSIVE_LINUX", "", "VERBOSEFILENAMEIN_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_radiance.html", "get_modisa_l1b_radiance.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_l1b_radiance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_radiance.html#GET_MODISA_L1B_RADIANCE", "GET_MODISA_L1B_RADIANCE", 'routine in <a href="modisa/get_modisa_l1b_radiance.html">get_modisa_l1b_radiance.pro</a>', "get_modisa_l1b_radiance.pro", "", "GET_MODISA_L1B_RADIANCE", "", "VERBOSERES_1KMRES_500MRES_250MFILENAMEIN_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_radiance_linux.html", "get_modisa_l1b_radiance_linux.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_l1b_radiance_linux.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_radiance_linux.html#GET_MODISA_L1B_RADIANCE_LINUX", "GET_MODISA_L1B_RADIANCE_LINUX", 'routine in <a href="modisa/get_modisa_l1b_radiance_linux.html">get_modisa_l1b_radiance_linux.pro</a>', "get_modisa_l1b_radiance_linux.pro", "", "GET_MODISA_L1B_RADIANCE_LINUX", "", "VERBOSERES_1KMRES_500MRES_250MFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_reflectance.html", "get_modisa_l1b_reflectance.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_l1b_reflectance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_reflectance.html#GET_MODISA_L1B_REFLECTANCE", "GET_MODISA_L1B_REFLECTANCE", 'routine in <a href="modisa/get_modisa_l1b_reflectance.html">get_modisa_l1b_reflectance.pro</a>', "get_modisa_l1b_reflectance.pro", "", "GET_MODISA_L1B_REFLECTANCE", "", "VERBOSERES_1KMRES_500MRES_250MFILENAMEIN_BAND", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_reflectance_linux.html", "get_modisa_l1b_reflectance_linux.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_l1b_reflectance_linux.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_l1b_reflectance_linux.html#GET_MODISA_L1B_REFLECTANCE_LINUX", "GET_MODISA_L1B_REFLECTANCE_LINUX", 'routine in <a href="modisa/get_modisa_l1b_reflectance_linux.html">get_modisa_l1b_reflectance_linux.pro</a>', "get_modisa_l1b_reflectance_linux.pro", "", "GET_MODISA_L1B_REFLECTANCE_LINUX", "", "VERBOSERES_1KMRES_500MRES_250MFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_lat_lon.html", "get_modisa_lat_lon.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_lat_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_lat_lon.html#GET_MODISA_LAT_LON", "GET_MODISA_LAT_LON", 'routine in <a href="modisa/get_modisa_lat_lon.html">get_modisa_lat_lon.pro</a>', "get_modisa_lat_lon.pro", "", "GET_MODISA_LAT_LON", "", "VERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_quicklook.html", "get_modisa_quicklook.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_quicklook.html#GET_MODISA_QUICKLOOK", "GET_MODISA_QUICKLOOK", 'routine in <a href="modisa/get_modisa_quicklook.html">get_modisa_quicklook.pro</a>', "get_modisa_quicklook.pro", "", "GET_MODISA_QUICKLOOK", "", "RGBROIICOORDSQL_QUALITYVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_quicklook_linux.html", "get_modisa_quicklook_linux.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_quicklook_linux.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_quicklook_linux.html#GET_MODISA_QUICKLOOK_LINUX", "GET_MODISA_QUICKLOOK_LINUX", 'routine in <a href="modisa/get_modisa_quicklook_linux.html">get_modisa_quicklook_linux.pro</a>', "get_modisa_quicklook_linux.pro", "", "GET_MODISA_QUICKLOOK_LINUX", "", "RGBROIICOORDSQL_QUALITYVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_timeseries_plots.html", "get_modisa_timeseries_plots.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_timeseries_plots.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_timeseries_plots.html#GET_MODISA_TIMESERIES_PLOTS", "GET_MODISA_TIMESERIES_PLOTS", 'routine in <a href="modisa/get_modisa_timeseries_plots.html">get_modisa_timeseries_plots.pro</a>', "get_modisa_timeseries_plots.pro", "", "GET_MODISA_TIMESERIES_PLOTS", "", "NO_ZBUFFCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZEVERBOSEOUTPUT_SAV", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/get_modisa_viewing_geometries.html", "get_modisa_viewing_geometries.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "get_modisa_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/get_modisa_viewing_geometries.html#GET_MODISA_VIEWING_GEOMETRIES", "GET_MODISA_VIEWING_GEOMETRIES", 'routine in <a href="modisa/get_modisa_viewing_geometries.html">get_modisa_viewing_geometries.pro</a>', "get_modisa_viewing_geometries.pro", "", "GET_MODISA_VIEWING_GEOMETRIES", "", "VERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("toa_simulation/get_ozone_transmission.html", "get_ozone_transmission.pro", '.pro file in <a href="toa_simulation/dir-overview.html">toa_simulation/ directory</a>', "get_ozone_transmission.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("toa_simulation/get_ozone_transmission.html#GET_OZONE_TRANSMISSION", "GET_OZONE_TRANSMISSION", 'routine in <a href="toa_simulation/get_ozone_transmission.html">get_ozone_transmission.pro</a>', "get_ozone_transmission.pro", "", "GET_OZONE_TRANSMISSION", "", "VERBOSEWAVELENGTHS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("parasol/get_parasol_direction_geometry.html", "get_parasol_direction_geometry.pro", '.pro file in <a href="parasol/dir-overview.html">parasol/ directory</a>', "get_parasol_direction_geometry.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("parasol/get_parasol_direction_geometry.html#GET_PARASOL_DIRECTION_GEOMETRY", "GET_PARASOL_DIRECTION_GEOMETRY", 'routine in <a href="parasol/get_parasol_direction_geometry.html">get_parasol_direction_geometry.pro</a>', "get_parasol_direction_geometry.pro", "", "GET_PARASOL_DIRECTION_GEOMETRY", "", "L1B_IMAGE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("parasol/get_parasol_l1b_data.html", "get_parasol_l1b_data.pro", '.pro file in <a href="parasol/dir-overview.html">parasol/ directory</a>', "get_parasol_l1b_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("parasol/get_parasol_l1b_data.html#GET_PARASOL_L1B_DATA", "GET_PARASOL_L1B_DATA", 'routine in <a href="parasol/get_parasol_l1b_data.html">get_parasol_l1b_data.pro</a>', "get_parasol_l1b_data.pro", "", "GET_PARASOL_L1B_DATA", "", "ENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("parasol/get_parasol_l1b_header.html", "get_parasol_l1b_header.pro", '.pro file in <a href="parasol/dir-overview.html">parasol/ directory</a>', "get_parasol_l1b_header.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("parasol/get_parasol_l1b_header.html#GET_PARASOL_L1B_HEADER", "GET_PARASOL_L1B_HEADER", 'routine in <a href="parasol/get_parasol_l1b_header.html">get_parasol_l1b_header.pro</a>', "get_parasol_l1b_header.pro", "", "GET_PARASOL_L1B_HEADER", "", "VERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("parasol/get_parasol_l1b_pixel_structure.html", "get_parasol_l1b_pixel_structure.pro", '.pro file in <a href="parasol/dir-overview.html">parasol/ directory</a>', "get_parasol_l1b_pixel_structure.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("parasol/get_parasol_l1b_pixel_structure.html#GET_PARASOL_L1B_PIXEL_STRUCTURE", "GET_PARASOL_L1B_PIXEL_STRUCTURE", 'routine in <a href="parasol/get_parasol_l1b_pixel_structure.html">get_parasol_l1b_pixel_structure.pro</a>', "get_parasol_l1b_pixel_structure.pro", "", "GET_PARASOL_L1B_PIXEL_STRUCTURE", "", "VERBOSEINUM_RECS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/get_parasol_num_pixels.html", "get_parasol_num_pixels.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "get_parasol_num_pixels.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/get_parasol_num_pixels.html#remove_bad_parasol", "remove_bad_parasol", 'routine in <a href="validation/get_parasol_num_pixels.html">get_parasol_num_pixels.pro</a>', "get_parasol_num_pixels.pro", "", "remove_bad_parasol", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/get_parasol_num_pixels.html#get_parasol_num_pixels", "get_parasol_num_pixels", 'routine in <a href="validation/get_parasol_num_pixels.html">get_parasol_num_pixels.pro</a>', "get_parasol_num_pixels.pro", "", "get_parasol_num_pixels", "", "filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("parasol/get_parasol_quicklook.html", "get_parasol_quicklook.pro", '.pro file in <a href="parasol/dir-overview.html">parasol/ directory</a>', "get_parasol_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("parasol/get_parasol_quicklook.html#GET_PARASOL_QUICKLOOK", "GET_PARASOL_QUICKLOOK", 'routine in <a href="parasol/get_parasol_quicklook.html">get_parasol_quicklook.pro</a>', "get_parasol_quicklook.pro", "", "GET_PARASOL_QUICKLOOK", "", "RGBROIICOORDSQL_QUALITYENDIAN_SIZEVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("parasol/get_parasol_timeseries_plots.html", "get_parasol_timeseries_plots.pro", '.pro file in <a href="parasol/dir-overview.html">parasol/ directory</a>', "get_parasol_timeseries_plots.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("parasol/get_parasol_timeseries_plots.html#GET_PARASOL_TIMESERIES_PLOTS", "GET_PARASOL_TIMESERIES_PLOTS", 'routine in <a href="parasol/get_parasol_timeseries_plots.html">get_parasol_timeseries_plots.pro</a>', "get_parasol_timeseries_plots.pro", "", "GET_PARASOL_TIMESERIES_PLOTS", "", "NO_ZBUFFCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZEVERBOSEOUTPUT_SAV", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/get_parasol_viewing_geometries.html", "get_parasol_viewing_geometries.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "get_parasol_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/get_parasol_viewing_geometries.html#GET_PARASOL_VIEWING_GEOMETRIES", "GET_PARASOL_VIEWING_GEOMETRIES", 'routine in <a href="sade/get_parasol_viewing_geometries.html">get_parasol_viewing_geometries.pro</a>', "get_parasol_viewing_geometries.pro", "", "GET_PARASOL_VIEWING_GEOMETRIES", "", "PNAMEICOORDSSITE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/get_parasol_viewing_geometries.html", "get_parasol_viewing_geometries.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "get_parasol_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/get_parasol_viewing_geometries.html#get_parasol_viewing_geometries", "get_parasol_viewing_geometries", 'routine in <a href="validation/get_parasol_viewing_geometries.html">get_parasol_viewing_geometries.pro</a>', "get_parasol_viewing_geometries.pro", "", "get_parasol_viewing_geometries", "", "pnameicoordssite", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_product_identifiers.html", "get_product_identifiers.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_product_identifiers.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_product_identifiers.html#GET_PRODUCT_IDENTIFIERS", "GET_PRODUCT_IDENTIFIERS", 'routine in <a href="misc/get_product_identifiers.html">get_product_identifiers.pro</a>', "get_product_identifiers.pro", "", "GET_PRODUCT_IDENTIFIERS", "", "VERBOSESEARCH_SENSOR", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_sensor_band_index.html", "get_sensor_band_index.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_sensor_band_index.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_sensor_band_index.html#GET_SENSOR_BAND_INDEX", "GET_SENSOR_BAND_INDEX", 'routine in <a href="misc/get_sensor_band_index.html">get_sensor_band_index.pro</a>', "get_sensor_band_index.pro", "", "GET_SENSOR_BAND_INDEX", "", "VERBOSEBI_SENSORBINDEX", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_sensor_band_name.html", "get_sensor_band_name.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_sensor_band_name.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_sensor_band_name.html#GET_SENSOR_BAND_NAME", "GET_SENSOR_BAND_NAME", 'routine in <a href="misc/get_sensor_band_name.html">get_sensor_band_name.pro</a>', "get_sensor_band_name.pro", "", "GET_SENSOR_BAND_NAME", "", "BN_SENSORBN_ID", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_site_coordinates.html", "get_site_coordinates.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_site_coordinates.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_site_coordinates.html#GET_SITE_COORDINATES", "GET_SITE_COORDINATES", 'routine in <a href="misc/get_site_coordinates.html">get_site_coordinates.pro</a>', "get_site_coordinates.pro", "", "GET_SITE_COORDINATES", "", "VERBOSESITE_IDSITE_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/get_site_type.html", "get_site_type.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "get_site_type.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/get_site_type.html#GET_SITE_TYPE", "GET_SITE_TYPE", 'routine in <a href="misc/get_site_type.html">get_site_type.pro</a>', "get_site_type.pro", "", "GET_SITE_TYPE", "", "VERBOSESITE_ID", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_header_info.html", "get_vegetation_header_info.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_header_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_header_info.html#GET_VEGETATION_HEADER_INFO", "GET_VEGETATION_HEADER_INFO", 'routine in <a href="vegetation/get_vegetation_header_info.html">get_vegetation_header_info.pro</a>', "get_vegetation_header_info.pro", "", "GET_VEGETATION_HEADER_INFO", "", "VERBOSELOG_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_l1b_reflectance.html", "get_vegetation_l1b_reflectance.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_l1b_reflectance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_l1b_reflectance.html#GET_VEGETATION_L1B_REFLECTANCE", "GET_VEGETATION_L1B_REFLECTANCE", 'routine in <a href="vegetation/get_vegetation_l1b_reflectance.html">get_vegetation_l1b_reflectance.pro</a>', "get_vegetation_l1b_reflectance.pro", "", "GET_VEGETATION_L1B_REFLECTANCE", "", "VERBOSELOG_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_lat_lon.html", "get_vegetation_lat_lon.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_lat_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_lat_lon.html#GET_VEGETATION_LAT_LON", "GET_VEGETATION_LAT_LON", 'routine in <a href="vegetation/get_vegetation_lat_lon.html">get_vegetation_lat_lon.pro</a>', "get_vegetation_lat_lon.pro", "", "GET_VEGETATION_LAT_LON", "", "VERBOSELOG_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_lat_lon_plate_carree.html", "get_vegetation_lat_lon_plate_carree.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_lat_lon_plate_carree.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_lat_lon_plate_carree.html#GET_VEGETATION_LAT_LON_PLATE_CARREE", "GET_VEGETATION_LAT_LON_PLATE_CARREE", 'routine in <a href="vegetation/get_vegetation_lat_lon_plate_carree.html">get_vegetation_lat_lon_plate_carree.pro</a>', "get_vegetation_lat_lon_plate_carree.pro", "", "GET_VEGETATION_LAT_LON_PLATE_CARREE", "", "VERBOSENORTHSOUTHEASTWESTNUM_PIX_XNUM_PIX_Y", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_lat_lon_stereo_pole.html", "get_vegetation_lat_lon_stereo_pole.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_lat_lon_stereo_pole.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_lat_lon_stereo_pole.html#GET_VEGETATION_LAT_LON_STEREO_POLE", "GET_VEGETATION_LAT_LON_STEREO_POLE", 'routine in <a href="vegetation/get_vegetation_lat_lon_stereo_pole.html">get_vegetation_lat_lon_stereo_pole.pro</a>', "get_vegetation_lat_lon_stereo_pole.pro", "", "GET_VEGETATION_LAT_LON_STEREO_POLE", "", "VERBOSEVGTLATVGTLONNUMPIXXNUMPIXY", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_ozone.html", "get_vegetation_ozone.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_ozone.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_ozone.html#GET_VEGETATION_OZONE", "GET_VEGETATION_OZONE", 'routine in <a href="vegetation/get_vegetation_ozone.html">get_vegetation_ozone.pro</a>', "get_vegetation_ozone.pro", "", "GET_VEGETATION_OZONE", "", "VERBOSELOG_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_quicklook.html", "get_vegetation_quicklook.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_quicklook.html#GET_VEGETATION_QUICKLOOK", "GET_VEGETATION_QUICKLOOK", 'routine in <a href="vegetation/get_vegetation_quicklook.html">get_vegetation_quicklook.pro</a>', "get_vegetation_quicklook.pro", "", "GET_VEGETATION_QUICKLOOK", "", "RGBROIICOORDSQL_QUALITYVERBOSEFILENAME", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_timeseries_plots.html", "get_vegetation_timeseries_plots.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_timeseries_plots.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_timeseries_plots.html#GET_VEGETATION_TIMESERIES_PLOTS", "GET_VEGETATION_TIMESERIES_PLOTS", 'routine in <a href="vegetation/get_vegetation_timeseries_plots.html">get_vegetation_timeseries_plots.pro</a>', "get_vegetation_timeseries_plots.pro", "", "GET_VEGETATION_TIMESERIES_PLOTS", "", "NO_ZBUFFCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZEVERBOSEOUTPUT_SAV", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_viewing_geometries.html", "get_vegetation_viewing_geometries.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_viewing_geometries.html#GET_VEGETATION_VIEWING_GEOMETRIES", "GET_VEGETATION_VIEWING_GEOMETRIES", 'routine in <a href="vegetation/get_vegetation_viewing_geometries.html">get_vegetation_viewing_geometries.pro</a>', "get_vegetation_viewing_geometries.pro", "", "GET_VEGETATION_VIEWING_GEOMETRIES", "", "VERBOSELOG_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vegetation_wvap.html", "get_vegetation_wvap.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vegetation_wvap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vegetation_wvap.html#GET_VEGETATION_WVAP", "GET_VEGETATION_WVAP", 'routine in <a href="vegetation/get_vegetation_wvap.html">get_vegetation_wvap.pro</a>', "get_vegetation_wvap.pro", "", "GET_VEGETATION_WVAP", "", "VERBOSELOG_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/get_vgt_correction_factor.html", "get_vgt_correction_factor.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "get_vgt_correction_factor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/get_vgt_correction_factor.html#GET_VGT_CORRECTION_FACTOR", "GET_VGT_CORRECTION_FACTOR", 'routine in <a href="vegetation/get_vgt_correction_factor.html">get_vgt_correction_factor.pro</a>', "get_vgt_correction_factor.pro", "", "GET_VGT_CORRECTION_FACTOR", "", "DOY", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_aux_files.html", "get_viirs_aux_files.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_aux_files.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_aux_files.html#GET_VIIRS_AUX_FILES", "GET_VIIRS_AUX_FILES", 'routine in <a href="viirs/get_viirs_aux_files.html">get_viirs_aux_files.pro</a>', "get_viirs_aux_files.pro", "", "GET_VIIRS_AUX_FILES", "", "FILENAME        full path of the file to be analysed   ", "          -1", "      04 DEC 2010 - C KENT    - DIMITRI-2 V1.0   VALIDATION HISTORY:       04 DEC 2010 - C KENT    - WINDOWS 32-BIT MACHINE IDL 7.1: COMPILATION SUCCESSFUL,                                 RESULTS EQUAL TO HDF EXPLORER/BEAM VISAT       05 JAN 2011 - C KENT    - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL,                                 NO APPARENT DIFFERENCES WHEN COMPARED TO WINDOWS MACHINE        AUX_FILES:         a string array containing the auxiliary filename information   :Common Blocs:       NONE   ");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_date_info.html", "get_viirs_date_info.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_date_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_date_info.html#GET_VIIRS_DATE_INFO", "GET_VIIRS_DATE_INFO", 'routine in <a href="viirs/get_viirs_date_info.html">get_viirs_date_info.pro</a>', "get_viirs_date_info.pro", "", "GET_VIIRS_DATE_INFO", "", "VERBOSE         processing status outputs   FILENAME          a string containing the filename of the product for geolocaiton extraction   ", "          -1", "      26 JUN 2013 - D MARRABLE   - DIMITRI-2 V1.0        DATE_INFO : a structure containing the year, month, day, day of year and decimel year   COMMON BLOCKS:       none   ");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_emissive_btemp.html", "get_viirs_emissive_btemp.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_emissive_btemp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_emissive_btemp.html#GET_VIIRS_EMISSIVE_BTEMP", "GET_VIIRS_EMISSIVE_BTEMP", 'routine in <a href="viirs/get_viirs_emissive_btemp.html">get_viirs_emissive_btemp.pro</a>', "get_viirs_emissive_btemp.pro", "", "GET_VIIRS_EMISSIVE_BTEMP", "      returns the l1b emissive radiance brightness temperature.  These are read       straight out of the VIIRS file.   :Calling Sequence:       RES = GET_MODISA_L1B_EMISSIVE_BTEMP(FILENAME)   ", "VERBOSE          processing status outputs   FILENAME        a string containing the filename of the product for reflectance extraction   ", "          -1", "      27 jun 2013 - D Marrable   - DIMITRI-2 V1.0        BTEMP  :           an array of brightness temperatures in kelvin   :Common blocks:       NONE   ");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_l1b_emissive.html", "get_viirs_l1b_emissive.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_l1b_emissive.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_l1b_emissive.html#GET_VIIRS_L1B_EMISSIVE", "GET_VIIRS_L1B_EMISSIVE", 'routine in <a href="viirs/get_viirs_l1b_emissive.html">get_viirs_l1b_emissive.pro</a>', "get_viirs_l1b_emissive.pro", "", "GET_VIIRS_L1B_EMISSIVE", "      returns the l1b emissive radiance for a specific modisa band   :Calling Sequence:       RES = GET_MODISA_L1B_EMISSIVE(FILENAME,IN_BAND)   ", "VERBOSE          processing status outputs   FILENAME        a string containing the filename of the product for reflectance extraction   ", "          -1", "      27 jun 2013 - D Marrable   - DIMITRI-2 V1.0        TOA_EMM  :           toa reflectance for product following use of scaling factor   :Common blocks:       NONE   ");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_l1b_radiance.html", "get_viirs_l1b_radiance.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_l1b_radiance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_l1b_radiance.html#GET_VIIRS_L1B_RADIANCE", "GET_VIIRS_L1B_RADIANCE", 'routine in <a href="viirs/get_viirs_l1b_radiance.html">get_viirs_l1b_radiance.pro</a>', "get_viirs_l1b_radiance.pro", "", "GET_VIIRS_L1B_RADIANCE", "      returns the l1b radiance for a specific modisa band   :calling sequence:       res = get_modisa_l1b_radiance_linux(filename, 2)   ", "VERBOSEFILENAME        A string containing the filename of the product for radiance extraction  IN_BAND        The band to extract.  * Keywords:  ", "          -1", "      27 JUN 2013 - D Marrable   - DIMITRI-2 V1.0        TOA_REFL :           - toa radiance for product   :Common blocks:       NONE   ");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_l1b_reflectance.html", "get_viirs_l1b_reflectance.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_l1b_reflectance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_l1b_reflectance.html#GET_VIIRS_L1B_REFLECTANCE", "GET_VIIRS_L1B_REFLECTANCE", 'routine in <a href="viirs/get_viirs_l1b_reflectance.html">get_viirs_l1b_reflectance.pro</a>', "get_viirs_l1b_reflectance.pro", "", "GET_VIIRS_L1B_REFLECTANCE", "      returns the l1b reflectance for a specific VIIRS band   :Calling sequence:       RES = GET_VIIRS_L1B_REFLECTANCE_LINUX(FILENAME)   ", "VERBOSE        processing status outputs  RES_750M        indicates that the in_band index refers to the 1km dataset   FILENAME        a scalar containing the filename of the product for reflectance extraction   IN_BAND", "          -1", "      27 Jun 2013 - D marrable   - DIMITRI-2 V1.0         TOA_REFL :         toa reflectance for product following use of scaling factor   COMMON BLOCKS:       NONE   ");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_lat_lon.html", "get_viirs_lat_lon.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_lat_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_lat_lon.html#GET_VIIRS_LAT_LON", "GET_VIIRS_LAT_LON", 'routine in <a href="viirs/get_viirs_lat_lon.html">get_viirs_lat_lon.pro</a>', "get_viirs_lat_lon.pro", "", "GET_VIIRS_LAT_LON", "", "VERBOSE         PROCESSING STATUS OUTPUTS   FILENAME          a string containing the filename of the product for geolocaiton extraction   ", "          -1", "      26 JUN 2013 - D MARRABLE   - DIMITRI-2 V1.0        STRUCT.LAT :          LATITUDE IN DEGREES FOR L1B PRODUCT       STRUCT.LON :          LONGITUDE IN DEGREES FOR L1B PRODUCT   COMMON BLOCKS:       NONE   ");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_quicklook.html", "get_viirs_quicklook.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_quicklook.html#GET_VIIRS_QUICKLOOK", "GET_VIIRS_QUICKLOOK", 'routine in <a href="viirs/get_viirs_quicklook.html">get_viirs_quicklook.pro</a>', "get_viirs_quicklook.pro", "", "GET_VIIRS_QUICKLOOK", "      outputs a rgb modisa quicklook with roi overlay if requested   :Calling sequence:       RES = GET_MODISA_QUICKLOOK(FILENAME)   ", "RGB       program generates an rgb colour quicklook (default is grayscale)  ROI       Overlay coordinates of an roi in red (requires icoords)  ICOORDS       A 4-element array of roi geolocation (n,s,e,w)  QL_QUALITY       Quality of jpeg generated (100 = max, 0 = lowest)  VERBOSE        Processing status outputs   FILENAME         A string containing the filename of the product for quicklook generation   ", "          -1", "      1 FJul 2013 - D Marrable       STATUS :        1: nominal, (-1) or 0: error        jpegs are automatically saved in filename folder   :Common blocks:      NONE   ");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_timeseries_plots.html", "get_viirs_timeseries_plots.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_timeseries_plots.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_timeseries_plots.html#GET_VIIRS_TIMESERIES_PLOTS", "GET_VIIRS_TIMESERIES_PLOTS", 'routine in <a href="viirs/get_viirs_timeseries_plots.html">get_viirs_timeseries_plots.pro</a>', "get_viirs_timeseries_plots.pro", "", "GET_VIIRS_TIMESERIES_PLOTS", "", "NO_ZBUFFCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZEVERBOSEOUTPUT_SAV", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/get_viirs_viewing_geometries.html", "get_viirs_viewing_geometries.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "get_viirs_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/get_viirs_viewing_geometries.html#GET_VIIRS_VIEWING_GEOMETRIES", "GET_VIIRS_VIEWING_GEOMETRIES", 'routine in <a href="viirs/get_viirs_viewing_geometries.html">get_viirs_viewing_geometries.pro</a>', "get_viirs_viewing_geometries.pro", "", "GET_VIIRS_VIEWING_GEOMETRIES", "      returns the interpolated viewing_geometries of a modisa image   :Calling sequence:       RES = GET_MODISA_VIEWING_GEOMETRIES(FILENAME)   ", "VERBOSE          - processing status outputs   FILENAME", "          -1", "                  - M BOUVET - PROTOTYPE DIMITRI VERSION       02 DEC 2010 - C KENT   - DIMITRI-2 V1.0       27 APR 2011 - C KENT   - ADDED FULL SWATH EXCEPTION PROCESSING   VALIDATION HISTORY:       01 DEC 2010 - C KENT    - WINDOWS 32-BIT MACHINE IDL 7.1: COMPILATION SUCCESSFUL,                                 PIXEL DATA WITHIN APPROXIMATELY 0.004 DEGREES OF BEAM VISAT       05 JAN 2011 - C KENT    - LINUX 64-BIT MACHINE IDL 8.0: COMPILATION SUCCESSFUL,                                 NO APPARENT DIFFERENCES WHEN COMPARED TO WINDOWS MACHINE        STRUCT.SZA :         - solar zenith angle in degrees       STRUCT.SAA :         - solar azimuth angle in degrees       STRUCT.VZA :         - sensor zenith angle in degrees       STRUCT.VAA :         - sensor azimuth angle in degrees   :COMMON BLOCKS:       NONE   ");
  
  

libdata[libdataItem++] = new Array("toa_simulation/get_wvap_transmission.html", "get_wvap_transmission.pro", '.pro file in <a href="toa_simulation/dir-overview.html">toa_simulation/ directory</a>', "get_wvap_transmission.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("toa_simulation/get_wvap_transmission.html#GET_WVAP_TRANSMISSION", "GET_WVAP_TRANSMISSION", 'routine in <a href="toa_simulation/get_wvap_transmission.html">get_wvap_transmission.pro</a>', "get_wvap_transmission.pro", "", "GET_WVAP_TRANSMISSION", "", "VERBOSEWAVELENGTHS", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/great_circle_distance.html", "great_circle_distance.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "great_circle_distance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/great_circle_distance.html#GREAT_CIRCLE_DISTANCE", "GREAT_CIRCLE_DISTANCE", 'routine in <a href="misc/great_circle_distance.html">great_circle_distance.pro</a>', "great_circle_distance.pro", "", "GREAT_CIRCLE_DISTANCE", "", "DEGREESVERBOSELATALONALATBLONB", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/helpform.html", "helpform.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "helpform.pro", "", "", " NAME:    HELPFORM   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Generate a descriptive string in IDL HELP format   CALLING SEQUENCE:    STRINGS = HELPFORM(NAME, VALUE, [/SHORTFORM,] [/SINGLE,] [WIDTH=width])   DESCRIPTION:     The HELPFORM function converts an IDL data value into a    representation very similar to the format produced by the built-in    command HELP.  Programmers can thus present data types and values    to users in a format they are familiar with.     For example, if the variable A is defined in the following manner,    and HELP is called, then the following transcript will result:       IDL&gt; a = [1,2]      IDL&gt; help, a      A               INT       = Array[2]     The same result can be achieved with the HELPFORM function:       IDL&gt; print, helpform('A', a)      A               INT       = Array[2]     The benefit is that the output of HELPFORM is a string that can be    outputted or reformatted.  This capability is not available in all    versions of IDL.     HELPFORM actually produces *two* forms of output.  The above    output is considered the  long  form, as it appears in the IDL    HELP command, and is the default.  A  short  form can also be    produced, and is very similar to the information that appears in    certain terse IDL error messages.  It is activated by setting the    SHORTFORM keyword.     If the variable name is too long, the HELPFORM may be forced to be    two lines long to have consistent formatting.  In that case a    two-element string is returned.  If a single line is desired, use    the SINGLE keyword, but this comes at the expense of consistent    output formatting.   INPUTS:     NAME - A scalar string containing the name of the IDL variable.           An empty string is permitted.  The name is ignored if the           SHORTFORM keyword is set.     VALUE - Any IDL value to be examined.  VALUE is optional if the            SIZE keyword is passed and uniquely describes the data.            VALUE should be passed for scalars and structures, since            the help form for these values requires additional            information beyond the SIZE.   KEYWORDS:     SIZE - the IDL SIZE descriptor for the value to be printed.           Default: information is taken from VALUE.     SINGLE - if set, then output which would normally             appear on two lines for consistent formatting, appears on             one single line instead.     FULL_STRUCT - if set, then a detailed output is printed for                  structures, similar to HELP, VALUE, /STRUCTURE.     RECURSIVE_STRUCT - if both this keyword and FULL_STRUCT are set,                       and if VALUE itself has sub-structures, then                       print the full contents of those sub-structures                       as well.  The contents will be slightly indented.     SHORTFORM - set this keyword for a shorter output format that can                be used in error messages.     WIDTH - the width of the terminal in characters (used for            formatting).            Default: 80   RETURNS:     An array of strings containing the HELPFORM output, which may have    more than one element depending on the length of NAME, SHORTFORM    and SINGLE.  The helpforms of pointer- and object-typed values    does not include the sequence number, but are otherwise correct.   EXAMPLE:       IDL&gt; print, helpform('A', size=[1,2,1,2])      A               BYTE      = Array[2]      ;; Do not pass VALUE and instead use SIZE to specify the type       IDL&gt; print, helpform('A', size=[1,2,1,2], /shortform)      BYTE     (Array[2])      ;; Compare to the short form, which is meant to be placed in      ;; error messages       IDL&gt; print, helpform('fjsldkfjsldfkjslkdfjslkdfjslkdfjsldkfjk',a)      fjsldkfjsldfkjslkdfjslkdfjslkdfjsldkfjk                       INT       = Array[2]      IDL&gt; print, helpform('fjsldkfjsldfkjslkdfjslkdfjslkdfjsldkfjk',a,/single)      fjsldkfjsldfkjslkdfjslkdfjslkdfjsldkfjk INT       = Array[2]      ;; Compare the long and short forms   SEE ALSO:     INPUTFORM, HELP   MODIFICATION HISTORY:    Written, CM, 13 May 2000    Documented, 04 Jul 2000    Improved output for objects, CM, 11 Jan 2001    Added support for full structure output, CM 08 Feb 2001    Added forward_function declaration for safety, CM 08 Apr 2001    Print more info about POINTER type, CM 08 Apr 2001    Add the RECURSIVE_STRUCT keyword, CM 04 Jan 2009   $Id: helpform.pro,v 1.6 2009/01/04 09:18:18 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/helpform.html#helpform", "helpform", 'routine in <a href="gdl/helpform.html">helpform.pro</a>', "helpform.pro", "", "helpform", "", "sizesingleshortformwidthstructure_nametagformfull_structrecursive_structname0value", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html", "idlgrlegend__define.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "idlgrlegend__define.pro", "", "", " CLASS_NAME:    IDLgrLegend   PURPOSE:    An IDLgrLegend object provides a simple interface for        displaying a list of glyph/box/styled line - text string        tuples.  They are displayed in a single column (default)        with an optional title string and bounding box which can        be filled.   CATEGORY:    Graphics   SUPERCLASSES:        This class inherits from IDLgrModel.   SUBCLASSES:        This class has no subclasses.   CREATION:        See IDLgrLegend::Init   METHODS:        Intrinsic Methods        This class has the following methods:         IDLgrLegend::Cleanup        IDLgrLegend::ComputeDimensions        IDLgrLegend::Init        IDLgrLegend::GetProperty        IDLgrLegend::SetProperty   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 9/26/97   =============================================================   METHODNAME:        IDLgrLegend::Init   PURPOSE:        The IDLgrLegend::Init function method initializes the        legend object.         NOTE: Init methods are special lifecycle methods, and as such        cannot be called outside the context of object creation.  This        means that in most cases, you cannot call the Init method        directly.  There is one exception to this rule: If you write        your own subclass of this class, you can call the Init method        from within the Init method of the subclass.   CALLING SEQUENCE:        Obj = OBJ_NEW('IDLgrLegend'[,aItemNames])         or         Result = oLegend-&gt;[IDLgrLegend::]Init([aItemNames])   OPTIONAL INPUTS:        aItemNames - an array of strings to be used as the displayed                item labels.  The length of this array is used to                determine the number of items to be displayed.  Each                item is defined by taking one element from the                ITEM_NAME, ITEM_TYPE, ITEM_LINESTYLE, ITEM_THICK,                ITEM_COLOR and ITEM_OBJECT vectors.  IF the number                of items (as defined by the ITEM_NAME array) exceeds                any of the attribute vectors, the attribute defaults                will be used for any additional items.   KEYWORD PARAMETERS:        BORDER_GAP(Get,Set): Set this keyword to a float value to indicate                the amount of blank space to be placed around the outside                of the glyphs and text items.  The units for this keyword                are in fraction of the legend label font height.  The                default is 0.1 (10% of the label font height).        COLUMNS(Get,Set): Set this keyword to an integer value to indicate                the number of columns the legend items should be displayed                in.  The default is 1.        FILL_COLOR(Get,Set): Set this keyword to the color to be used                to fill the legend background box.  The color may be                specified as a color lookup table index or as an RGB                vector.  The default is [255,255,255].        FONT(Get,Set): Set this keyword to an instance of an IDLgrFont                object class to describe the font to use to draw the                legend labels.  The default is 12 point Helvetica.                NOTE: If the default font is in use, retrieving the value                of the FONT property (using the GetProperty method)                will return a null object.        GAP(Get,Set): Set this keyword to a float value to indicate the                blank space to be placed vertically between each legend                item.  The units for this keyword are in fraction of the                legend label font height.  The default is 0.1 (10% of                the label font height).  This same gap is placed                horizontally between the legend glyph and the legend                text string.        GLYPH_WIDTH(Get,Set): Set this keyword to a float value to                indicate the width of the glyphs.  The units for this                keyword are a percentage of the font height.  The                default value is .8 (80%).        HIDE(Get,Set): Set this keyword to a boolean value to indicate                whether this object should be drawn. 0=Draw (default),                1=Hide.        ITEM_COLOR(Get,Set): Set this keyword to an array of colors                defining the color of each item.  This array can be of                the form [3,M] or [M] which defines M separate colors.                In the first case, the three values are used as an RGB                triplet, in the second case, the single value is used                as a color index value.  The default color is: [0,0,0].        ITEM_LINESTYLE(Get,Set): Set this keyword to an array of integers                defining the style of the line to be drawn if the TYPE                is 0.  The array can be of the form [M] or [2,M].  The                first form selects the linestyle for each legend item                from the predefined defaults:                     0=Solid line (the default)                     1=dotted                     2=dashed                     3=dash dot                     4=dash dot dot dot                     5=long dash                     6=no line drawn                The second form specifies the stippling pattern explicity                for each legend item (see IDLgrPolyline::Init LINESTYLE                keyword for details).        ITEM_NAME(Get,Set): Set this keyword to an array of strings.  This                keyword is the same as the aItemNames argument for the                IDLgrLegend::Init method.        ITEM_OBJECT(Get,Set): Set this keyword to an array of object                references.  These can be objects of type IDLgrSymbol                or IDLgrPattern.  A symbol object is drawn only if the                TYPE is 0.  A pattern object is used when drawing the                color patch if the TYPE is 1.  The default is the null                object.        ITEM_THICK(Get,Set): Set this keyword to an array of floats which                define the thickness of each item line (TYPE=0) in points.                The default is 1 point.        ITEM_TYPE(Get,Set): Set this keyword to an array of integers which                define the type of glyph to be displayed for each item.                0=line type (default), 1=filled box type.        NAME(Get,Set): Set this keyword to a string representing the name                to be associated with this object.  The default is the                null string, ''.        OUTLINE_COLOR(Get,Set): Set this keyword to the color to be used                to draw the legend outline box.  The color may be specified                as a color lookup table index or as an RGB vector.  The                default is [0,0,0].        OUTLINE_THICK(Get,Set): Set this keyword to an integer which defines                the thickness of the legend outline box.  Default = 1 point.        SHOW_OUTLINE(Get,Set): Set this keyword to a boolean value indicating                whether the outline box should be displayed.  0=Do not                display outline (default), 1=Display outline.        SHOW_FILL(Get,Set): Set this keyword to a boolean value indicating                whether the background should be filled with a color. 0=Do not                fill background (default), 1=fill background.        TEXT_COLOR(Get,Set): Set this keyword to the color to be used to                draw the legend item text.  The color may be specified                as a color lookup table index or as an RGB vector.  The                default is [0,0,0].        TITLE(Get,Set): Set this keyword to an instance of the IDLgrText                object class to specify the title for the legend.  The                default is the null object, specifying that no title is                drawn.  The title will be centered at the top of the                legend, even if the text object itself has an associated                location.        UVALUE(Get,Set): Set this keyword to a value of any type.  You                may use this value to contain any information you wish.        XCOORD_CONV(Get,Set): Set this keyword to a vector, [t,s],                indicating the translation and scaling to be applied                to convert the X coordinates to an alternate data space.                The formula for the conversion is as follows:                converted X = t + s*X.  The default is [0,1].        YCOORD_CONV(Get,Set): Set this keyword to a vector, [t,s],                indicating the translation and scaling to be applied                to convert the Y coordinates to an alternate data space.                The formula for the conversion is as follows:                converted Y = t + s*Y.  The default is [0,1].        ZCOORD_CONV(Get,Set): Set this keyword to a vector, [t,s],                indicating the translation and scaling to be applied                to convert the Y coordinates to an alternate data space.                The formula for the conversion is as follows:                converted Y = t + s*Y.  The default is [0,1].  OUTPUTS:        1: successful, 0: unsuccessful.   EXAMPLE:        oLegend = OBJ_NEW('IDLgrLegend')   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 9/26/97   =============================================================   METHODNAME:        IDLgrLegend::DefaultArrays   PURPOSE:        The IDLgrLegend::DefaultArrays procedure method is a private        method and is not intended to be called directly.   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 9/30/97   =============================================================   METHODNAME:        IDLgrLegend::CreateGlyphs   PURPOSE:        The IDLgrLegend::CreateGlyphs procedure method is a private        method and is not intended to be called directly.   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 9/30/97   =============================================================   METHODNAME:        IDLgrLegend::ComputeDimensions   PURPOSE:        The IDLgrLegend::ComputeDimensions method function        computes and returns the dimensions of the legend        for a given destination.   CALLING SEQUENCE:        Result = oLegend-&gt;[IDLgrLegend::]ComputeDimensions(SrcDest)   INPUTS:        SrcDest - A destination object.   EXAMPLE:        dimensions = oLegend-&gt;ComputeDimensions(oSrcDest)   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 10/17/97   =============================================================   METHODNAME:        IDLgrLegend::Draw   PURPOSE:        The IDLgrLegend::Draw procedure method is a private        method and is not to be called directly.   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 10/1/97   =============================================================   METHODNAME:        IDLgrLegend::Cleanup   PURPOSE:        The IDLgrLegend::Cleanup procedure method preforms all cleanup        on the object.         NOTE: Cleanup methods are special lifecycle methods, and as such        cannot be called outside the context of object destruction.  This        means that in most cases, you cannot call the Cleanup method        directly.  There is one exception to this rule: If you write        your own subclass of this class, you can call the Cleanup method        from within the Cleanup method of the subclass.   CALLING SEQUENCE:        OBJ_DESTROY, oLegend         or         oLegend-&gt;[IDLgrLegend::]Cleanup   INPUTS:        There are no inputs for this method.   KEYWORD PARAMETERS:        There are no keywords for this method.   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 9/26/97   =============================================================   METHODNAME:        IDLgrLegend::SetProperty   PURPOSE:        The IDLgrLegend::SetProperty procedure method sets the value        of a property or group of properties for the legend.   CALLING SEQUENCE:        oLegend-&gt;[IDLgrLegend::]SetProperty   INPUTS:        There are no inputs for this method.   KEYWORD PARAMETERS:        Any keyword to IDLgrLegend::Init followed by the word  Set         can be set using IDLgrLegend::SetProperty.   EXAMPLE:        myLegend-&gt;SetProperty, NAME = 'My Legend'   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 9/26/97   =============================================================   METHODNAME:        IDLgrLegend::GetProperty   PURPOSE:        The IDLgrLegend::GetProperty procedure method retrieves the        value of a property or group of properties for the legend.   CALLING SEQUENCE:        oLegend-&gt;[IDLgrLegend::]GetProperty   INPUTS:        There are no inputs for this method.   KEYWORD PARAMETERS:        Any keyword to IDLgrLegend::Init or IDLgrModel::init followed by the        word  Get  can be retrieved using IDLgrLegend::GetProperty.  In        addition the following keywords are available:         ALL:    Set this keyword to a named variable that will contain                an anonymous structure containing the values of all the                retrievable properties associated with this object.                NOTE: UVALUE is not returned in this struct.        XRANGE: Set this keyword to a named variable that will contain                a two-element vector of the form [xmin,xmax] specifying                the range of the x data coordinates covered by the Legend.        YRANGE: Set this keyword to a named variable that will contain                a two-element vector of the form [ymin,ymax] specifying                the range of the y data coordinates covered by the Legend.        ZRANGE: Set this keyword to a named variable that will contain                a two-element vector of the form [zmin,zmax] specifying                the range of the z data coordinates covered by the Legend.   EXAMPLE:        oLegend-&gt;GetProperty, PARENT = parent   MODIFICATION HISTORY:    Written by: Scott J. Lasica, 9/26/97  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend::Init", "IDLgrLegend::Init", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend::Init", "", "BORDER_GAPCOLUMNSFILL_COLORFONTGAPGLYPH_WIDTHHIDEITEM_COLORITEM_LINESTYLEITEM_NAMEITEM_OBJECTITEM_THICKITEM_TYPEITEM_RGBNAMEOUTLINE_COLOROUTLINE_THICKSHOW_OUTLINESHOW_FILLTEXT_COLORTITLEUVALUEXCOORD_CONVYCOORD_CONVZCOORD_CONV_EXTRAaItemNames", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend::DefaultArrays", "IDLgrLegend::DefaultArrays", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend::DefaultArrays", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend::CreateGlyphs", "IDLgrLegend::CreateGlyphs", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend::CreateGlyphs", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend::ComputeDimensions", "IDLgrLegend::ComputeDimensions", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend::ComputeDimensions", "", "PATHoSrcDest", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend::Draw", "IDLgrLegend::Draw", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend::Draw", "", "oSrcDestoView", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend::Cleanup", "IDLgrLegend::Cleanup", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend::Cleanup", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend::SetProperty", "IDLgrLegend::SetProperty", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend::SetProperty", "", "BORDER_GAPCOLUMNSFILL_COLORFONTGAPGLYPH_WIDTHITEM_COLORITEM_LINESTYLEITEM_NAMEITEM_OBJECTITEM_THICKITEM_TYPEITEM_RGBRECOMPUTEOUTLINE_COLOROUTLINE_THICKSHOW_OUTLINESHOW_FILLTEXT_COLORTITLEXCOORD_CONVYCOORD_CONVZCOORD_CONV_EXTRA", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend::GetProperty", "IDLgrLegend::GetProperty", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend::GetProperty", "", "ALLBORDER_GAPCOLUMNSFILL_COLORFONTGAPGLYPH_WIDTHITEM_COLORITEM_LINESTYLEITEM_NAMEITEM_OBJECTITEM_THICKITEM_TYPEOUTLINE_COLOROUTLINE_THICKSHOW_OUTLINESHOW_FILLTEXT_COLORTITLEXCOORD_CONVYCOORD_CONVZCOORD_CONVXRANGEYRANGEZRANGE_REF_EXTRA", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/idlgrlegend__define.html#IDLgrLegend__Define", "IDLgrLegend__Define", 'routine in <a href="misc/idlgrlegend__define.html">idlgrlegend__define.pro</a>', "idlgrlegend__define.pro", "", "IDLgrLegend__Define", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("aatsr/ingest_aatsr_product.html", "ingest_aatsr_product.pro", '.pro file in <a href="aatsr/dir-overview.html">aatsr/ directory</a>', "ingest_aatsr_product.pro", "", "", "    :VALIDATION HISTORY:         08 DEC 2010 - C KENT    - WINDOWS 32BIT MACHINE IDL 7.1: COMPILATION AND EXECUTION                                   SUCCESSFUL. OPERATION TESTED MULTIPLE OPTIONS ON MULTIPLE                                   PRODUCTS         12 APR 2011 - C KENT    - LINUX 64BIT MACHINE IDL 8.0: COMPILATION AND OPERATION SUCCESSFUL  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("aatsr/ingest_aatsr_product.html#INGEST_AATSR_PRODUCT", "INGEST_AATSR_PRODUCT", 'routine in <a href="aatsr/ingest_aatsr_product.html">ingest_aatsr_product.pro</a>', "ingest_aatsr_product.pro", "", "INGEST_AATSR_PRODUCT", "   ingests aatsr l1b data into dimitri database. multiple product    extraction is available but it expects all files to be the same region/processing.    outputs quicklook images, updates database and appends data to sav file for    specified region and processing.   ", "INPUT_FOLDER        a string containing the full path of the 'input' folder, if not provided then it is derived from the filename   ICOORDS        a four element floating-point array containing the north, south, east and west coordinates of the roi, e.g [50.,45.,10.,0.]   ENDIAN_SZE        machine endian size (0: little, 1: big), if not provided then computed.   COLOUR_TABLE        user defined idl colour table index (default is 39)   PLOT_XSIZE        width of generated plots (default is 700px)   PLOT_YSIZE        height of generated plots (default is 400px)   NO_ZBUFF        if set then plots are generated in windows and not wihtin the z-buffer.   NO_QUICKLOOK         IF SET THEN QUICKLOOKS ARE NOT GENERATED FOR IFILES.   VERBOSE        PROCESSING STATUS OUTPUTS   IFILES        a string or string array of the full path filenames of products for ingestion.   ", "          -1", "                      M BOUVET  - PROTOTYPE DIMITRI VERSION         08 DEC 2010 - C KENT    - DIMITRI-2 V1.0         08 DEC 2010 - C KENT    - UPDATED REFLECTANCE CALCULATION SECTION         20 DEC 2010 - C KENT    - MINOR CHANGES TO COMMENTS         07 JAN 2011 - C KENT    - UPDATED ROI PIXEL RECORDING DUE TO MULTIPLE ANGLES         10 JAN 2011 - C KENT    - CHANGED SAVED OUTPUT VARIABLE TO SENSOR_L1B_REF         12 JAN 2011 - C KENT    - OUTPUT RGB QUICKLOOKS AS DEFUALT, UPDATED OUTPUT DATA                                   WITH SAA AND VAA (REMOVED RAA)         21 MAR 2011 - C KENT    - MODIFIED FILE DEFINITION TO USE GET_DIMITRI_LOCATION         22 MAR 2011 - C KENT    - ADDED CONFIGURAITON FILE DEPENDENCE         01 JUL 2011 - C KENT    - ADDED ANGLE CORRECTOR         04 JUL 2011 - C KENT    - ADDED AUX INFO TO OUTPUT SAV         12 JUL 2011 - C KENT    - FIXED LAT/LON AND ANGLE EXTRACTION BUG         14 JUL 2011 - C KENT    - UPDATED TIME EXTRACTION SECTION         12 SEP 2011 - C KENT    - ADDED NETCDF OUTPUT STRUCTURE         08 MAR 2012 - C KENT    - ADDED ROI COVERAGE         STATUS  - 1: no errors reported, (-1) or 0: errors during ingestion   ");
  
  

libdata[libdataItem++] = new Array("atsr2/ingest_atsr2_product.html", "ingest_atsr2_product.pro", '.pro file in <a href="atsr2/dir-overview.html">atsr2/ directory</a>', "ingest_atsr2_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("atsr2/ingest_atsr2_product.html#INGEST_ATSR2_PRODUCT", "INGEST_ATSR2_PRODUCT", 'routine in <a href="atsr2/ingest_atsr2_product.html">ingest_atsr2_product.pro</a>', "ingest_atsr2_product.pro", "", "INGEST_ATSR2_PRODUCT", "", "INPUT_FOLDERICOORDSENDIAN_SZECOLOUR_TABLEPLOT_XSIZEPLOT_YSIZENO_ZBUFFNO_QUICKLOOKVERBOSEIFILES", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/ingest_meris_product.html", "ingest_meris_product.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "ingest_meris_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/ingest_meris_product.html#INGEST_MERIS_PRODUCT", "INGEST_MERIS_PRODUCT", 'routine in <a href="meris/ingest_meris_product.html">ingest_meris_product.pro</a>', "ingest_meris_product.pro", "", "INGEST_MERIS_PRODUCT", "", "INPUT_FOLDERICOORDSENDIAN_SZECOLOUR_TABLEPLOT_XSIZEPLOT_YSIZENO_ZBUFFNO_QUICKLOOKVERBOSEIFILES", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/ingest_modisa_product.html", "ingest_modisa_product.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "ingest_modisa_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/ingest_modisa_product.html#INGEST_MODISA_PRODUCT", "INGEST_MODISA_PRODUCT", 'routine in <a href="modisa/ingest_modisa_product.html">ingest_modisa_product.pro</a>', "ingest_modisa_product.pro", "", "INGEST_MODISA_PRODUCT", "", "INPUT_FOLDERICOORDSCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZENO_ZBUFFNO_QUICKLOOKVERBOSEIFILES", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/ingest_modisa_product_linux.html", "ingest_modisa_product_linux.pro", '.pro file in <a href="modisa/dir-overview.html">modisa/ directory</a>', "ingest_modisa_product_linux.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/ingest_modisa_product_linux.html#INGEST_MODISA_PRODUCT_LINUX", "INGEST_MODISA_PRODUCT_LINUX", 'routine in <a href="modisa/ingest_modisa_product_linux.html">ingest_modisa_product_linux.pro</a>', "ingest_modisa_product_linux.pro", "", "INGEST_MODISA_PRODUCT_LINUX", "", "INPUT_FOLDERICOORDSCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZENO_ZBUFFNO_QUICKLOOKVERBOSEIFILES", "          -1", "");
  
  

libdata[libdataItem++] = new Array("parasol/ingest_parasol_product.html", "ingest_parasol_product.pro", '.pro file in <a href="parasol/dir-overview.html">parasol/ directory</a>', "ingest_parasol_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("parasol/ingest_parasol_product.html#INGEST_PARASOL_PRODUCT", "INGEST_PARASOL_PRODUCT", 'routine in <a href="parasol/ingest_parasol_product.html">ingest_parasol_product.pro</a>', "ingest_parasol_product.pro", "", "INGEST_PARASOL_PRODUCT", "", "INPUT_FOLDERICOORDSENDIAN_SZECOLOUR_TABLEPLOT_XSIZEPLOT_YSIZENO_ZBUFFNO_QUICKLOOKVERBOSEIFILES", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/ingest_vegetation_product.html", "ingest_vegetation_product.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "ingest_vegetation_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/ingest_vegetation_product.html#INGEST_VEGETATION_PRODUCT", "INGEST_VEGETATION_PRODUCT", 'routine in <a href="vegetation/ingest_vegetation_product.html">ingest_vegetation_product.pro</a>', "ingest_vegetation_product.pro", "", "INGEST_VEGETATION_PRODUCT", "", "INPUT_FOLDERICOORDSCOLOUR_TABLEPLOT_XSIZEPLOT_YSIZENO_ZBUFFNO_QUICKLOOKVERBOSEIFILES", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/ingest_viirs_product.html", "ingest_viirs_product.pro", '.pro file in <a href="viirs/dir-overview.html">viirs/ directory</a>', "ingest_viirs_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/ingest_viirs_product.html#INGEST_VIIRS_PRODUCT", "INGEST_VIIRS_PRODUCT", 'routine in <a href="viirs/ingest_viirs_product.html">ingest_viirs_product.pro</a>', "ingest_viirs_product.pro", "", "INGEST_VIIRS_PRODUCT", "", "INPUT_FOLDER          - A String containing the full path of the 'input' folder, if                           not provided then it is derived from the filename  ICOORDS           - A four element floating-point array containing the north, south,                           east and west coordinates of the roi, e.g [50.,45.,10.,0.]  COLOUR_TABLE           - User defined idl colour table index (default is 39)  PLOT_XSIZE             - Width of generated plots (default is 700px)  PLOT_YSIZE             - Height of generated plots (default is 400px)  NO_ZBUFF               - If set then plots are generated in windows and not wihtin the z-buffer.  NO_QUICKLOOK          - If set then quicklooks are not generated for ifiles.  VERBOSE               - Processing status outputs   IFILES        A string or string array of the full path filenames of products for ingestion.   ", "          -1", "        02 JUL 2013 - D MARRABLE        STATUS  :       - 1: No errors reported, (-1) or 0: errors during ingestion   :Common blocks:       NONE   ");
  
  

libdata[libdataItem++] = new Array("gdl/inputform.html", "inputform.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "inputform.pro", "", "", " NAME:    INPUTFORM   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Generates expression string from an IDL value   CALLING SEQUENCE:    STRING = INPUTFORM(VALUE, ERRMSG=ERRMSG, STATUS=STATUS, ...)   DESCRIPTION:     The INPUTFORM function converts an IDL data value into its string    representation, suitable for execution at the IDL command line or    with EXECUTE().  This is similar to the  InForm  output    representation of Mathematica, which formats output so that it can    be entered again on the command line.  INPUTFORM() is a    specialized form of STRING().     For example, the value DBLARR(2,2) has the default representation        '[[0D,0],[0D,0]]'     The formal goal of INPUTFORM is for the resulting textual    expression to be an exact representation of the original data.    Several other output options can be selected by using the /ZERO or    /ARRAY_NOTATION keywords.     Therefore, given the original value VARIABLE, then after executing        R = EXECUTE( 'variable1 = '+INPUTFORM(variable) )     The value, type, and dimension of VARIABLE1 and VARIABLE will be    the same.     Such behavior might useful in several circumstances:        * for printing values meant to be  pasted  back into the         command line by the user;       * for constructing command arguments to be EXECUTE()'d;       * for saving values in ASCII format for later execution.   OUTPUT OPTIONS:     The output of INPUTFORM can be controlled in the following ways.    See the EXAMPLES section for examples of each kind of behavior.        * By default, the output will replicate the exact values of the         input;       * If the /ZERO keyword parameter is set, then the output will         match the type and structure of the input, but all values         will be zero or blank, including IDL strings and structures.         This is useful if one wants to make a  blank template  from         an existing IDL data structure.       * If the /ARRAY_NOTATION keyword parameter is set, then any         input arrays are converted to INTARR(), DBLARR(), STRARR().         Scalars appear as in the input.  Obviously the contents of         arrays will be zero/blank in this case.  The combination of         /ZERO and /ARRAY_NOTATION produces a nice short-hand         blank template.   LIMITATIONS:     It should be noted that the IDL parser is not perfect.    While IDL has many data types, not all expressions are    representable as a textual string.  Pointers and objects can be    represented.  Examples of the parser limitation include,        * array expressions can have no more than 90 elements;       * bracketed array notation cannot be nested too deeply;       * anonymous structure arrays have no textual representation;     Given these limitations, the user of this routine must be prepared    for failure and have contingency plans.  Error messages and status    indicators are provided to facilitate this.  INPUTFORM() does not    call MESSAGE, so it should never intentionally crash.     Also, consider that the textual representation can never really be    suitable for very large arrays.  The internal algorithm is thus    not optimized for speed as heavily numeric routines might be, and    instead tries to make the output slightly more readable.   INPUTS:     VALUE - the IDL value to be converted.  Any value which has a            legal textual representation is permitted.   KEYWORDS:     ARRAY_NOTATION - if set, then any arrays in the input will be             replaced by their xxxARR() equivalent.     STATUS - upon return, a status indicator.  A value of zero             indicates failure; one indicates success.     ERRMSG - upon return, a string message indicating the reason for a             failure, if any.  The empty string ('') indicates             success.     MAX_DIMENSIONS - maximum number of array dimensions permitted in                     VALUE.  The conversion fails if the maximum is                     exceeded.                     Default: any number of dimensions is permitted.                      NOTE: IDL does not permit deep nesting, for                     dimensions greater than three.     MAX_ELEMENTS - maximum number of elements permitted in VALUE.  The                   conversion fails if the maximum is exceeded.                   Default: any number of elements is permitted.                    NOTE: the conversion may still fail if any array                   dimension exceeds 90.     MAX_LEN - approximate maximum length of returned string.  If large              string expressions exceed this size as they are being              composed internally, they will be terminated by a '...'              ellipsis and returned.  This value is to be used as a              guideline by INPUTFORM(); the precise limit may not be              adhered to.              Default: 16384L     MAX_TAGS - maximum number of structure tags permitted in VALUE.               The conversion fails if the maximum is exceeded.               Default: any number of tags is permitted.     N_FLOAT - for floating point numerical values, N_FLOAT gives the              number of decimal digits to print.  By definition,              setting this keyword will involve the loss of some              precision compared to the original value.              Default: full precision is printed.     ZERO - if set, then the output command will have zero values for           all fields, regardless of the contents of the input data.   RETURNS:    The resulting converted string, if successful.  Upon failure,    STATUS is set to zero and the empty string ('') is returned.   EXAMPLE:     Convert a double array to text using the default output option,      IDL&gt; x = [[1,2],[3,4]]      IDL&gt; print, inputform(x)      ---&gt;   [[1,2],[3,4]]     The same input, but using the /ZERO and /ARRAY_NOTATION options,      IDL&gt; print, inputform(x, /zero)      ---&gt;   [[0,0],[0,0]]      IDL&gt; print, inputform(x, /array_notation)      ---&gt;   INTARR(2L,2L)     Convert a structure,      IDL&gt; y = create_struct('s1',5,'s2','strvalue','s3',[1,2,3])      IDL&gt; print, inputform(y)      ---&gt;   [{S1:5,S2:'strvalue',S3:[1,2,3]}]     Also with /ZERO and /ARRAY_NOTATION options,      IDL&gt; print, inputform(y, /zero)      ---&gt;   {S1:0,S2:'',S3:[0,0,0]}      IDL&gt; print, inputform(y, /array_notation)      ---&gt;   {S1:5,S2:'strvalue',S3:INTARR(3L)}      (Note that in the final case with /ARRAY_NOTATION alone, S3 is       replaced by INTARR(), but that the scalars are left unchanged.)      IDL&gt; print, inputform(y, /zero, /array_notation)      ---&gt;   {S1:0,S2:'',S3:INTARR(3L)}      (With /ZERO and /ARRAY_NOTATION combined, then all fields are       zero or blank).   SEE ALSO:     STRING, PRINT, HELP, HELPFORM   MODIFICATION HISTORY:    Written, CM, 10 Apr 2000    Added HELPFORM to SEE ALSO, CM, 04 Jul 2000    Corrected case of scalar float value, CM, 13 Jul 2000    Put a space after float types like 1E or 1D to ease parsing, CM,      18 Jul 2000    Add ability to print INPUTFORM of pointers, CM, 09 Dec 2002    Add ability to print INPUTFORM of object pointers, CM, 01 Oct 2003    Bug fix: actually obey MAX_ELEMENTS (was being ignored), CM, 22      Oct 2006    Change to square-bracket array syntax, CM, 27 Feb 2007    Add the ZERO and ARRAY_NOTATION keywords; handle NAN and INFINITY      values properly, CM, 02 Jun 2009    Add N_FLOAT keyword, CM, 13 Nov 2010    $Id: inputform.pro,v 1.8 2010/11/13 09:27:36 cmarkwar Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_int", "inputform_int", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_int", "", "zeroxformat", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_float", "inputform_float", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_float", "", "dconvertzeronfloatxformat", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_string", "inputform_string", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_string", "", "zerox", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_struct", "inputform_struct", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_struct", "", "statuserrmsgzeroarray_notationnocatchnfloatdata", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_ptr", "inputform_ptr", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_ptr", "", "zeroxtp", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_basic", "inputform_basic", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_basic", "", "statuserrmsgsizeroarray_notationnocatchnfloatx", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_array1", "inputform_array1", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_array1", "", "typedims", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_array", "inputform_array", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_array", "", "statuserrmsgsix", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform_brackets", "inputform_brackets", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform_brackets", "", "sistatuserrmsgslr", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/inputform.html#inputform", "inputform", 'routine in <a href="gdl/inputform.html">inputform.pro</a>', "inputform.pro", "", "inputform", "", "errmsgstatusmax_elementsmax_dimensionsmax_tagsmax_lenarray_notationzeron_float_digitsnocatchdata", "          -1", "");
  
  

libdata[libdataItem++] = new Array("intercal/intercalibrate_doublets.html", "intercalibrate_doublets.pro", '.pro file in <a href="intercal/dir-overview.html">intercal/ directory</a>', "intercalibrate_doublets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("intercal/intercalibrate_doublets.html#INTERCALIBRATE_DOUBLETS", "INTERCALIBRATE_DOUBLETS", 'routine in <a href="intercal/intercalibrate_doublets.html">intercalibrate_doublets.pro</a>', "intercalibrate_doublets.pro", "", "INTERCALIBRATE_DOUBLETS", "", "VERBOSEOUTPUT_FOLDERID_REGIONSENSOR1PROC_VER1BID1SENSOR2PROC_VER2BID2", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/julday.html", "julday.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "julday.pro", "", "", " NAME: 	JULDAY   PURPOSE: 	Calculate the Julian Day Number for a given month, day, and year. 	This is the inverse of the library function CALDAT. 	See also caldat, the inverse of this function.   CATEGORY: 	Misc.   CALLING SEQUENCE: 	Result = JULDAY([[[[Month, Day, Year], Hour], Minute], Second])   INPUTS: 	MONTH:	Number of the desired month (1 = January, ..., 12 = December).  	DAY:	Number of day of the month.  	YEAR:	Number of the desired year.Year parameters must be valid                values from the civil calendar.  Years B.C.E. are represented                as negative integers.  Years in the common era are represented                as positive integers.  In particular, note that there is no                year 0 in the civil calendar.  1 B.C.E. (-1) is followed by                1 C.E. (1).  	HOUR:	Number of the hour of the day.  	MINUTE:	Number of the minute of the hour.  	SECOND:	Number of the second of the minute.     Note: Month, Day, Year, Hour, Minute, and Second can all be arrays.          The Result will have the same dimensions as the smallest array, or          will be a scalar if all arguments are scalars.   OPTIONAL INPUT PARAMETERS: 	Hour, Minute, Second = optional time of day.   OUTPUTS: 	JULDAY returns the Julian Day Number (which begins at noon) of the 	specified calendar date.  If Hour, Minute, and Second are not specified, 	then the result will be a long integer, otherwise the result is a 	double precision floating point number.   COMMON BLOCKS: 	None.   SIDE EFFECTS: 	None.   RESTRICTIONS: 	Accuracy using IEEE double precision numbers is approximately    1/10000th of a second, with higher accuracy for smaller (earlier)    Julian dates.   MODIFICATION HISTORY: 	Translated from  Numerical Recipies in C , by William H. Press, 	Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling. 	Cambridge University Press, 1988 (second printing).  	AB, September, 1988 	DMS, April, 1995, Added time of day.  CT, April 2000, Now accepts vectors or scalars.  CT, June 2012: Add undocumented PROLEPTIC_GREGORIAN, used by GREG2JUL.      Also rewrote the algorithm using integer arithmetic, for speed.  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/julday.html#JULDAY", "JULDAY", 'routine in <a href="gdl/julday.html">julday.pro</a>', "julday.pro", "", "JULDAY", "", "PROLEPTIC_GREGORIANMONTHDAYYEARHourMinuteSecond", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/julday_to_timestr.html", "julday_to_timestr.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "julday_to_timestr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/julday_to_timestr.html#JULDAY_TO_TIMESTR", "JULDAY_TO_TIMESTR", 'routine in <a href="misc/julday_to_timestr.html">julday_to_timestr.pro</a>', "julday_to_timestr.pro", "", "JULDAY_TO_TIMESTR", "", "JDAY", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/legend.html", "legend.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "legend.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/legend.html#legend", "legend", 'routine in <a href="misc/legend.html">legend.pro</a>', "legend.pro", "", "legend", " NAME:        LEGEND  PURPOSE:        Create an annotation legend for a plot.  EXPLANATION:        NOTE: This procedure is *deprecated* because IDL 8.0 contains a LEGEND()        function written in IDL.   Both can be used provided that the one found        later in one's !PATH is  explicitly compiled in one's startup file.        However we strongly recommend the use of AL_LEGEND, which is identical        in use to LEGEND.    legend.pro will eventually be removed from future        releases of the IDL Astron library.         This procedure makes a legend for a plot.  The legend can contain        a mixture of symbols, linestyles, Hershey characters (vectorfont),        and filled polygons (usersym).  A test procedure, legendtest.pro,        shows legend's capabilities.  Placement of the legend is controlled        with keywords like /right, /top, and /center or by using a position        keyword for exact placement (position=[x,y]) or via mouse (/position).  CALLING SEQUENCE:        LEGEND [,items][,keyword options]  EXAMPLES:        The call:                legend,['Plus sign','Asterisk','Period'],psym=[1,2,3]          produces:                -----------------                |               |                |  + Plus sign  |                |  * Asterisk   |                |  . Period     |          Each symbol is drawn with a plots command, so they look OK.          Other examples are given in optional output keywords.                 |               |         lines = indgen(6)                       ; for line styles        items = 'linestyle '+strtrim(lines,2)   ; annotations        legend,items,linestyle=lines            ; vertical legend---upper left        items = ['Plus sign','Asterisk','Period']        sym = [1,2,3]        legend,items,psym=sym                   ; ditto except using symbols        legend,items,psym=sym,/horizontal       ; horizontal format        legend,items,psym=sym,box=0             ; sans border        legend,items,psym=sym,delimiter='='     ; embed '=' betw psym & text        legend,items,psym=sym,margin=2          ; 2-character margin        legend,items,psym=sym,position=[x,y]    ; upper left in data coords        legend,items,psym=sym,pos=[x,y],/norm   ; upper left in normal coords        legend,items,psym=sym,pos=[x,y],/device ; upper left in device coords        legend,items,psym=sym,/position         ; interactive position        legend,items,psym=sym,/right            ; at upper right        legend,items,psym=sym,/bottom           ; at lower left        legend,items,psym=sym,/center           ; approximately near center        legend,items,psym=sym,number=2          ; plot two symbols, not one        legend,items,/fill,psym=[8,8,8],colors=[10,20,30]; 3 filled squares  INPUTS:        items = text for the items in the legend, a string array.                For example, items = ['diamond','asterisk','square'].                You can omit items if you don't want any text labels.  OPTIONAL INPUT KEYWORDS:         linestyle = array of linestyle numbers  If linestyle[i] &lt; 0, then omit                ith symbol or line to allow a multi-line entry.     If                linestyle = -99 then text will be left-justified.        psym = array of plot symbol numbers.  If psym[i] is negative, then a                line connects pts for ith item.  If psym[i] = 8, then the                procedure usersym is called with vertices define in the                keyword usersym.   If psym[i] = 88, then use the previously                defined user symbol.    If 11 &lt;= psym[i] &lt;= 46 then David                Fanning's function SYMCAT() will be used for additional symbols.                (http://www.dfanning.com/programs/symcat.pro).   Note that                PSYM=10 (histogram plot mode) is not allowed since it                cannot be used with the PLOTS command.        vectorfont = vector-drawn characters for the sym/line column, e.g.,                ['!9B!3','!9C!3','!9D!3'] produces an open square, a checkmark,                and a partial derivative, which might have accompanying items                ['BOX','CHECK','PARTIAL DERIVATIVE'].                There is no check that !p.font is set properly, e.g., -1 for                X and 0 for PostScript.  This can produce an error, e.g., use                !20 with PostScript and !p.font=0, but allows use of Hershey                *AND* PostScript fonts together.        N. B.: Choose any of linestyle, psym, and/or vectorfont.  If none is                present, only the text is output.  If more than one                is present, all need the same number of elements, and normal                plot behaviour occurs.                By default, if psym is positive, you get one point so there is                no connecting line.  If vectorfont[i] = '',                then plots is called to make a symbol or a line, but if                vectorfont[i] is a non-null string, then xyouts is called.        /help = flag to print header        /horizontal = flag to make the legend horizontal        /vertical = flag to make the legend vertical (D=vertical)        box = flag to include/omit box around the legend (D=include) 		  outline_color = color of box outline (D = !P.color)        bthick = thickness of the legend box (D = !P.thick)        clear = flag to clear the box area before drawing the legend        delimiter = embedded character(s) between symbol and text (D=none)        colors = array of colors for plot symbols/lines (D=!P.color)        font = scalar font graphics keyword (-1,0 or 1) for text        textcolors = array of colors for text (D=!P.color)        margin = margin around text measured in characters and lines        spacing = line spacing (D=bit more than character height)        linsize = Scale factor for line length (0-1), default = 1                  Set to 0 to give a dot, 0.5 give half default line length        pspacing = psym spacing (D=3 characters) (when number of symbols is              greater than 1)        charsize = just like !p.charsize for plot labels        charthick = just like !p.charthick for plot labels        thick = array of line thickness numbers (D = !P.thick), if used, then                linestyle must also be specified        position = data coordinates of the /top (D) /left (D) of the legend        normal = use normal coordinates for position, not data        device = use device coordinates for position, not data        number = number of plot symbols to plot or length of line (D=1)        usersym = 2-D array of vertices, cf. usersym in IDL manual.              (/USERSYM =square, default is to use existing USERSYM definition)        /fill = flag to fill the usersym        /left_legend = flag to place legend snug against left side of plot                  window (D)        /right_legend = flag to place legend snug against right side of plot                window.    If /right,pos=[x,y], then x is position of RHS and                text runs right-to-left.        /top_legend = flag to place legend snug against top of plot window (D)        /bottom = flag to place legend snug against bottom of plot window                /top,pos=[x,y] and /bottom,pos=[x,y] produce same positions.         If LINESTYLE, PSYM, VECTORFONT, THICK, COLORS, or TEXTCOLORS are        supplied as scalars, then the scalar value is set for every line or        symbol in the legend.  Outputs:        legend to current plot device  OPTIONAL OUTPUT KEYWORDS:        corners = 4-element array, like !p.position, of the normalized          coords for the box (even if box=0): [llx,lly,urx,ury].          Useful for multi-column or multi-line legends, for example,          to make a 2-column legend, you might do the following:            c1_items = ['diamond','asterisk','square']            c1_psym = [4,2,6]            c2_items = ['solid','dashed','dotted']            c2_line = [0,2,1]            legend,c1_items,psym=c1_psym,corners=c1,box=0            legend,c2_items,line=c2_line,corners=c2,box=0,pos=[c1[2],c1[3]]            c = [c1[0]&lt;c2[0],c1[1]&lt;c2[1],c1[2]&gt;c2[2],c1[3]&gt;c2[3]]            plots,[c[0],c[0],c[2],c[2],c[0]],[c[1],c[3],c[3],c[1],c[1]],/norm          Useful also to place the legend.  Here's an automatic way to place          the legend in the lower right corner.  The difficulty is that the          legend's width is unknown until it is plotted.  In this example,          the legend is plotted twice: the first time in the upper left, the          second time in the lower right.            legend,['1','22','333','4444'],linestyle=indgen(4),corners=corners                        ; BOGUS LEGEND---FIRST TIME TO REPORT CORNERS            xydims = [corners[2]-corners[0],corners[3]-corners[1]]                        ; SAVE WIDTH AND HEIGHT            chdim=[!d.x_ch_size/float(!d.x_size),!d.y_ch_size/float(!d.y_size)]                        ; DIMENSIONS OF ONE CHARACTER IN NORMALIZED COORDS            pos = [!x.window[1]-chdim[0]-xydims[0] $                        ,!y.window[0]+chdim[1]+xydims[1]]                        ; CALCULATE POSITION FOR LOWER RIGHT            plot,findgen(10)    ; SIMPLE PLOT; YOU DO WHATEVER YOU WANT HERE.            legend,['1','22','333','4444'],linestyle=indgen(4),pos=pos                        ; REDO THE LEGEND IN LOWER RIGHT CORNER          You can modify the pos calculation to place the legend where you          want.  For example to place it in the upper right:            pos = [!x.window[1]-chdim[0]-xydims[0],!y.window[1]-xydims[1]]  Common blocks:        none  Procedure:        If keyword help is set, call doc_library to print header.        See notes in the code.  Much of the code deals with placement of the        legend.  The main problem with placement is not being        able to sense the length of a string before it is output.  Some crude        approximations are used for centering.  Restrictions:        Here are some things that aren't implemented.        - An orientation keyword would allow lines at angles in the legend.        - An array of usersyms would be nice---simple change.        - An order option to interchange symbols and text might be nice.        - Somebody might like double boxes, e.g., with box = 2.        - Another feature might be a continuous bar with ticks and text.        - There are no guards to avoid writing outside the plot area.        - There is no provision for multi-line text, e.g., '1st line!c2nd line'          Sensing !c would be easy, but !c isn't implemented for PostScript.          A better way might be to simply output the 2nd line as another item          but without any accompanying symbol or linestyle.  A flag to omit          the symbol and linestyle is linestyle[i] = -1.        - There is no ability to make a title line containing any of titles          for the legend, for the symbols, or for the text.  Side Effects:  Modification history:        write, 24-25 Aug 92, F K Knight (knight@ll.mit.edu)        allow omission of items or omission of both psym and linestyle, add          corners keyword to facilitate multi-column legends, improve place-          ment of symbols and text, add guards for unequal size, 26 Aug 92, FKK        add linestyle(i)=-1 to suppress a single symbol/line, 27 Aug 92, FKK        add keyword vectorfont to allow characters in the sym/line column,          28 Aug 92, FKK        add /top, /bottom, /left, /right keywords for automatic placement at          the four corners of the plot window.  The /right keyword forces          right-to-left printing of menu. 18 Jun 93, FKK        change default position to data coords and add normal, data, and          device keywords, 17 Jan 94, FKK        add /center keyword for positioning, but it is not precise because          text string lengths cannot be known in advance, 17 Jan 94, FKK        add interactive positioning with /position keyword, 17 Jan 94, FKK        allow a legend with just text, no plotting symbols.  This helps in          simply describing a plot or writing assumptions done, 4 Feb 94, FKK        added thick, symsize, and clear keyword Feb 96, W. Landsman HSTX                David Seed, HR Wallingford, d.seed@hrwallingford.co.uk        allow scalar specification of keywords, Mar 96, W. Landsman HSTX        added charthick keyword, June 96, W. Landsman HSTX        Made keyword names  left,right,top,bottom,center longer,                                  Aug 16, 2000, Kim Tolbert        Added ability to have regular text lines in addition to plot legend        lines in legend.  If linestyle is -99 that item is left-justified.        Previously, only option for no sym/line was linestyle=-1, but then text        was lined up after sym/line column.    10 Oct 2000, Kim Tolbert        Make default value of thick = !P.thick  W. Landsman  Jan. 2001        Don't overwrite existing USERSYM definition  W. Landsman Mar. 2002 	     Added outline_color BT 24 MAY 2004        Pass font keyword to xyouts commands.  M. Fitzgerald, Sep. 2005        Default spacing, pspacing should be relative to charsize. M. Perrin, July 2007        Don't modify position keyword  A. Kimball/ W. Landsman Jul 2007        Small update to Jul 2007 for /NORMAL coords.  W. Landsman Aug 2007        Use SYMCAT() plotting symbols for 11&lt;=PSYM&lt;=46   W. Landsman  Nov 2009        Make a sharper box edge T. Robishaw/W.Landsman July 2010        Added BTHICK keyword W. Landsman October 2010        Added LINESIZ keyword W.L./V.Gonzalez   May 2011  ", "BOTTOM_LEGENDBOXCENTER_LEGENDCHARTHICKCHARSIZECLEARCOLORSCORNERSDATADELIMITERDEVICEFILLHELPHORIZONTALLEFT_LEGENDLINESTYLEMARGINNORMALNUMBERPOSITIONPSPACINGPSYMRIGHT_LEGENDSPACINGSYMSIZETEXTCOLORSTHICKTOP_LEGENDUSERSYMVECTORFONTVERTICALOUTLINE_COLORFONTBTHICKlinsizeitems", "          -1", "");
  
  

libdata[libdataItem++] = new Array("parasol/main.html", "main.pro", '.pro file in <a href="parasol/dir-overview.html">parasol/ directory</a>', "main.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("parasol/main.html#main", "main", 'routine in <a href="parasol/main.html">main.pro</a>', "main.pro", "", "main", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/merge_dimitri_database.html", "merge_dimitri_database.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "merge_dimitri_database.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/merge_dimitri_database.html#MERGE_DIMITRI_DATABASE", "MERGE_DIMITRI_DATABASE", 'routine in <a href="validation/merge_dimitri_database.html">merge_dimitri_database.pro</a>', "merge_dimitri_database.pro", "", "MERGE_DIMITRI_DATABASE", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/move_parasol.html", "move_parasol.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "move_parasol.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/move_parasol.html#MOVE_PARASOL", "MOVE_PARASOL", 'routine in <a href="validation/move_parasol.html">move_parasol.pro</a>', "move_parasol.pro", "", "MOVE_PARASOL", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/mpcurvefit.html", "mpcurvefit.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "mpcurvefit.pro", "", "", " NAME:    MPCURVEFIT   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov    UPDATED VERSIONs can be found on my WEB PAGE:       http://cow.physics.wisc.edu/~craigm/idl/idl.html   PURPOSE:    Perform Levenberg-Marquardt least-squares fit (replaces CURVEFIT)   MAJOR TOPICS:    Curve and Surface Fitting   CALLING SEQUENCE:    YFIT = MPCURVEFIT(X, Y, WEIGHTS, P, [SIGMA,] FUNCTION_NAME=FUNC,                      ITER=iter, ITMAX=itmax,                      CHISQ=chisq, NFREE=nfree, DOF=dof,                      NFEV=nfev, COVAR=covar, [/NOCOVAR, ] [/NODERIVATIVE, ]                      FUNCTARGS=functargs, PARINFO=parinfo,                      FTOL=ftol, XTOL=xtol, GTOL=gtol, TOL=tol,                      ITERPROC=iterproc, ITERARGS=iterargs,                      NPRINT=nprint, QUIET=quiet,                      ERRMSG=errmsg, STATUS=status)   DESCRIPTION:    MPCURVEFIT fits a user-supplied model -- in the form of an IDL   function -- to a set of user-supplied data.  MPCURVEFIT calls   MPFIT, the MINPACK-1 least-squares minimizer, to do the main   work.    Given the data and their uncertainties, MPCURVEFIT finds the best   set of model parameters which match the data (in a least-squares   sense) and returns them in the parameter P.    MPCURVEFIT returns the best fit function.    The user must supply the following items:    - An array of independent variable values ( X ).    - An array of  measured  *dependent* variable values ( Y ).    - An array of weighting values ( WEIGHTS ).    - The name of an IDL function which computes Y given X ( FUNC ).    - Starting guesses for all of the parameters ( P ).    There are very few restrictions placed on X, Y or FUNCT.  Simply   put, FUNCT must map the  X  values into  Y  values given the   model parameters.  The  X  values may represent any independent   variable (not just Cartesian X), and indeed may be multidimensional   themselves.  For example, in the application of image fitting, X   may be a 2xN array of image positions.    MPCURVEFIT carefully avoids passing large arrays where possible to   improve performance.    See below for an example of usage.   USER FUNCTION    The user must define a function which returns the model value.  For   applications which use finite-difference derivatives -- the default   -- the user function should be declared in the following way:      PRO MYFUNCT, X, P, YMOD      ; The independent variable is X      ; Parameter values are passed in  P       YMOD = ... computed model values at X ...     END    The returned array YMOD must have the same dimensions and type as   the  measured  Y values.    User functions may also indicate a fatal error condition   using the ERROR_CODE common block variable, as described   below under the MPFIT_ERROR common block definition.    See the discussion under  ANALYTIC DERIVATIVES  and AUTODERIVATIVE   in MPFIT.PRO if you wish to compute the derivatives for yourself.   AUTODERIVATIVE is accepted and passed directly to MPFIT.  The user   function must accept one additional parameter, DP, which contains   the derivative of the user function with respect to each parameter   at each data point, as described in MPFIT.PRO.   CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD    The behavior of MPFIT can be modified with respect to each   parameter to be fitted.  A parameter value can be fixed; simple   boundary constraints can be imposed; limitations on the parameter   changes can be imposed; properties of the automatic derivative can   be modified; and parameters can be tied to one another.    These properties are governed by the PARINFO structure, which is   passed as a keyword parameter to MPFIT.    PARINFO should be an array of structures, one for each parameter.   Each parameter is associated with one element of the array, in   numerical order.  The structure can have the following entries   (none are required):       .VALUE - the starting parameter value (but see the START_PARAMS               parameter for more information).       .FIXED - a boolean value, whether the parameter is to be held               fixed or not.  Fixed parameters are not varied by               MPFIT, but are passed on to MYFUNCT for evaluation.       .LIMITED - a two-element boolean array.  If the first/second                 element is set, then the parameter is bounded on the                 lower/upper side.  A parameter can be bounded on both                 sides.  Both LIMITED and LIMITS must be given                 together.       .LIMITS - a two-element float or double array.  Gives the                parameter limits on the lower and upper sides,                respectively.  Zero, one or two of these values can be                set, depending on the values of LIMITED.  Both LIMITED                and LIMITS must be given together.       .PARNAME - a string, giving the name of the parameter.  The                 fitting code of MPFIT does not use this tag in any                 way.  However, the default ITERPROC will print the                 parameter name if available.       .STEP - the step size to be used in calculating the numerical              derivatives.  If set to zero, then the step size is              computed automatically.  Ignored when AUTODERIVATIVE=0.              This value is superceded by the RELSTEP value.       .RELSTEP - the *relative* step size to be used in calculating                 the numerical derivatives.  This number is the                 fractional size of the step, compared to the                 parameter value.  This value supercedes the STEP                 setting.  If the parameter is zero, then a default                 step size is chosen.       .MPSIDE - the sidedness of the finite difference when computing                numerical derivatives.  This field can take four                values:                    0 - one-sided derivative computed automatically                   1 - one-sided derivative (f(x+h) - f(x)  )/h                  -1 - one-sided derivative (f(x)   - f(x-h))/h                   2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)                Where H is the STEP parameter described above.  The                automatic  one-sided derivative method will chose a               direction for the finite difference which does not               violate any constraints.  The other methods do not               perform this check.  The two-sided method is in               principle more precise, but requires twice as many               function evaluations.  Default: 0.       .MPMAXSTEP - the maximum change to be made in the parameter                   value.  During the fitting process, the parameter                   will never be changed by more than this value in                   one iteration.                    A value of 0 indicates no maximum.  Default: 0.       .TIED - a string expression which  ties  the parameter to other              free or fixed parameters.  Any expression involving              constants and the parameter array P are permitted.              Example: if parameter 2 is always to be twice parameter              1 then use the following: parinfo(2).tied = '2 * P(1)'.              Since they are totally constrained, tied parameters are              considered to be fixed; no errors are computed for them.              [ NOTE: the PARNAME can't be used in expressions. ]       .MPPRINT - if set to 1, then the default ITERPROC will print the                 parameter value.  If set to 0, the parameter value                 will not be printed.  This tag can be used to                 selectively print only a few parameter values out of                 many.  Default: 1 (all parameters printed)    Future modifications to the PARINFO structure, if any, will involve   adding structure tags beginning with the two letters  MP .   Therefore programmers are urged to avoid using tags starting with   the same letters; otherwise they are free to include their own   fields within the PARINFO structure, and they will be ignored.    PARINFO Example:   parinfo = replicate({value:0.D, fixed:0, limited:[0,0], $                        limits:[0.D,0]}, 5)   parinfo(0).fixed = 1   parinfo(4).limited(0) = 1   parinfo(4).limits(0)  = 50.D   parinfo(*).value = [5.7D, 2.2, 500., 1.5, 2000.]    A total of 5 parameters, with starting values of 5.7,   2.2, 500, 1.5, and 2000 are given.  The first parameter   is fixed at a value of 5.7, and the last parameter is   constrained to be above 50.   INPUTS:    X - Array of independent variable values.     Y - Array of  measured  dependent variable values.  Y should have        the same data type as X.  The function FUNCT should map        X-&gt;Y.     WEIGHTS - Array of weights to be used in calculating the              chi-squared value.  If WEIGHTS is specified then the ERR              parameter is ignored.  The chi-squared value is computed              as follows:                  CHISQ = TOTAL( (Y-FUNCT(X,P))^2 * ABS(WEIGHTS) )               Here are common values of WEIGHTS:                  1D/ERR^2 - Normal weighting (ERR is the measurement error)                 1D/Y     - Poisson weighting (counting statistics)                 1D       - Unweighted     P - An array of starting values for each of the parameters of the        model.  The number of parameters should be fewer than the        number of measurements.  Also, the parameters should have the        same data type as the measurements (double is preferred).         Upon successful completion the new parameter values are        returned in P.         If both START_PARAMS and PARINFO are passed, then the starting        *value* is taken from START_PARAMS, but the *constraints* are        taken from PARINFO.     SIGMA - The formal 1-sigma errors in each parameter, computed from            the covariance matrix.  If a parameter is held fixed, or            if it touches a boundary, then the error is reported as            zero.             If the fit is unweighted (i.e. no errors were given, or            the weights were uniformly set to unity), then SIGMA will            probably not represent the true parameter uncertainties.             *If* you can assume that the true reduced chi-squared            value is unity -- meaning that the fit is implicitly            assumed to be of good quality -- then the estimated            parameter uncertainties can be computed by scaling SIGMA            by the measured chi-squared value.                DOF     = N_ELEMENTS(X) - N_ELEMENTS(P) ; deg of freedom               CSIGMA  = SIGMA * SQRT(CHISQ / DOF)     ; scaled uncertainties   RETURNS:     Returns the array containing the best-fitting function.   KEYWORD PARAMETERS:     CHISQ - the value of the summed, squared, weighted residuals for            the returned parameter values, i.e. the chi-square value.     COVAR - the covariance matrix for the set of parameters returned            by MPFIT.  The matrix is NxN where N is the number of            parameters.  The square root of the diagonal elements            gives the formal 1-sigma statistical errors on the            parameters IF errors were treated  properly  in MYFUNC.            Parameter errors are also returned in PERROR.             To compute the correlation matrix, PCOR, use this:            IDL&gt; PCOR = COV * 0            IDL&gt; FOR i = 0, n-1 DO FOR j = 0, n-1 DO $                 PCOR(i,j) = COV(i,j)/sqrt(COV(i,i)*COV(j,j))             If NOCOVAR is set or MPFIT terminated abnormally, then            COVAR is set to a scalar with value !VALUES.D_NAN.     DOF - number of degrees of freedom, computed as              DOF = N_ELEMENTS(DEVIATES) - NFREE          Note that this doesn't account for pegged parameters (see          NPEGGED).     ERRMSG - a string error or warning message is returned.     FTOL - a nonnegative input variable. Termination occurs when both           the actual and predicted relative reductions in the sum of           squares are at most FTOL (and STATUS is accordingly set to           1 or 3).  Therefore, FTOL measures the relative error           desired in the sum of squares.  Default: 1D-10     FUNCTION_NAME - a scalar string containing the name of an IDL                    procedure to compute the user model values, as                    described above in the  USER MODEL  section.     FUNCTARGS - A structure which contains the parameters to be passed                to the user-supplied function specified by FUNCT via                the _EXTRA mechanism.  This is the way you can pass                additional data to your user-supplied function without                using common blocks.                 By default, no extra parameters are passed to the                user-supplied function.     GTOL - a nonnegative input variable. Termination occurs when the           cosine of the angle between fvec and any column of the           jacobian is at most GTOL in absolute value (and STATUS is           accordingly set to 4). Therefore, GTOL measures the           orthogonality desired between the function vector and the           columns of the jacobian.  Default: 1D-10     ITER - the number of iterations completed.     ITERARGS - The keyword arguments to be passed to ITERPROC via the               _EXTRA mechanism.  This should be a structure, and is               similar in operation to FUNCTARGS.               Default: no arguments are passed.     ITERPROC - The name of a procedure to be called upon each NPRINT               iteration of the MPFIT routine.  It should be declared               in the following way:                PRO ITERPROC, FUNCT, p, iter, fnorm, FUNCTARGS=fcnargs, $                 PARINFO=parinfo, QUIET=quiet, ...                 ; perform custom iteration update               END                ITERPROC must either accept all three keyword               parameters (FUNCTARGS, PARINFO and QUIET), or at least               accept them via the _EXTRA keyword.                FUNCT is the user-supplied function to be minimized,               P is the current set of model parameters, ITER is the               iteration number, and FUNCTARGS are the arguments to be               passed to FUNCT.  FNORM should be the               chi-squared value.  QUIET is set when no textual output               should be printed.  See below for documentation of               PARINFO.                In implementation, ITERPROC can perform updates to the               terminal or graphical user interface, to provide               feedback while the fit proceeds.  If the fit is to be               stopped for any reason, then ITERPROC should set the               common block variable ERROR_CODE to negative value (see               MPFIT_ERROR common block below).  In principle,               ITERPROC should probably not modify the parameter               values, because it may interfere with the algorithm's               stability.  In practice it is allowed.                Default: an internal routine is used to print the                        parameter values.     ITMAX - The maximum number of iterations to perform.  If the              number is exceeded, then the STATUS value is set to 5              and MPFIT returns.              Default: 200 iterations     NFEV - the number of FUNCT function evaluations performed.     NFREE - the number of free parameters in the fit.  This includes            parameters which are not FIXED and not TIED, but it does            include parameters which are pegged at LIMITS.     NOCOVAR - set this keyword to prevent the calculation of the              covariance matrix before returning (see COVAR)     NODERIVATIVE - if set, then the user function will not be queried                   for analytical derivatives, and instead the                   derivatives will be computed by finite differences                   (and according to the PARINFO derivative settings;                   see above for a description).     NPRINT - The frequency with which ITERPROC is called.  A value of             1 indicates that ITERPROC is called with every iteration,             while 2 indicates every other iteration, etc.  Note that             several Levenberg-Marquardt attempts can be made in a             single iteration.             Default value: 1     PARINFO - Provides a mechanism for more sophisticated constraints              to be placed on parameter values.  When PARINFO is not              passed, then it is assumed that all parameters are free              and unconstrained.  Values in PARINFO are never              modified during a call to MPFIT.               See description above for the structure of PARINFO.               Default value:  all parameters are free and unconstrained.     QUIET - set this keyword when no textual output should be printed            by MPFIT     STATUS - an integer status code is returned.  All values other             than zero can represent success.  It can have one of the             following values:  	   0  improper input parameters.  	   1  both actual and predicted relative reductions 	      in the sum of squares are at most FTOL.  	   2  relative error between two consecutive iterates 	      is at most XTOL  	   3  conditions for STATUS = 1 and STATUS = 2 both hold.  	   4  the cosine of the angle between fvec and any 	      column of the jacobian is at most GTOL in 	      absolute value.  	   5  the maximum number of iterations has been reached  	   6  FTOL is too small. no further reduction in 	      the sum of squares is possible.  	   7  XTOL is too small. no further improvement in 	      the approximate solution x is possible.  	   8  GTOL is too small. fvec is orthogonal to the 	      columns of the jacobian to machine precision.     TOL - synonym for FTOL.  Use FTOL instead.     XTOL - a nonnegative input variable. Termination occurs when the           relative error between two consecutive iterates is at most           XTOL (and STATUS is accordingly set to 2 or 3).  Therefore,           XTOL measures the relative error desired in the approximate           solution.  Default: 1D-10     YERROR - upon return, the root-mean-square variance of the             residuals.   EXAMPLE:     ; First, generate some synthetic data    npts = 200    x  = dindgen(npts) * 0.1 - 10.                  ; Independent variable    yi = gauss1(x, [2.2D, 1.4, 3000.])              ;  Ideal  Y variable    y  = yi + randomn(seed, npts) * sqrt(1000. + yi); Measured, w/ noise    sy = sqrt(1000.D + y)                           ; Poisson errors     ; Now fit a Gaussian to see how well we can recover    p0 = [1.D, 1., 1000.]                           ; Initial guess    yfit = mpcurvefit(x, y, 1/sy^2, p0, $           ; Fit a function                      FUNCTION_NAME='GAUSS1P',/autoderivative)    print, p     Generates a synthetic data set with a Gaussian peak, and Poisson    statistical uncertainty.  Then the same function is fitted to the    data to see how close we can get.  GAUSS1 and GAUSS1P are    available from the same web page.   COMMON BLOCKS:     COMMON MPFIT_ERROR, ERROR_CODE       User routines may stop the fitting process at any time by      setting an error condition.  This condition may be set in either      the user's model computation routine (MYFUNCT), or in the      iteration procedure (ITERPROC).       To stop the fitting, the above common block must be declared,      and ERROR_CODE must be set to a negative number.  After the user      procedure or function returns, MPFIT checks the value of this      common block variable and exits immediately if the error      condition has been set.  By default the value of ERROR_CODE is      zero, indicating a successful function/procedure call.   REFERENCES:     MINPACK-1, Jorge More', available from netlib (www.netlib.org).     Optimization Software Guide,  Jorge More' and Stephen Wright,      SIAM, *Frontiers in Applied Mathematics*, Number 14.   MODIFICATION HISTORY:    Translated from MPFITFUN, 25 Sep 1999, CM    Alphabetized documented keywords, 02 Oct 1999, CM    Added QUERY keyword and query checking of MPFIT, 29 Oct 1999, CM    Check to be sure that X and Y are present, 02 Nov 1999, CM    Documented SIGMA for unweighted fits, 03 Nov 1999, CM    Changed to ERROR_CODE for error condition, 28 Jan 2000, CM    Copying permission terms have been liberalized, 26 Mar 2000, CM    Propagated improvements from MPFIT, 17 Dec 2000, CM    Corrected behavior of NODERIVATIVE, 13 May 2002, CM    Documented RELSTEP field of PARINFO (!!), CM, 25 Oct 2002    Make more consistent with comparable IDL routines, 30 Jun 2003, CM    Minor documentation adjustment, 03 Feb 2004, CM    Fix error in documentation, 26 Aug 2005, CM    Convert to IDL 5 array syntax (!), 16 Jul 2006, CM    Move STRICTARR compile option inside each function/procedure, 9 Oct 2006    $Id: mpcurvefit.pro,v 1.9 2006/10/09 19:25:29 craigm Exp $  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/mpcurvefit.html#mpcurvefit_eval", "mpcurvefit_eval", 'routine in <a href="misc/mpcurvefit.html">mpcurvefit.pro</a>', "mpcurvefit.pro", "", "mpcurvefit_eval", "", "_EXTRApdp", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpcurvefit.html#mpcurvefit", "mpcurvefit", 'routine in <a href="misc/mpcurvefit.html">mpcurvefit.pro</a>', "mpcurvefit.pro", "", "mpcurvefit", "", "function_nameiteritmaxchisqnfreedofnfevcovarnocovaryerrornoderivativetolftolFUNCTARGSparinfoerrmsgSTATUSQUIETquery_EXTRAxywtspperror", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/mpfit.html", "mpfit.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "mpfit.pro", "", "", " NAME:    MPFIT   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov    UPDATED VERSIONs can be found on my WEB PAGE:       http://cow.physics.wisc.edu/~craigm/idl/idl.html   PURPOSE:    Perform Levenberg-Marquardt least-squares minimization (MINPACK-1)   MAJOR TOPICS:    Curve and Surface Fitting   CALLING SEQUENCE:    parms = MPFIT(MYFUNCT, start_parms, FUNCTARGS=fcnargs, NFEV=nfev,                  MAXITER=maxiter, ERRMSG=errmsg, NPRINT=nprint, QUIET=quiet,                  FTOL=ftol, XTOL=xtol, GTOL=gtol, NITER=niter,                  STATUS=status, ITERPROC=iterproc, ITERARGS=iterargs,                  COVAR=covar, PERROR=perror, BESTNORM=bestnorm,                  PARINFO=parinfo)   DESCRIPTION:    MPFIT uses the Levenberg-Marquardt technique to solve the   least-squares problem.  In its typical use, MPFIT will be used to   fit a user-supplied function (the  model ) to user-supplied data   points (the  data ) by adjusting a set of parameters.  MPFIT is   based upon MINPACK-1 (LMDIF.F) by More' and collaborators.    For example, a researcher may think that a set of observed data   points is best modelled with a Gaussian curve.  A Gaussian curve is   parameterized by its mean, standard deviation and normalization.   MPFIT will, within certain constraints, find the set of parameters   which best fits the data.  The fit is  best  in the least-squares   sense; that is, the sum of the weighted squared differences between   the model and data is minimized.    The Levenberg-Marquardt technique is a particular strategy for   iteratively searching for the best fit.  This particular   implementation is drawn from MINPACK-1 (see NETLIB), and seems to   be more robust than routines provided with IDL.  This version   allows upper and lower bounding constraints to be placed on each   parameter, or the parameter can be held fixed.    The IDL user-supplied function should return an array of weighted   deviations between model and data.  In a typical scientific problem   the residuals should be weighted so that each deviate has a   gaussian sigma of 1.0.  If X represents values of the independent   variable, Y represents a measurement for each value of X, and ERR   represents the error in the measurements, then the deviates could   be calculated as follows:      DEVIATES = (Y - F(X)) / ERR    where F is the function representing the model.  You are   recommended to use the convenience functions MPFITFUN and   MPFITEXPR, which are driver functions that calculate the deviates   for you.  If ERR are the 1-sigma uncertainties in Y, then      TOTAL( DEVIATES^2 )    will be the total chi-squared value.  MPFIT will minimize the   chi-square value.  The values of X, Y and ERR are passed through   MPFIT to the user-supplied function via the FUNCTARGS keyword.    Simple constraints can be placed on parameter values by using the   PARINFO keyword to MPFIT.  See below for a description of this   keyword.    MPFIT does not perform more general optimization tasks.  See TNMIN   instead.  MPFIT is customized, based on MINPACK-1, to the   least-squares minimization problem.   USER FUNCTION    The user must define a function which returns the appropriate   values as specified above.  The function should return the weighted   deviations between the model and the data.  For applications which   use finite-difference derivatives -- the default -- the user   function should be declared in the following way:      FUNCTION MYFUNCT, p, X=x, Y=y, ERR=err      ; Parameter values are passed in  p       model = F(x, p)      return, (y-model)/err     END    See below for applications with explicit derivatives.    The keyword parameters X, Y, and ERR in the example above are   suggestive but not required.  Any parameters can be passed to   MYFUNCT by using the FUNCTARGS keyword to MPFIT.  Use MPFITFUN and   MPFITEXPR if you need ideas on how to do that.  The function *must*   accept a parameter list, P.    In general there are no restrictions on the number of dimensions in   X, Y or ERR.  However the deviates *must* be returned in a   one-dimensional array, and must have the same type (float or   double) as the input arrays.    See below for error reporting mechanisms.   CHECKING STATUS AND HANNDLING ERRORS    Upon return, MPFIT will report the status of the fitting operation   in the STATUS and ERRMSG keywords.  The STATUS keyword will contain   a numerical code which indicates the success or failure status.   Generally speaking, any value 1 or greater indicates success, while   a value of 0 or less indicates a possible failure.  The ERRMSG   keyword will contain a text string which should describe the error   condition more fully.    By default, MPFIT will trap fatal errors and report them to the   caller gracefully.  However, during the debugging process, it is   often useful to halt execution where the error occurred.  When you   set the NOCATCH keyword, MPFIT will not do any special error   trapping, and execution will stop where ever the error occurred.    MPFIT does not explicitly change the !ERROR_STATE variable   (although it may be changed implicitly if MPFIT calls MESSAGE).  It   is the caller's responsibility to call MESSAGE, /RESET to ensure   that the error state is initialized before calling MPFIT.    User functions may also indicate non-fatal error conditions using   the ERROR_CODE common block variable, as described below under the   MPFIT_ERROR common block definition (by setting ERROR_CODE to a   number between -15 and -1).  When the user function sets an error   condition via ERROR_CODE, MPFIT will gracefully exit immediately   and report this condition to the caller.  The ERROR_CODE is   returned in the STATUS keyword in that case.   EXPLICIT DERIVATIVES    In the search for the best-fit solution, MPFIT by default   calculates derivatives numerically via a finite difference   approximation.  The user-supplied function need not calculate the   derivatives explicitly.  However, the user function *may* calculate   the derivatives if desired, but only if the model function is   declared with an additional position parameter, DP, as described   below.  If the user function does not accept this additional   parameter, MPFIT will report an error.  As a practical matter, it   is often sufficient and even faster to allow MPFIT to calculate the   derivatives numerically, but this option is available for users who   wish more control over the fitting process.    There are two ways to enable explicit derivatives.  First, the user   can set the keyword AUTODERIVATIVE=0, which is a global switch for   all parameters.  In this case, MPFIT will request explicit   derivatives for every free parameter.    Second, the user may request explicit derivatives for specifically   selected parameters using the PARINFO.MPSIDE=3 (see  CONSTRAINING   PARAMETER VALUES WITH THE PARINFO KEYWORD  below).  In this   strategy, the user picks and chooses which parameter derivatives   are computed explicitly versus numerically.  When PARINFO[i].MPSIDE   EQ 3, then the ith parameter derivative is computed explicitly.    The keyword setting AUTODERIVATIVE=0 always globally overrides the   individual values of PARINFO.MPSIDE.  Setting AUTODERIVATIVE=0 is   equivalent to resetting PARINFO.MPSIDE=3 for all parameters.    However, be aware that even if the user requests explicit   derivatives for some or all parameters, MPFIT will not always   request explicit derivatives on ever user function call.   EXPLICIT DERIVATIVES - CALLING INTERFACE    When AUTODERIVATIVE=0, the user function is responsible for   calculating the derivatives of the *residuals* with respect to each   parameter.  The user function should be declared as follows:      ;     ; MYFUNCT - example user function     ;   P - input parameter values (N-element array)     ;   DP - upon input, an N-vector indicating which parameters     ;          to compute derivatives for;     ;        upon output, the user function must return     ;          an ARRAY(M,N) of derivatives in this keyword     ;   (keywords) - any other keywords specified by FUNCTARGS     ; RETURNS - residual values     ;     FUNCTION MYFUNCT, p, dp, X=x, Y=y, ERR=err      model = F(x, p)         ;; Model function      resid = (y - model)/err ;; Residual calculation (for example)       if n_params() GT 1 then begin        ; Create derivative and compute derivative array        requested = dp   ; Save original value of DP        dp = make_array(n_elements(x), n_elements(p), value=x[0]*0)         ; Compute derivative if requested by caller        for i = 0, n_elements(p)-1 do if requested(i) NE 0 then $          dp(*,i) = FGRAD(x, p, i) / err      endif       return, resid     END    where FGRAD(x, p, i) is a model function which computes the   derivative of the model F(x,p) with respect to parameter P(i) at X.    A quirk in the implementation leaves a stray negative sign in the   definition of DP.  The derivative of the *residual* should be    -FGRAD(x,p,i) / err  because of how the residual is defined   ( resid = (data - model) / err ).  **HOWEVER** because of the   implementation quirk, MPFIT expects FGRAD(x,p,i)/err instead,   i.e. the opposite sign of the gradient of RESID.    Derivatives should be returned in the DP array. DP should be an   ARRAY(m,n) array, where m is the number of data points and n is the   number of parameters.  -DP[i,j] is the derivative of the ith   residual with respect to the jth parameter (note the minus sign   due to the quirk described above).    As noted above, MPFIT may not always request derivatives from the   user function.  In those cases, the parameter DP is not passed.   Therefore functions can use N_PARAMS() to indicate whether they   must compute the derivatives or not.    The derivatives with respect to fixed parameters are ignored; zero   is an appropriate value to insert for those derivatives.  Upon   input to the user function, DP is set to a vector with the same   length as P, with a value of 1 for a parameter which is free, and a   value of zero for a parameter which is fixed (and hence no   derivative needs to be calculated).  This input vector may be   overwritten as needed.  In the example above, the original DP   vector is saved to a variable called REQUESTED, and used as a mask   to calculate only those derivatives that are required.    If the data is higher than one dimensional, then the *last*   dimension should be the parameter dimension.  Example: fitting a   50x50 image,  dp  should be 50x50xNPAR.   EXPLICIT DERIVATIVES - TESTING and DEBUGGING    For reasonably complicated user functions, the calculation of   explicit derivatives of the correct sign and magnitude can be   difficult to get right.  A simple sign error can cause MPFIT to be   confused.  MPFIT has a derivative debugging mode which will compute   the derivatives *both* numerically and explicitly, and compare the   results.    It is expected that during production usage, derivative debugging   should be disabled for all parameters.    In order to enable derivative debugging mode, set the following   PARINFO members for the ith parameter.       PARINFO[i].MPSIDE = 3          ; Enable explicit derivatives       PARINFO[i].MPDERIV_DEBUG = 1   ; Enable derivative debugging mode       PARINFO[i].MPDERIV_RELTOL = ?? ; Relative tolerance for comparison       PARINFO[i].MPDERIV_ABSTOL = ?? ; Absolute tolerance for comparison   Note that these settings are maintained on a parameter-by-parameter   basis using PARINFO, so the user can choose which parameters   derivatives will be tested.    When .MPDERIV_DEBUG is set, then MPFIT first computes the   derivative explicitly by requesting them from the user function.   Then, it computes the derivatives numerically via finite   differencing, and compares the two values.  If the difference   exceeds a tolerance threshold, then the values are printed out to   alert the user.  The tolerance level threshold contains both a   relative and an absolute component, and is expressed as,       ABS(DERIV_U - DERIV_N) GE (ABSTOL + RELTOL*ABS(DERIV_U))    where DERIV_U and DERIV_N are the derivatives computed explicitly   and numerically, respectively.  Appropriate values   for most users will be:        PARINFO[i].MPDERIV_RELTOL = 1d-3 ;; Suggested relative tolerance       PARINFO[i].MPDERIV_ABSTOL = 1d-7 ;; Suggested absolute tolerance    although these thresholds may have to be adjusted for a particular   problem.  When the threshold is exceeded, users can expect to see a   tabular report like this one:      FJAC DEBUG BEGIN     #        IPNT       FUNC    DERIV_U    DERIV_N   DIFF_ABS   DIFF_REL     FJAC PARM 2                80    -0.7308    0.04233    0.04233 -5.543E-07 -1.309E-05                99      1.370    0.01417    0.01417 -5.518E-07 -3.895E-05               118    0.07187   -0.01400   -0.01400 -5.566E-07  3.977E-05               137      1.844   -0.04216   -0.04216 -5.589E-07  1.326E-05     FJAC DEBUG END    The report will be bracketed by FJAC DEBUG BEGIN/END statements.   Each parameter will be delimited by the statement FJAC PARM n,   where n is the parameter number.  The columns are,        IPNT - data point number  (0 ... M-1)       FUNC - function value at that point       DERIV_U - explicit derivative value at that point       DERIV_N - numerical derivative estimate at that point       DIFF_ABS - absolute difference = (DERIV_U - DERIV_N)       DIFF_REL - relative difference = (DIFF_ABS)/(DERIV_U)    When prints appear in this report, it is most important to check   that the derivatives computed in two different ways have the same   numerical sign and the same order of magnitude, since these are the   most common programming mistakes.   CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD    The behavior of MPFIT can be modified with respect to each   parameter to be fitted.  A parameter value can be fixed; simple   boundary constraints can be imposed; limitations on the parameter   changes can be imposed; properties of the automatic derivative can   be modified; and parameters can be tied to one another.    These properties are governed by the PARINFO structure, which is   passed as a keyword parameter to MPFIT.    PARINFO should be an array of structures, one for each parameter.   Each parameter is associated with one element of the array, in   numerical order.  The structure can have the following entries   (none are required):       .VALUE - the starting parameter value (but see the START_PARAMS               parameter for more information).       .FIXED - a boolean value, whether the parameter is to be held               fixed or not.  Fixed parameters are not varied by               MPFIT, but are passed on to MYFUNCT for evaluation.       .LIMITED - a two-element boolean array.  If the first/second                 element is set, then the parameter is bounded on the                 lower/upper side.  A parameter can be bounded on both                 sides.  Both LIMITED and LIMITS must be given                 together.       .LIMITS - a two-element float or double array.  Gives the                parameter limits on the lower and upper sides,                respectively.  Zero, one or two of these values can be                set, depending on the values of LIMITED.  Both LIMITED                and LIMITS must be given together.       .PARNAME - a string, giving the name of the parameter.  The                 fitting code of MPFIT does not use this tag in any                 way.  However, the default ITERPROC will print the                 parameter name if available.       .STEP - the step size to be used in calculating the numerical              derivatives.  If set to zero, then the step size is              computed automatically.  Ignored when AUTODERIVATIVE=0.              This value is superceded by the RELSTEP value.       .RELSTEP - the *relative* step size to be used in calculating                 the numerical derivatives.  This number is the                 fractional size of the step, compared to the                 parameter value.  This value supercedes the STEP                 setting.  If the parameter is zero, then a default                 step size is chosen.       .MPSIDE - selector for type of derivative calculation. This                field can take one of five possible values:                    0 - one-sided derivative computed automatically                   1 - one-sided derivative (f(x+h) - f(x)  )/h                  -1 - one-sided derivative (f(x)   - f(x-h))/h                   2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)                   3 - explicit derivative used for this parameter                In the first four cases, the derivative is approximated               numerically by finite difference, with step size               H=STEP, where the STEP parameter is defined above.  The               last case, MPSIDE=3, indicates to allow the user               function to compute the derivative explicitly (see               section on  EXPLICIT DERIVATIVES ).  AUTODERIVATIVE=0               overrides this setting for all parameters, and is               equivalent to MPSIDE=3 for all parameters.  For               MPSIDE=0, the  automatic  one-sided derivative method               will chose a direction for the finite difference which               does not violate any constraints.  The other methods               (MPSIDE=-1 or MPSIDE=1) do not perform this check.  The               two-sided method is in principle more precise, but               requires twice as many function evaluations.  Default:               0.       .MPDERIV_DEBUG - set this value to 1 to enable debugging of               user-supplied explicit derivatives (see  TESTING and               DEBUGGING  section above).  In addition, the               user must enable calculation of explicit derivatives by               either setting AUTODERIVATIVE=0, or MPSIDE=3 for the               desired parameters.  When this option is enabled, a               report may be printed to the console, depending on the               MPDERIV_ABSTOL and MPDERIV_RELTOL settings.               Default: 0 (no debugging)       .MPDERIV_ABSTOL, .MPDERIV_RELTOL - tolerance settings for               print-out of debugging information, for each parameter               where debugging is enabled.  See  TESTING and               DEBUGGING  section above for the meanings of these two               fields.       .MPMAXSTEP - the maximum change to be made in the parameter                   value.  During the fitting process, the parameter                   will never be changed by more than this value in                   one iteration.                    A value of 0 indicates no maximum.  Default: 0.       .TIED - a string expression which  ties  the parameter to other              free or fixed parameters as an equality constraint.  Any              expression involving constants and the parameter array P              are permitted.              Example: if parameter 2 is always to be twice parameter              1 then use the following: parinfo[2].tied = '2 * P[1]'.              Since they are totally constrained, tied parameters are              considered to be fixed; no errors are computed for them,              and any LIMITS are not obeyed.              [ NOTE: the PARNAME can't be used in a TIED expression. ]       .MPPRINT - if set to 1, then the default ITERPROC will print the                 parameter value.  If set to 0, the parameter value                 will not be printed.  This tag can be used to                 selectively print only a few parameter values out of                 many.  Default: 1 (all parameters printed)       .MPFORMAT - IDL format string to print the parameter within                  ITERPROC.  Default: '(G20.6)'  (An empty string will                  also use the default.)    Future modifications to the PARINFO structure, if any, will involve   adding structure tags beginning with the two letters  MP .   Therefore programmers are urged to avoid using tags starting with    MP , but otherwise they are free to include their own fields   within the PARINFO structure, which will be ignored by MPFIT.    PARINFO Example:   parinfo = replicate({value:0.D, fixed:0, limited:[0,0], $                        limits:[0.D,0]}, 5)   parinfo[0].fixed = 1   parinfo[4].limited[0] = 1   parinfo[4].limits[0]  = 50.D   parinfo[*].value = [5.7D, 2.2, 500., 1.5, 2000.]    A total of 5 parameters, with starting values of 5.7,   2.2, 500, 1.5, and 2000 are given.  The first parameter   is fixed at a value of 5.7, and the last parameter is   constrained to be above 50.   COMPATIBILITY    This function is designed to work with IDL 5.0 or greater.    Because TIED parameters and the  (EXTERNAL)  user-model feature use   the EXECUTE() function, they cannot be used with the free version   of the IDL Virtual Machine.   DETERMINING THE VERSION OF MPFIT    MPFIT is a changing library.  Users of MPFIT may also depend on a   specific version of the library being present.  As of version 1.70   of MPFIT, a VERSION keyword has been added which allows the user to   query which version is present.  The keyword works like this:      RESULT = MPFIT(/query, VERSION=version)    This call uses the /QUERY keyword to query the version number   without performing any computations.  Users of MPFIT can call this   method to determine which version is in the IDL path before   actually using MPFIT to do any numerical work.  Upon return, the   VERSION keyword contains the version number of MPFIT, expressed as   a string of the form 'X.Y' where X and Y are integers.    Users can perform their own version checking, or use the built-in   error checking of MPFIT.  The MIN_VERSION keyword enforces the   requested minimum version number.  For example,      RESULT = MPFIT(/query, VERSION=version, MIN_VERSION='1.70')    will check whether the accessed version is 1.70 or greater, without   performing any numerical processing.    Because the VERSION and MIN_VERSION keywords were added in MPFIT   version 1.70 and later.  If the caller attempts to use the VERSION   or MIN_VERSION keywords, and an *older* version of the code is   present in the caller's path, then IDL will throw an 'unknown   keyword' error.  Therefore, in order to be robust, the caller, must   use exception handling.  Here is an example demanding at least   version 1.70.      MPFIT_OK = 0  & VERSION = '&lt;unknown&gt;'     CATCH, CATCHERR     IF CATCHERR EQ 0 THEN MPFIT_OK = MPFIT(/query, VERSION=version, $                                          MIN_VERSION='1.70')     CATCH, /CANCEL      IF NOT MPFIT_OK THEN $       MESSAGE, 'ERROR: you must have MPFIT version 1.70 or higher in '+$              'your path (found version '+version+')'    Of course, the caller can also do its own version number   requirements checking.   HARD-TO-COMPUTE FUNCTIONS:  EXTERNAL  EVALUATION    The normal mode of operation for MPFIT is for the user to pass a   function name, and MPFIT will call the user function multiple times   as it iterates toward a solution.    Some user functions are particularly hard to compute using the   standard model of MPFIT.  Usually these are functions that depend   on a large amount of external data, and so it is not feasible, or   at least highly impractical, to have MPFIT call it.  In those cases   it may be possible to use the  (EXTERNAL)  evaluation option.    In this case the user is responsible for making all function *and   derivative* evaluations.  The function and Jacobian data are passed   in through the EXTERNAL_FVEC and EXTERNAL_FJAC keywords,   respectively.  The user indicates the selection of this option by   specifying a function name (MYFUNCT) of  (EXTERNAL) .  No   user-function calls are made when EXTERNAL evaluation is being   used.    ** SPECIAL NOTE ** For the  (EXTERNAL)  case, the quirk noted above      does not apply.  The gradient matrix, EXTERNAL_FJAC, should be      comparable to  -FGRAD(x,p)/err , which is the *opposite* sign of      the DP matrix described above.  In other words, EXTERNAL_FJAC      has the same sign as the derivative of EXTERNAL_FVEC, and the      opposite sign of FGRAD.    At the end of each iteration, control returns to the user, who must   reevaluate the function at its new parameter values.  Users should   check the return value of the STATUS keyword, where a value of 9   indicates the user should supply more data for the next iteration,   and re-call MPFIT.  The user may refrain from calling MPFIT   further; as usual, STATUS will indicate when the solution has   converged and no more iterations are required.    Because MPFIT must maintain its own data structures between calls,   the user must also pass a named variable to the EXTERNAL_STATE   keyword.  This variable must be maintained by the user, but not   changed, throughout the fitting process.  When no more iterations   are desired, the named variable may be discarded.   INPUTS:    MYFUNCT - a string variable containing the name of the function to              be minimized.  The function should return the weighted              deviations between the model and the data, as described              above.               For EXTERNAL evaluation of functions, this parameter              should be set to a value of  (EXTERNAL) .     START_PARAMS - An one-dimensional array of starting values for each of the                   parameters of the model.  The number of parameters                   should be fewer than the number of measurements.                   Also, the parameters should have the same data type                   as the measurements (double is preferred).                    This parameter is optional if the PARINFO keyword                   is used (but see PARINFO).  The PARINFO keyword                   provides a mechanism to fix or constrain individual                   parameters.  If both START_PARAMS and PARINFO are                   passed, then the starting *value* is taken from                   START_PARAMS, but the *constraints* are taken from                   PARINFO.   RETURNS:     Returns the array of best-fit parameters.    Exceptions:       * if /QUERY is set (see QUERY).   KEYWORD PARAMETERS:     AUTODERIVATIVE - If this is set, derivatives of the function will                     be computed automatically via a finite                     differencing procedure.  If not set, then MYFUNCT                     must provide the explicit derivatives.                     Default: set (=1)                     NOTE: to supply your own explicit derivatives,                       explicitly pass AUTODERIVATIVE=0     BESTNORM - the value of the summed squared weighted residuals for               the returned parameter values, i.e. TOTAL(DEVIATES^2).     COVAR - the covariance matrix for the set of parameters returned            by MPFIT.  The matrix is NxN where N is the number of            parameters.  The square root of the diagonal elements            gives the formal 1-sigma statistical errors on the            parameters IF errors were treated  properly  in MYFUNC.            Parameter errors are also returned in PERROR.             To compute the correlation matrix, PCOR, use this example:                   PCOR = COV * 0                   FOR i = 0, n-1 DO FOR j = 0, n-1 DO $                     PCOR[i,j] = COV[i,j]/sqrt(COV[i,i]*COV[j,j])            or equivalently, in vector notation,                   PCOR = COV / (PERROR # PERROR)             If NOCOVAR is set or MPFIT terminated abnormally, then            COVAR is set to a scalar with value !VALUES.D_NAN.     DOF - number of degrees of freedom, computed as              DOF = N_ELEMENTS(DEVIATES) - NFREE          Note that this doesn't account for pegged parameters (see          NPEGGED).     ERRMSG - a string error or warning message is returned.     EXTERNAL_FVEC - upon input, the function values, evaluated at                    START_PARAMS.  This should be an M-vector, where M                    is the number of data points.     EXTERNAL_FJAC - upon input, the Jacobian array of partial                    derivative values.  This should be a M x N array,                    where M is the number of data points and N is the                    number of parameters.  NOTE: that all FIXED or                    TIED parameters must *not* be included in this                    array.     EXTERNAL_STATE - a named variable to store MPFIT-related state                     information between iterations (used in input and                     output to MPFIT).  The user must not manipulate                     or discard this data until the final iteration is                     performed.     FASTNORM - set this keyword to select a faster algorithm to               compute sum-of-square values internally.  For systems               with large numbers of data points, the standard               algorithm can become prohibitively slow because it               cannot be vectorized well.  By setting this keyword,               MPFIT will run faster, but it will be more prone to               floating point overflows and underflows.  Thus, setting               this keyword may sacrifice some stability in the               fitting process.     FTOL - a nonnegative input variable. Termination occurs when both           the actual and predicted relative reductions in the sum of           squares are at most FTOL (and STATUS is accordingly set to           1 or 3).  Therefore, FTOL measures the relative error           desired in the sum of squares.  Default: 1D-10     FUNCTARGS - A structure which contains the parameters to be passed                to the user-supplied function specified by MYFUNCT via                the _EXTRA mechanism.  This is the way you can pass                additional data to your user-supplied function without                using common blocks.                 Consider the following example:                 if FUNCTARGS = { XVAL:[1.D,2,3], YVAL:[1.D,4,9],                                  ERRVAL:[1.D,1,1] }                 then the user supplied function should be declared                 like this:                 FUNCTION MYFUNCT, P, XVAL=x, YVAL=y, ERRVAL=err                 By default, no extra parameters are passed to the                user-supplied function, but your function should                accept *at least* one keyword parameter.  [ This is to                accomodate a limitation in IDL's _EXTRA                parameter-passing mechanism. ]     GTOL - a nonnegative input variable. Termination occurs when the           cosine of the angle between fvec and any column of the           jacobian is at most GTOL in absolute value (and STATUS is           accordingly set to 4). Therefore, GTOL measures the           orthogonality desired between the function vector and the           columns of the jacobian.  Default: 1D-10     ITERARGS - The keyword arguments to be passed to ITERPROC via the               _EXTRA mechanism.  This should be a structure, and is               similar in operation to FUNCTARGS.               Default: no arguments are passed.     ITERPRINT - The name of an IDL procedure, equivalent to PRINT,                that ITERPROC will use to render output.  ITERPRINT                should be able to accept at least four positional                arguments.  In addition, it should be able to accept                the standard FORMAT keyword for output formatting; and                the UNIT keyword, to redirect output to a logical file                unit (default should be UNIT=1, standard output).                These keywords are passed using the ITERARGS keyword                above.  The ITERPRINT procedure must accept the _EXTRA                keyword.                NOTE: that much formatting can be handled with the                      MPPRINT and MPFORMAT tags.                Default: 'MPFIT_DEFPRINT' (default internal formatter)     ITERPROC - The name of a procedure to be called upon each NPRINT               iteration of the MPFIT routine.  ITERPROC is always               called in the final iteration.  It should be declared               in the following way:                PRO ITERPROC, MYFUNCT, p, iter, fnorm, FUNCTARGS=fcnargs, $                 PARINFO=parinfo, QUIET=quiet, DOF=dof, PFORMAT=pformat, $                 UNIT=unit, ...                 ; perform custom iteration update               END                ITERPROC must either accept all three keyword               parameters (FUNCTARGS, PARINFO and QUIET), or at least               accept them via the _EXTRA keyword.                MYFUNCT is the user-supplied function to be minimized,               P is the current set of model parameters, ITER is the               iteration number, and FUNCTARGS are the arguments to be               passed to MYFUNCT.  FNORM should be the chi-squared               value.  QUIET is set when no textual output should be               printed.  DOF is the number of degrees of freedom,               normally the number of points less the number of free               parameters.  See below for documentation of PARINFO.               PFORMAT is the default parameter value format.  UNIT is               passed on to the ITERPRINT procedure, and should               indicate the file unit where log output will be sent               (default: standard output).                In implementation, ITERPROC can perform updates to the               terminal or graphical user interface, to provide               feedback while the fit proceeds.  If the fit is to be               stopped for any reason, then ITERPROC should set the               common block variable ERROR_CODE to negative value               between -15 and -1 (see MPFIT_ERROR common block               below).  In principle, ITERPROC should probably not               modify the parameter values, because it may interfere               with the algorithm's stability.  In practice it is               allowed.                Default: an internal routine is used to print the                        parameter values.     ITERSTOP - Set this keyword if you wish to be able to stop the               fitting by hitting the predefined ITERKEYSTOP key on               the keyboard.  This only works if you use the default               ITERPROC.     ITERKEYSTOP - A keyboard key which will halt the fit (and if                  ITERSTOP is set and the default ITERPROC is used).                  ITERSTOPKEY may either be a one-character string                  with the desired key, or a scalar integer giving the                  ASCII code of the desired key.                  Default: 7b (control-g)                   NOTE: the default value of ASCI 7 (control-G) cannot                  be read in some windowing environments, so you must                  change to a printable character like 'q'.     MAXITER - The maximum number of iterations to perform.  If the              number is exceeded, then the STATUS value is set to 5              and MPFIT returns.              Default: 200 iterations     MIN_VERSION - The minimum requested version number.  This must be                  a scalar string of the form returned by the VERSION                  keyword.  If the current version of MPFIT does not                  satisfy the minimum requested version number, then,                     MPFIT(/query, min_version='...') returns 0                     MPFIT(...) returns NAN                  Default: no version number check                  NOTE: MIN_VERSION was added in MPFIT version 1.70     NFEV - the number of MYFUNCT function evaluations performed.     NFREE - the number of free parameters in the fit.  This includes            parameters which are not FIXED and not TIED, but it does            include parameters which are pegged at LIMITS.     NITER - the number of iterations completed.     NOCATCH - if set, then MPFIT will not perform any error trapping.              By default (not set), MPFIT will trap errors and report              them to the caller.  This keyword will typically be used              for debugging.     NOCOVAR - set this keyword to prevent the calculation of the              covariance matrix before returning (see COVAR)     NPEGGED - the number of free parameters which are pegged at a              LIMIT.     NPRINT - The frequency with which ITERPROC is called.  A value of             1 indicates that ITERPROC is called with every iteration,             while 2 indicates every other iteration, etc.  Be aware             that several Levenberg-Marquardt attempts can be made in             a single iteration.  Also, the ITERPROC is *always*             called for the final iteration, regardless of the             iteration number.             Default value: 1     PARINFO - A one-dimensional array of structures.              Provides a mechanism for more sophisticated constraints              to be placed on parameter values.  When PARINFO is not              passed, then it is assumed that all parameters are free              and unconstrained.  Values in PARINFO are never              modified during a call to MPFIT.               See description above for the structure of PARINFO.               Default value:  all parameters are free and unconstrained.     PERROR - The formal 1-sigma errors in each parameter, computed             from the covariance matrix.  If a parameter is held             fixed, or if it touches a boundary, then the error is             reported as zero.              If the fit is unweighted (i.e. no errors were given, or             the weights were uniformly set to unity), then PERROR             will probably not represent the true parameter             uncertainties.              *If* you can assume that the true reduced chi-squared             value is unity -- meaning that the fit is implicitly             assumed to be of good quality -- then the estimated             parameter uncertainties can be computed by scaling PERROR             by the measured chi-squared value.                DOF     = N_ELEMENTS(X) - N_ELEMENTS(PARMS) ; deg of freedom               PCERROR = PERROR * SQRT(BESTNORM / DOF)   ; scaled uncertainties     QUERY - if set, then MPFIT() will return immediately with one of            the following values:                  1 - if MIN_VERSION is not set                  1 - if MIN_VERSION is set and MPFIT satisfies the minimum                  0 - if MIN_VERSION is set and MPFIT does not satisfy it            The VERSION output keyword is always set upon return.            Default: not set.     QUIET - set this keyword when no textual output should be printed            by MPFIT     RESDAMP - a scalar number, indicating the cut-off value of              residuals where  damping  will occur.  Residuals with              magnitudes greater than this number will be replaced by              their logarithm.  This partially mitigates the so-called              large residual problem inherent in least-squares solvers              (as for the test problem CURVI, http://www.maxthis.com/-              curviex.htm).  A value of 0 indicates no damping.              Default: 0               Note: RESDAMP doesn't work with AUTODERIV=0     STATUS - an integer status code is returned.  All values greater             than zero can represent success (however STATUS EQ 5 may             indicate failure to converge).  It can have one of the             following values:          -18  a fatal execution error has occurred.  More information              may be available in the ERRMSG string.          -16  a parameter or function value has become infinite or an              undefined number.  This is usually a consequence of              numerical overflow in the user's model function, which              must be avoided.          -15 to -1              these are error codes that either MYFUNCT or ITERPROC              may return to terminate the fitting process (see              description of MPFIT_ERROR common below).  If either              MYFUNCT or ITERPROC set ERROR_CODE to a negative number,              then that number is returned in STATUS.  Values from -15              to -1 are reserved for the user functions and will not              clash with MPFIT.  	   0  improper input parameters.  	   1  both actual and predicted relative reductions 	      in the sum of squares are at most FTOL.  	   2  relative error between two consecutive iterates 	      is at most XTOL  	   3  conditions for STATUS = 1 and STATUS = 2 both hold.  	   4  the cosine of the angle between fvec and any 	      column of the jacobian is at most GTOL in 	      absolute value.  	   5  the maximum number of iterations has been reached  	   6  FTOL is too small. no further reduction in 	      the sum of squares is possible.  	   7  XTOL is too small. no further improvement in 	      the approximate solution x is possible.  	   8  GTOL is too small. fvec is orthogonal to the 	      columns of the jacobian to machine precision.            9  A successful single iteration has been completed, and              the user must supply another  EXTERNAL  evaluation of              the function and its derivatives.  This status indicator              is neither an error nor a convergence indicator.     VERSION - upon return, VERSION will be set to the MPFIT internal              version number.  The version number will be a string of              the form  X.Y  where X is a major revision number and Y              is a minor revision number.              NOTE: the VERSION keyword was not present before                MPFIT version number 1.70, therefore, callers must                use exception handling when using this keyword.     XTOL - a nonnegative input variable. Termination occurs when the           relative error between two consecutive iterates is at most           XTOL (and STATUS is accordingly set to 2 or 3).  Therefore,           XTOL measures the relative error desired in the approximate           solution.  Default: 1D-10   EXAMPLE:     p0 = [5.7D, 2.2, 500., 1.5, 2000.]    fa = {X:x, Y:y, ERR:err}    p = mpfit('MYFUNCT', p0, functargs=fa)     Minimizes sum of squares of MYFUNCT.  MYFUNCT is called with the X,    Y, and ERR keyword parameters that are given by FUNCTARGS.  The    resulting parameter values are returned in p.   COMMON BLOCKS:     COMMON MPFIT_ERROR, ERROR_CODE       User routines may stop the fitting process at any time by      setting an error condition.  This condition may be set in either      the user's model computation routine (MYFUNCT), or in the      iteration procedure (ITERPROC).       To stop the fitting, the above common block must be declared,      and ERROR_CODE must be set to a negative number.  After the user      procedure or function returns, MPFIT checks the value of this      common block variable and exits immediately if the error      condition has been set.  This value is also returned in the      STATUS keyword: values of -1 through -15 are reserved error      codes for the user routines.  By default the value of ERROR_CODE      is zero, indicating a successful function/procedure call.     COMMON MPFIT_PROFILE    COMMON MPFIT_MACHAR    COMMON MPFIT_CONFIG       These are undocumented common blocks are used internally by      MPFIT and may change in future implementations.   THEORY OF OPERATION:     There are many specific strategies for function minimization.  One    very popular technique is to use function gradient information to    realize the local structure of the function.  Near a local minimum    the function value can be taylor expanded about x0 as follows:        f(x) = f(x0) + f'(x0) . (x-x0) + (1/2) (x-x0) . f''(x0) . (x-x0)              -----   ---------------   -------------------------------  (1)      Order    0th          1st                      2nd     Here f'(x) is the gradient vector of f at x, and f''(x) is the    Hessian matrix of second derivatives of f at x.  The vector x is    the set of function parameters, not the measured data vector.  One    can find the minimum of f, f(xm) using Newton's method, and    arrives at the following linear equation:        f''(x0) . (xm-x0) = - f'(x0)                            (2)     If an inverse can be found for f''(x0) then one can solve for    (xm-x0), the step vector from the current position x0 to the new    projected minimum.  Here the problem has been linearized (ie, the    gradient information is known to first order).  f''(x0) is    symmetric n x n matrix, and should be positive definite.     The Levenberg - Marquardt technique is a variation on this theme.    It adds an additional diagonal term to the equation which may aid the    convergence properties:        (f''(x0) + nu I) . (xm-x0) = -f'(x0)                  (2a)     where I is the identity matrix.  When nu is large, the overall    matrix is diagonally dominant, and the iterations follow steepest    descent.  When nu is small, the iterations are quadratically    convergent.     In principle, if f''(x0) and f'(x0) are known then xm-x0 can be    determined.  However the Hessian matrix is often difficult or    impossible to compute.  The gradient f'(x0) may be easier to    compute, if even by finite difference techniques.  So-called    quasi-Newton techniques attempt to successively estimate f''(x0)    by building up gradient information as the iterations proceed.     In the least squares problem there are further simplifications    which assist in solving eqn (2).  The function to be minimized is    a sum of squares:         f = Sum(hi^2)                                         (3)     where hi is the ith residual out of m residuals as described    above.  This can be substituted back into eqn (2) after computing    the derivatives:         f'  = 2 Sum(hi  hi')        f'' = 2 Sum(hi' hj') + 2 Sum(hi hi'')                (4)     If one assumes that the parameters are already close enough to a    minimum, then one typically finds that the second term in f'' is    negligible [or, in any case, is too difficult to compute].  Thus,    equation (2) can be solved, at least approximately, using only    gradient information.     In matrix notation, the combination of eqns (2) and (4) becomes:          hT' . h' . dx = - hT' . h                          (5)     Where h is the residual vector (length m), hT is its transpose, h'    is the Jacobian matrix (dimensions n x m), and dx is (xm-x0).  The    user function supplies the residual vector h, and in some cases h'    when it is not found by finite differences (see MPFIT_FDJAC2,    which finds h and hT').  Even if dx is not the best absolute step    to take, it does provide a good estimate of the best *direction*,    so often a line minimization will occur along the dx vector    direction.     The method of solution employed by MINPACK is to form the Q . R    factorization of h', where Q is an orthogonal matrix such that QT .    Q = I, and R is upper right triangular.  Using h' = Q . R and the    ortogonality of Q, eqn (5) becomes          (RT . QT) . (Q . R) . dx = - (RT . QT) . h                      RT . R . dx = - RT . QT . h         (6)                           R . dx = - QT . h     where the last statement follows because R is upper triangular.    Here, R, QT and h are known so this is a matter of solving for dx.    The routine MPFIT_QRFAC provides the QR factorization of h, with    pivoting, and MPFIT_QRSOL;V provides the solution for dx.   REFERENCES:     Markwardt, C. B. 2008,  Non-Linear Least Squares Fitting in IDL      with MPFIT,  in proc. Astronomical Data Analysis Software and      Systems XVIII, Quebec, Canada, ASP Conference Series, Vol. XXX, eds.      D. Bohlender, P. Dowler & D. Durand (Astronomical Society of the      Pacific: San Francisco), p. 251-254 (ISBN: 978-1-58381-702-5)        http://arxiv.org/abs/0902.2850        Link to NASA ADS: http://adsabs.harvard.edu/abs/2009ASPC..411..251M        Link to ASP: http://aspbooks.org/a/volumes/table_of_contents/411     Refer to the MPFIT website as:        http://purl.com/net/mpfit     MINPACK-1 software, by Jorge More' et al, available from netlib.      http://www.netlib.org/      Optimization Software Guide,  Jorge More' and Stephen Wright,      SIAM, *Frontiers in Applied Mathematics*, Number 14.      (ISBN: 978-0-898713-22-0)     More', J. 1978,  The Levenberg-Marquardt Algorithm: Implementation      and Theory,  in Numerical Analysis, vol. 630, ed. G. A. Watson      (Springer-Verlag: Berlin), p. 105 (DOI: 10.1007/BFb0067690 )   MODIFICATION HISTORY:    Translated from MINPACK-1 in FORTRAN, Apr-Jul 1998, CM    Fixed bug in parameter limits (x vs xnew), 04 Aug 1998, CM    Added PERROR keyword, 04 Aug 1998, CM    Added COVAR keyword, 20 Aug 1998, CM    Added NITER output keyword, 05 Oct 1998       D.L Windt, Bell Labs, windt@bell-labs.com;    Made each PARINFO component optional, 05 Oct 1998 CM    Analytical derivatives allowed via AUTODERIVATIVE keyword, 09 Nov 1998    Parameter values can be tied to others, 09 Nov 1998    Fixed small bugs (Wayne Landsman), 24 Nov 1998    Added better exception error reporting, 24 Nov 1998 CM    Cosmetic documentation changes, 02 Jan 1999 CM    Changed definition of ITERPROC to be consistent with TNMIN, 19 Jan 1999 CM    Fixed bug when AUTDERIVATIVE=0.  Incorrect sign, 02 Feb 1999 CM    Added keyboard stop to MPFIT_DEFITER, 28 Feb 1999 CM    Cosmetic documentation changes, 14 May 1999 CM    IDL optimizations for speed & FASTNORM keyword, 15 May 1999 CM    Tried a faster version of mpfit_enorm, 30 May 1999 CM    Changed web address to cow.physics.wisc.edu, 14 Jun 1999 CM    Found malformation of FDJAC in MPFIT for 1 parm, 03 Aug 1999 CM    Factored out user-function call into MPFIT_CALL.  It is possible,      but currently disabled, to call procedures.  The calling format      is similar to CURVEFIT, 25 Sep 1999, CM    Slightly changed mpfit_tie to be less intrusive, 25 Sep 1999, CM    Fixed some bugs associated with tied parameters in mpfit_fdjac, 25      Sep 1999, CM    Reordered documentation; now alphabetical, 02 Oct 1999, CM    Added QUERY keyword for more robust error detection in drivers, 29      Oct 1999, CM    Documented PERROR for unweighted fits, 03 Nov 1999, CM    Split out MPFIT_RESETPROF to aid in profiling, 03 Nov 1999, CM    Some profiling and speed optimization, 03 Nov 1999, CM      Worst offenders, in order: fdjac2, qrfac, qrsolv, enorm.      fdjac2 depends on user function, qrfac and enorm seem to be      fully optimized.  qrsolv probably could be tweaked a little, but      is still &lt;10% of total compute time.    Made sure that !err was set to 0 in MPFIT_DEFITER, 10 Jan 2000, CM    Fixed small inconsistency in setting of QANYLIM, 28 Jan 2000, CM    Added PARINFO field RELSTEP, 28 Jan 2000, CM    Converted to MPFIT_ERROR common block for indicating error      conditions, 28 Jan 2000, CM    Corrected scope of MPFIT_ERROR common block, CM, 07 Mar 2000    Minor speed improvement in MPFIT_ENORM, CM 26 Mar 2000    Corrected case where ITERPROC changed parameter values and      parameter values were TIED, CM 26 Mar 2000    Changed MPFIT_CALL to modify NFEV automatically, and to support      user procedures more, CM 26 Mar 2000    Copying permission terms have been liberalized, 26 Mar 2000, CM    Catch zero value of zero a(j,lj) in MPFIT_QRFAC, 20 Jul 2000, CM       (thanks to David Schlegel &lt;schlegel@astro.princeton.edu&gt;)    MPFIT_SETMACHAR is called only once at init; only one common block      is created (MPFIT_MACHAR); it is now a structure; removed almost      all CHECK_MATH calls for compatibility with IDL5 and !EXCEPT;      profiling data is now in a structure too; noted some      mathematical discrepancies in Linux IDL5.0, 17 Nov 2000, CM    Some significant changes.  New PARINFO fields: MPSIDE, MPMINSTEP,      MPMAXSTEP.  Improved documentation.  Now PTIED constraints are      maintained in the MPCONFIG common block.  A new procedure to      parse PARINFO fields.  FDJAC2 now computes a larger variety of      one-sided and two-sided finite difference derivatives.  NFEV is      stored in the MPCONFIG common now.  17 Dec 2000, CM    Added check that PARINFO and XALL have same size, 29 Dec 2000 CM    Don't call function in TERMINATE when there is an error, 05 Jan      2000    Check for float vs. double discrepancies; corrected implementation      of MIN/MAXSTEP, which I still am not sure of, but now at least      the correct behavior occurs *without* it, CM 08 Jan 2001    Added SCALE_FCN keyword, to allow for scaling, as for the CASH      statistic; added documentation about the theory of operation,      and under the QR factorization; slowly I'm beginning to      understand the bowels of this algorithm, CM 10 Jan 2001    Remove MPMINSTEP field of PARINFO, for now at least, CM 11 Jan      2001    Added RESDAMP keyword, CM, 14 Jan 2001    Tried to improve the DAMP handling a little, CM, 13 Mar 2001    Corrected .PARNAME behavior in _DEFITER, CM, 19 Mar 2001    Added checks for parameter and function overflow; a new STATUS      value to reflect this; STATUS values of -15 to -1 are reserved      for user function errors, CM, 03 Apr 2001    DAMP keyword is now a TANH, CM, 03 Apr 2001    Added more error checking of float vs. double, CM, 07 Apr 2001    Fixed bug in handling of parameter lower limits; moved overflow      checking to end of loop, CM, 20 Apr 2001    Failure using GOTO, TERMINATE more graceful if FNORM1 not defined,      CM, 13 Aug 2001    Add MPPRINT tag to PARINFO, CM, 19 Nov 2001    Add DOF keyword to DEFITER procedure, and print degrees of      freedom, CM, 28 Nov 2001    Add check to be sure MYFUNCT is a scalar string, CM, 14 Jan 2002    Addition of EXTERNAL_FJAC, EXTERNAL_FVEC keywords; ability to save      fitter's state from one call to the next; allow '(EXTERNAL)'      function name, which implies that user will supply function and      Jacobian at each iteration, CM, 10 Mar 2002    Documented EXTERNAL evaluation code, CM, 10 Mar 2002    Corrected signficant bug in the way that the STEP parameter, and      FIXED parameters interacted (Thanks Andrew Steffl), CM, 02 Apr      2002    Allow COVAR and PERROR keywords to be computed, even in case of      '(EXTERNAL)' function, 26 May 2002    Add NFREE and NPEGGED keywords; compute NPEGGED; compute DOF using      NFREE instead of n_elements(X), thanks to Kristian Kjaer, CM 11      Sep 2002    Hopefully PERROR is all positive now, CM 13 Sep 2002    Documented RELSTEP field of PARINFO (!!), CM, 25 Oct 2002    Error checking to detect missing start pars, CM 12 Apr 2003    Add DOF keyword to return degrees of freedom, CM, 30 June 2003    Always call ITERPROC in the final iteration; add ITERKEYSTOP      keyword, CM, 30 June 2003    Correct bug in MPFIT_LMPAR of singularity handling, which might      likely be fatal for one-parameter fits, CM, 21 Nov 2003      (with thanks to Peter Tuthill for the proper test case)    Minor documentation adjustment, 03 Feb 2004, CM    Correct small error in QR factorization when pivoting; document      the return values of QRFAC when pivoting, 21 May 2004, CM    Add MPFORMAT field to PARINFO, and correct behavior of interaction      between MPPRINT and PARNAME in MPFIT_DEFITERPROC (thanks to Tim      Robishaw), 23 May 2004, CM    Add the ITERPRINT keyword to allow redirecting output, 26 Sep      2004, CM    Correct MAXSTEP behavior in case of a negative parameter, 26 Sep      2004, CM    Fix bug in the parsing of MINSTEP/MAXSTEP, 10 Apr 2005, CM    Fix bug in the handling of upper/lower limits when the limit was      negative (the fitting code would never  stick  to the lower      limit), 29 Jun 2005, CM    Small documentation update for the TIED field, 05 Sep 2005, CM    Convert to IDL 5 array syntax (!), 16 Jul 2006, CM    If MAXITER equals zero, then do the basic parameter checking and      uncertainty analysis, but do not adjust the parameters, 15 Aug      2006, CM    Added documentation, 18 Sep 2006, CM    A few more IDL 5 array syntax changes, 25 Sep 2006, CM    Move STRICTARR compile option inside each function/procedure, 9 Oct 2006    Bug fix for case of MPMAXSTEP and fixed parameters, thanks      to Huib Intema (who found it from the Python translation!), 05 Feb 2007    Similar fix for MPFIT_FDJAC2 and the MPSIDE sidedness of      derivatives, also thanks to Huib Intema, 07 Feb 2007    Clarify documentation on user-function, derivatives, and PARINFO,      27 May 2007    Change the wording of  Analytic Derivatives  to  Explicit      Derivatives  in the documentation, CM, 03 Sep 2007    Further documentation tweaks, CM, 13 Dec 2007    Add COMPATIBILITY section and add credits to copyright, CM, 13 Dec       2007    Document and enforce that START_PARMS and PARINFO are 1-d arrays,       CM, 29 Mar 2008    Previous change for 1-D arrays wasn't correct for       PARINFO.LIMITED/.LIMITS; now fixed, CM, 03 May 2008    Documentation adjustments, CM, 20 Aug 2008    Change some minor FOR-loop variables to type-long, CM, 03 Sep 2008    Change error handling slightly, document NOCATCH keyword,       document error handling in general, CM, 01 Oct 2008    Special case: when either LIMITS is zero, and a parameter pushes       against that limit, the coded that 'pegged' it there would not       work since it was a relative condition; now zero is handled       properly, CM, 08 Nov 2008    Documentation of how TIED interacts with LIMITS, CM, 21 Dec 2008    Better documentation of references, CM, 27 Feb 2009    If MAXITER=0, then be sure to set STATUS=5, which permits the       the covariance matrix to be computed, CM, 14 Apr 2009    Avoid numerical underflow while solving for the LM parameter,       (thanks to Sergey Koposov) CM, 14 Apr 2009    Use individual functions for all possible MPFIT_CALL permutations,       (and make sure the syntax is right) CM, 01 Sep 2009    Correct behavior of MPMAXSTEP when some parameters are frozen,       thanks to Josh Destree, CM, 22 Nov 2009    Update the references section, CM, 22 Nov 2009    1.70 - Add the VERSION and MIN_VERSION keywords, CM, 22 Nov 2009    1.71 - Store pre-calculated revision in common, CM, 23 Nov 2009    1.72-1.74 - Documented alternate method to compute correlation matrix,           CM, 05 Feb 2010    1.75 - Enforce TIED constraints when preparing to terminate the           routine, CM, 2010-06-22    $Id: mpfit.pro,v 1.75 2010/06/22 06:43:35 craigm Exp $  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_dummy", "mpfit_dummy", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_dummy", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_resetprof", "mpfit_resetprof", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_resetprof", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_setmachar", "mpfit_setmachar", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_setmachar", "", "double", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_call_func_noextra", "mpfit_call_func_noextra", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_call_func_noextra", "", "_EXTRAfcnxfjac", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_call_func_extra", "mpfit_call_func_extra", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_call_func_extra", "", "_EXTRAfcnxfjac", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_call_pro_noextra", "mpfit_call_pro_noextra", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_call_pro_noextra", "", "_EXTRAfcnxfjac", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_call_pro_extra", "mpfit_call_pro_extra", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_call_pro_extra", "", "_EXTRAfcnxfjac", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_call", "mpfit_call", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_call", "", "_EXTRAfcnxfjac", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_fdjac2", "mpfit_fdjac2", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_fdjac2", "", "iflagepsfcnautoderivFUNCTARGSxallifreedstepderiv_debugderiv_reltolderiv_abstolfcnxfvecstepulimitedulimitdside", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_enorm", "mpfit_enorm", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_enorm", "", "vec", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_qrfac", "mpfit_qrfac", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_qrfac", "", "pivotaipvtrdiagacnorm", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_qrsolv", "mpfit_qrsolv", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_qrsolv", "", "ripvtdiagqtbxsdiag", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_lmpar", "mpfit_lmpar", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_lmpar", "", "parripvtdiagqtbdeltaxsdiag", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_tie", "mpfit_tie", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_tie", "", "p_ptied", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_defprint", "mpfit_defprint", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_defprint", "", "formatunit_EXTRAp1p2p3p4p5p6p7p8p9p10p11p12p13p14p15p16p17p18", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_defiter", "mpfit_defiter", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_defiter", "", "FUNCTARGSquietiterstopiterkeybyteparinfoiterprintformatpformatdof_EXTRAfcnxiterfnorm", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_parinfo", "mpfit_parinfo", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_parinfo", "", "defaultstatusn_paramparinfotnamestagvalues", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_covar", "mpfit_covar", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_covar", "", "tolrripvt", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_revision", "mpfit_revision", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_revision", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_parse_version", "mpfit_parse_version", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_parse_version", "", "version", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit_min_version", "mpfit_min_version", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit_min_version", "", "versionmin_version", "          -1", "");
  
  libdata[libdataItem++] = new Array("misc/mpfit.html#mpfit", "mpfit", 'routine in <a href="misc/mpfit.html">mpfit.pro</a>', "mpfit.pro", "", "mpfit", "", "FUNCTARGSSCALE_FCNftolxtolgtolepsfcnresdampnfevmaxitererrmsgfactornprintSTATUSiterprociterargsiterstopiterkeystopniternfreenpeggeddofdiagrescaleautoderivativeperrorcovarnocovarbestnormparinfoquietnocatchfastnormprocqueryexternal_stateexternal_initexternal_fvecexternal_fjacversionmin_versionfcnxall", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/plot_dimitri_doublets.html", "plot_dimitri_doublets.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "plot_dimitri_doublets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_doublets.html#PLOT_DIMITRI_DOUBLETS", "PLOT_DIMITRI_DOUBLETS", 'routine in <a href="hmi/plot_dimitri_doublets.html">plot_dimitri_doublets.pro</a>', "plot_dimitri_doublets.pro", "", "PLOT_DIMITRI_DOUBLETS", "", "OUTPUT_FOLDERDIMITRI_BANDRegionDB_REF_SENSORDB_REF_PROC_VERSION", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/plot_dimitri_rho_std.html", "plot_dimitri_rho_std.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "plot_dimitri_rho_std.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/plot_dimitri_rho_std.html#PLOT_DIMITRI_RHO_STD", "PLOT_DIMITRI_RHO_STD", 'routine in <a href="validation/plot_dimitri_rho_std.html">plot_dimitri_rho_std.pro</a>', "plot_dimitri_rho_std.pro", "", "PLOT_DIMITRI_RHO_STD", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr.html", "plot_dimitri_sensor_rsr.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "plot_dimitri_sensor_rsr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr.html#RSR_OBJECT_EVENT", "RSR_OBJECT_EVENT", 'routine in <a href="hmi/plot_dimitri_sensor_rsr.html">plot_dimitri_sensor_rsr.pro</a>', "plot_dimitri_sensor_rsr.pro", "", "RSR_OBJECT_EVENT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr.html#RSR_OBJECT_EXIT", "RSR_OBJECT_EXIT", 'routine in <a href="hmi/plot_dimitri_sensor_rsr.html">plot_dimitri_sensor_rsr.pro</a>', "plot_dimitri_sensor_rsr.pro", "", "RSR_OBJECT_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr.html#RSR_OBJECT_PLOT", "RSR_OBJECT_PLOT", 'routine in <a href="hmi/plot_dimitri_sensor_rsr.html">plot_dimitri_sensor_rsr.pro</a>', "plot_dimitri_sensor_rsr.pro", "", "RSR_OBJECT_PLOT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr.html#RSR_OBJECT_OPTION", "RSR_OBJECT_OPTION", 'routine in <a href="hmi/plot_dimitri_sensor_rsr.html">plot_dimitri_sensor_rsr.pro</a>', "plot_dimitri_sensor_rsr.pro", "", "RSR_OBJECT_OPTION", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr.html#RSR_OBJECT_EXPORT", "RSR_OBJECT_EXPORT", 'routine in <a href="hmi/plot_dimitri_sensor_rsr.html">plot_dimitri_sensor_rsr.pro</a>', "plot_dimitri_sensor_rsr.pro", "", "RSR_OBJECT_EXPORT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr.html#PLOT_DIMITRI_SENSOR_RSR", "PLOT_DIMITRI_SENSOR_RSR", 'routine in <a href="hmi/plot_dimitri_sensor_rsr.html">plot_dimitri_sensor_rsr.pro</a>', "plot_dimitri_sensor_rsr.pro", "", "PLOT_DIMITRI_SENSOR_RSR", "", "VERBOSEGROUP_LEADERRANGE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr_old.html", "plot_dimitri_sensor_rsr_old.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "plot_dimitri_sensor_rsr_old.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr_old.html#RSR_OBJECT_EVENT", "RSR_OBJECT_EVENT", 'routine in <a href="hmi/plot_dimitri_sensor_rsr_old.html">plot_dimitri_sensor_rsr_old.pro</a>', "plot_dimitri_sensor_rsr_old.pro", "", "RSR_OBJECT_EVENT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr_old.html#RSR_OBJECT_EXIT", "RSR_OBJECT_EXIT", 'routine in <a href="hmi/plot_dimitri_sensor_rsr_old.html">plot_dimitri_sensor_rsr_old.pro</a>', "plot_dimitri_sensor_rsr_old.pro", "", "RSR_OBJECT_EXIT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr_old.html#RSR_OBJECT_OPTION", "RSR_OBJECT_OPTION", 'routine in <a href="hmi/plot_dimitri_sensor_rsr_old.html">plot_dimitri_sensor_rsr_old.pro</a>', "plot_dimitri_sensor_rsr_old.pro", "", "RSR_OBJECT_OPTION", "", "VERBOSEEVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr_old.html#RSR_OBJECT_IMPORT", "RSR_OBJECT_IMPORT", 'routine in <a href="hmi/plot_dimitri_sensor_rsr_old.html">plot_dimitri_sensor_rsr_old.pro</a>', "plot_dimitri_sensor_rsr_old.pro", "", "RSR_OBJECT_IMPORT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr_old.html#RSR_OBJECT_EXPORT", "RSR_OBJECT_EXPORT", 'routine in <a href="hmi/plot_dimitri_sensor_rsr_old.html">plot_dimitri_sensor_rsr_old.pro</a>', "plot_dimitri_sensor_rsr_old.pro", "", "RSR_OBJECT_EXPORT", "", "EVENT", "          -1", "");
  
  libdata[libdataItem++] = new Array("hmi/plot_dimitri_sensor_rsr_old.html#PLOT_DIMITRI_SENSOR_RSR", "PLOT_DIMITRI_SENSOR_RSR", 'routine in <a href="hmi/plot_dimitri_sensor_rsr_old.html">plot_dimitri_sensor_rsr_old.pro</a>', "plot_dimitri_sensor_rsr_old.pro", "", "PLOT_DIMITRI_SENSOR_RSR", "", "VERBOSEGROUP_LEADERRANGE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("toa_simulation/plot_sim_vgt.html", "plot_sim_vgt.pro", '.pro file in <a href="toa_simulation/dir-overview.html">toa_simulation/ directory</a>', "plot_sim_vgt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("toa_simulation/plot_sim_vgt.html#PLOT_SIM_VGT", "PLOT_SIM_VGT", 'routine in <a href="toa_simulation/plot_sim_vgt.html">plot_sim_vgt.pro</a>', "plot_sim_vgt.pro", "", "PLOT_SIM_VGT", "", "VERBOSESL_FOLDERVGT_DATASIM_DATA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/profree.html", "profree.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "profree.pro", "", "", " NAME:    PROFREE   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Free the pointers associated with an PRODIS abstract syntax tree   CALLING SEQUENCE:    PROFREE, TREE   DESCRIPTION:     PROFREE frees the memory and pointers associated with an abstract    syntax tree, as returned by PRODIS.  Users should use this    procedure when they are finished with an abstract syntax tree and    want to release its resources.  The procedure frees all pointers    in the tree recursively.   INPUTS:     TREE - the abstract syntax tree to be freed.  Upon return the           contents of TREE will be undefined.   SEE ALSO:     PRODIS, PROREND, CMSAVEDIR, CMSVLIB   MODIFICATION HISTORY:    Written, 2000-2002, CM    Documented, 19 Mar 2002, CM   $Id: profree.pro,v 1.3 2002/03/19 21:45:02 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/profree.html#profree", "profree", 'routine in <a href="gdl/profree.html">profree.pro</a>', "profree.pro", "", "profree", "", "tree", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/prorend.html", "prorend.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "prorend.pro", "", "", " NAME:    PROREND   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Render a PRODIS abstract syntax tree into IDL Language Text   CALLING SEQUENCE:    PROREND, TREE, TEXT, [ /INIT ]   DESCRIPTION:     PROREND converts an abstract syntax tree as returned by PRODIS,    into a human-readable form, written in the IDL programming    language.  The abstract syntax tree format is a set of linked data    structures, and is derived from the raw data on disk.  The human    readable form is returned as an array of strings that can be    printed to the console or a file.     The abstract syntax tree is generated by PRODIS, an external    procedure in the same library.  The standard approach is to use    the following steps:         1. Use PRODIS to convert raw bytes to abstract syntax tree        2. Use PROREND to convert abstract syntax tree to IDL language     The external routine PROTRANS does the end-to-end conversion steps    of both PRODIS and PROREND for you.     At the moment there is relatively little flexibility in how the    IDL code is rendered to text.  For example, all reserved keywords    and variables appear in upper-case letters, and array indexing    syntax is expressed with round ()'s instead of square []'s.    Suggestions on how to achieve this are solicited.     PROREND does not free the TREE structure.  The user is responsible    to do this using the PROFREE procedure.   COMPATIBILITY:     -- File Format --     PROREND accepts any tree provided by PRODIS.  PRODIS cannot    examine compressed save files.  It is able to read and translate    SAVE files produced by IDL 4, and IDL versions 5.0 through 5.5.    The output of PROREND should be compatible with IDL 4 and 5.     This procedure is part of the CMSVLIB SAVE library for IDL by    Craig Markwardt.  You must have the full CMSVLIB core package    installed in order for this procedure to function properly.   INPUTS:     TREE - the abstract syntax tree, as returned by PRODIS.  This           structure is unmodified by PROREND.     TEXT - upon output, the IDL code is placed in as an array of           strings in TEXT.  By default, any new IDL code will be           *appended* to TEXT.  Use the /INIT keyword to overwrite the           existing contents of TEXT.   KEYWORDS:     INIT - if set, then overwrite the TEXT array with the new IDL           code.  By default (INIT not set), any new IDL code is           *appended* to TEXT.   EXAMPLE:     This example compiles a test function, saves it to a file called    test_pro.sav, and then disassembles the save file into a syntax    tree using PRODIS.  Finally, the syntax tree is converted to IDL    text, which is printed to the console.       IDL&gt; .comp      - pro test_pro, x      -   x = x + 1      -   return      - end      % Compiled module: TEST_PRO.      IDL&gt; save, 'test_pro', /routine, file='test_pro.sav'      IDL&gt; prodis, 'test_pro.sav', prodecl, tree      IDL&gt; prorend, tree, text      IDL&gt; print, text, format='(A)'      PRO TEST_PRO, X        ;; Beginning of code        X = X+1        RETURN      END   SEE ALSO:     PRODIS, PROREND, CMSAVEDIR, CMSVLIB   MODIFICATION HISTORY:    Written, 2000-2002, CM    Documented, 19 Mar 2002, CM    Added PRN_STRCAT, to avoid an internal library function, 22 Mar      2002, CM   $Id: prorend.pro,v 1.13 2002/03/22 22:01:11 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_strcat", "prn_strcat", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_strcat", "", "joinstringstrings", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_push", "prn_push", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_push", "", "nstacktemplatestackval", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_opn", "prn_opn", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_opn", "", "typeembedlast_operationprodeclptr", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_return", "prn_return", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_return", "", "prodecltree", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_ubop", "prn_ubop", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_ubop", "", "binopunopprodecltree", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_assign", "prn_assign", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_assign", "", "nstackprefixprodecltreetext", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_subscript", "prn_subscript", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_subscript", "", "nstackprodecltreetext", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_procall", "prn_procall", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_procall", "", "nstackprefixmethodfunctstatementprodecltreetext", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_array", "prn_array", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_array", "", "prodecltree", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_pderef", "prn_pderef", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_pderef", "", "prodecltree", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_for", "prn_for", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_for", "", "nstackprefixprodecltreetext", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_if", "prn_if", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_if", "", "nstackprefixprodecltreetext", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_while", "prn_while", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_while", "", "nstackprefixprodecltreetext", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_tricond", "prn_tricond", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_tricond", "", "prodecltree", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_onioerror", "prn_onioerror", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_onioerror", "", "prodecltree", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_structref", "prn_structref", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_structref", "", "prodecltree", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_struct", "prn_struct", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_struct", "", "prodecltree", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_case", "prn_case", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_case", "", "nstackprefixprodecltreetext", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prn_parse", "prn_parse", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prn_parse", "", "nstackprefixlast_operationprodecltreetext", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/prorend.html#prorend", "prorend", 'routine in <a href="gdl/prorend.html">prorend.pro</a>', "prorend.pro", "", "prorend", "", "initmangletree0text", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/read_dimitri_extract_toa_ncdf.html", "read_dimitri_extract_toa_ncdf.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "read_dimitri_extract_toa_ncdf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/read_dimitri_extract_toa_ncdf.html#READ_DIMITRI_EXTRACT_TOA_NCDF", "READ_DIMITRI_EXTRACT_TOA_NCDF", 'routine in <a href="misc/read_dimitri_extract_toa_ncdf.html">read_dimitri_extract_toa_ncdf.pro</a>', "read_dimitri_extract_toa_ncdf.pro", "", "READ_DIMITRI_EXTRACT_TOA_NCDF", "", "VERBOSENCDF_FILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/read_sade_prodfile_text.html", "read_sade_prodfile_text.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "read_sade_prodfile_text.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/read_sade_prodfile_text.html#READ_SADE_PRODFILE_TEXT", "READ_SADE_PRODFILE_TEXT", 'routine in <a href="sade/read_sade_prodfile_text.html">read_sade_prodfile_text.pro</a>', "read_sade_prodfile_text.pro", "", "READ_SADE_PRODFILE_TEXT", "", "PRODFILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/read_sade_prodfile_text.html", "read_sade_prodfile_text.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "read_sade_prodfile_text.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/read_sade_prodfile_text.html#read_sade_prodfile_text", "read_sade_prodfile_text", 'routine in <a href="validation/read_sade_prodfile_text.html">read_sade_prodfile_text.pro</a>', "read_sade_prodfile_text.pro", "", "read_sade_prodfile_text", "", "prodfile", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/read_sade_txt.html", "read_sade_txt.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "read_sade_txt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/read_sade_txt.html#READ_SADE_TXT", "READ_SADE_TXT", 'routine in <a href="sade/read_sade_txt.html">read_sade_txt.pro</a>', "read_sade_txt.pro", "", "READ_SADE_TXT", "", "SADEFILESENSOR", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/read_sade_txt.html", "read_sade_txt.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "read_sade_txt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/read_sade_txt.html#read_sade_txt", "read_sade_txt", 'routine in <a href="validation/read_sade_txt.html">read_sade_txt.pro</a>', "read_sade_txt.pro", "", "read_sade_txt", "", "sadefilesensor", "          -1", "");
  
  

libdata[libdataItem++] = new Array("recal/recalibrate_doublets.html", "recalibrate_doublets.pro", '.pro file in <a href="recal/dir-overview.html">recal/ directory</a>', "recalibrate_doublets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("recal/recalibrate_doublets.html#RECALIBRATE_DOUBLETS", "RECALIBRATE_DOUBLETS", 'routine in <a href="recal/recalibrate_doublets.html">recalibrate_doublets.pro</a>', "recalibrate_doublets.pro", "", "RECALIBRATE_DOUBLETS", "", "VERBOSESADE1SADE2OUTPUT_FOLDERRC_REGIONREF_SENSORREF_PROC_VERCAL_SENSORCAL_PROC_VERCLOUD_PERCENTAGEROI_PERCENTAGEVZA_MINVZA_MAXVAA_MINVAA_MAXSZA_MINSZA_MAXSAA_MINSAA_MAX", "          -1", "");
  
  

libdata[libdataItem++] = new Array("recal/recalibrate_doublets_old.html", "recalibrate_doublets_old.pro", '.pro file in <a href="recal/dir-overview.html">recal/ directory</a>', "recalibrate_doublets_old.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("recal/recalibrate_doublets_old.html#RECALIBRATE_DOUBLETS", "RECALIBRATE_DOUBLETS", 'routine in <a href="recal/recalibrate_doublets_old.html">recalibrate_doublets_old.pro</a>', "recalibrate_doublets_old.pro", "", "RECALIBRATE_DOUBLETS", "", "VERBOSEOUTPUT_FOLDERRC_REGIONREF_SENSORREF_PROC_VERCAL_SENSORCAL_PROC_VER", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/remove_bad_parasol.html", "remove_bad_parasol.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "remove_bad_parasol.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/remove_bad_parasol.html#remove_bad_parasol", "remove_bad_parasol", 'routine in <a href="validation/remove_bad_parasol.html">remove_bad_parasol.pro</a>', "remove_bad_parasol.pro", "", "remove_bad_parasol", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/remove_bad_parasol.html#get_parasol_num_pixels", "get_parasol_num_pixels", 'routine in <a href="validation/remove_bad_parasol.html">remove_bad_parasol.pro</a>', "remove_bad_parasol.pro", "", "get_parasol_num_pixels", "", "filename", "          -1", "");
  
  

libdata[libdataItem++] = new Array("sade/remove_bad_sade.html", "remove_bad_sade.pro", '.pro file in <a href="sade/dir-overview.html">sade/ directory</a>', "remove_bad_sade.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sade/remove_bad_sade.html#REMOVE_BAD_SADE", "REMOVE_BAD_SADE", 'routine in <a href="sade/remove_bad_sade.html">remove_bad_sade.pro</a>', "remove_bad_sade.pro", "", "REMOVE_BAD_SADE", "", "SITESENSORPROC_VERPRODFILE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/remove_bad_sade.html", "remove_bad_sade.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "remove_bad_sade.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/remove_bad_sade.html#remove_bad_sade", "remove_bad_sade", 'routine in <a href="validation/remove_bad_sade.html">remove_bad_sade.pro</a>', "remove_bad_sade.pro", "", "remove_bad_sade", "", "sitesensorproc_verprodfile", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/remove_data_from_database.html", "remove_data_from_database.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "remove_data_from_database.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/remove_data_from_database.html#remove_data_from_database", "remove_data_from_database", 'routine in <a href="validation/remove_data_from_database.html">remove_data_from_database.pro</a>', "remove_data_from_database.pro", "", "remove_data_from_database", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/remove_night.html", "remove_night.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "remove_night.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/remove_night.html#remove_night", "remove_night", 'routine in <a href="validation/remove_night.html">remove_night.pro</a>', "remove_night.pro", "", "remove_night", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/repstr.html", "repstr.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "repstr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/repstr.html#repstr", "repstr", 'routine in <a href="gdl/repstr.html">repstr.pro</a>', "repstr.pro", "", "repstr", " NAME: 	REPSTR  PURPOSE: 	Replace all occurences of one substring by another.  EXPLANATION: 	Meant to emulate the string substitution capabilities of text editors         For a more sophisticated routine that allows regular expressions look        at MG_STRREPLACE()        http://docs.idldev.com/idllib/strings/mg_streplace.html  CALLING SEQUENCE: 	result = repstr( obj, in, out )   INPUT PARAMETERS: 	obj    = object string for editing, scalar or array 	in     = substring of 'obj' to be replaced, scalar   OPTIONAL INPUT PARMETER: 	out    = what 'in' is replaced with, scalar.   If not supplied 		then out = '', i.e. 'in' is not replaced by anything.   OUTPUT PARAMETERS: 	Result returned as function value.  Input object string 	not changed unless assignment done in calling program.   PROCEDURE: 	Searches for 'in', splits 'obj' into 3 pieces, reassembles 	with 'out' in place of 'in'.  Repeats until all cases done.   EXAMPLE: 	If a = 'I am what I am' then print,repstr(a,'am','was') 	will give 'I was what I was'.   MODIFICATION HISTORY: 	Written by Robert S. Hill, ST Systems Corp., 12 April 1989. 	Accept vector object strings, W. Landsman   HSTX,   April, 1996        Convert loop to LONG, vectorize STRLEN call W. Landsman June 2002        Correct bug in optimization, case where STRLEN(OBJ) EQ          STRLEN(IN), C. Markwardt, Jan 2003        Fixed problem when multiple replacements extend the string length                  D. Finkbeiner, W. Landsman  April 2003        Allow third parameter to be optional again W. Landsman  August 2003        Remove limitation of 9999 characters, C. Markwardt Dec 2003        Test for empty  in  string (causing infinite loop) W. Landsman Jan 2010        Streamline code W Landsman Dec 2011  ", "objinout", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/reset_dimitri_database.html", "reset_dimitri_database.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "reset_dimitri_database.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/reset_dimitri_database.html#REMOVE_NIGHT_PRODUCTS", "REMOVE_NIGHT_PRODUCTS", 'routine in <a href="validation/reset_dimitri_database.html">reset_dimitri_database.pro</a>', "reset_dimitri_database.pro", "", "REMOVE_NIGHT_PRODUCTS", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/reset_dimitri_database.html#REMOVE_DIMITRI_SAVS", "REMOVE_DIMITRI_SAVS", 'routine in <a href="validation/reset_dimitri_database.html">reset_dimitri_database.pro</a>', "reset_dimitri_database.pro", "", "REMOVE_DIMITRI_SAVS", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/reset_dimitri_database.html#BATCH_INGEST_ALL", "BATCH_INGEST_ALL", 'routine in <a href="validation/reset_dimitri_database.html">reset_dimitri_database.pro</a>', "reset_dimitri_database.pro", "", "BATCH_INGEST_ALL", "", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("validation/reset_dimitri_database.html#RESET_DIMITRI_DATABASE", "RESET_DIMITRI_DATABASE", 'routine in <a href="validation/reset_dimitri_database.html">reset_dimitri_database.pro</a>', "reset_dimitri_database.pro", "", "RESET_DIMITRI_DATABASE", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/resolve_every.html", "resolve_every.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "resolve_every.pro", "", "", " NAME: 	RESOLVE_EVERY   PURPOSE: 	Resolve (by compiling) all procedures and functions. 	This is useful when preparing .sav files containing all the IDL 	routines required for an application.  CATEGORY: 	Programming.  CALLING SEQUENCE: 	RESOLVE_EVERY  INPUTS: 	None.  KEYWORD PARAMETERS: 	QUIET = if set, produce no messages.  	SKIP_ROUTINES = an optional string array containing the names  	    of routines to NOT resolve.  This is useful when a library  	    file containing the designated routines will be later included.  OUTPUTS: 	No explicit outputs.  COMMON BLOCKS: 	None.  SIDE EFFECTS:  RESTRICTIONS: 	Will not resolve procedures or functions that are called via 	CALL_PROCEDURE, CALL_FUNCTION, or EXECUTE.  Only explicit calls 	are resolved.  	If an unresolved procedure or function is not in the IDL 	search path, an error occurs, and no additional routines 	are resolved.   PROCEDURE: 	This routine iteratively determines the names of unresolved calls 	to user-written or library procedures and functions, and then 	compiles them.  The process stops when there are no unresolved 	routines.  EXAMPLE: 	RESOLVE_EVERY.  MODIFICATION HISTORY:  	Written by: 	DMS, RSI, January, 1995. 	DMS, RSI, April, 1997, Added SKIP_ROUTINES keyword.      mgs, Harvard, 21 Apr 1998: use findfile before trying to resolve        a routine  ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/resolve_every.html#resolve_every", "resolve_every", 'routine in <a href="misc/resolve_every.html">resolve_every.pro</a>', "resolve_every.pro", "", "resolve_every", "", "QUIETSKIP_ROUTINES", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/restore.html", "restore.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "restore.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/restore.html#RESTORE", "RESTORE", 'routine in <a href="gdl/restore.html">restore.pro</a>', "restore.pro", "", "RESTORE", " NAME: RESTORE   PURPOSE:        Serves as a wrapper around CMSAVE from Craig B. Markwardt CMVSLIB        library. You must download and install yourself this CMVSLIB library        then add it PATH in your GDL_PATH. This library can be found here:        http://cow.physics.wisc.edu/~craigm/idl/cmsave.html   MODIFICATION HISTORY:    01-Sep-2006 : written by Joel Gales    15-dec-2006 : by Alain Coulais (AC)       1/ explicite HTTP link in header to external CMVSLIB library       2/ test via EXECUTE() in pro to warn new users for missing                    external CMVSLIB library    12-feb-2007: modifications by AC:       1a/ managing filename.       1b/ default filename if no filename provided (see CMSAVE)       2/ add keyword /verbose ... (but bug in CMRESTORE (2 time print !))       3/ warning for 3 keywords not managed yet    13-Nov-2012: modifications by AC:       1/ feature request 3581835       2/ proper STRING conversion of input file name       3/ extra keywords /help and /test   LICENCE:  Copyright (C) 2006-2012, J. Gales and A. Coulais  This program is free software; you can redistribute it and/or modify  it under the terms of the GNU General Public License as published by  the Free Software Foundation; either version 2 of the License, or  (at your option) any later version.   ", "filenameRELAXED_STRUCTURE_ASSIGNMENTDESCRIPTIONRESTORED_OBJECTShelpverbosetestfilename0", "          -1", "");
  
  

libdata[libdataItem++] = new Array("brdf/roujean_brdf.html", "roujean_brdf.pro", '.pro file in <a href="brdf/dir-overview.html">brdf/ directory</a>', "roujean_brdf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("brdf/roujean_brdf.html#ROUJEAN_BRDF", "ROUJEAN_BRDF", 'routine in <a href="brdf/roujean_brdf.html">roujean_brdf.pro</a>', "roujean_brdf.pro", "", "ROUJEAN_BRDF", "", "NO_PLOTSVERBOSESTART_TIMESTOP_TIMENB_ACQUI_LIMITOFOLDERRB_REGIONREF_SENSORREF_PROC_VERBRDF_BIN", "          -1", "");
  
  

libdata[libdataItem++] = new Array("brdf/roujean_brdf_coef.html", "roujean_brdf_coef.pro", '.pro file in <a href="brdf/dir-overview.html">brdf/ directory</a>', "roujean_brdf_coef.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("brdf/roujean_brdf_coef.html#ROUJEAN_BRDF_COEF", "ROUJEAN_BRDF_COEF", 'routine in <a href="brdf/roujean_brdf_coef.html">roujean_brdf_coef.pro</a>', "roujean_brdf_coef.pro", "", "ROUJEAN_BRDF_COEF", "", "DEGREESVERBOSEBC_SZABC_VZABC_DPHIBC_RHO", "          -1", "");
  
  

libdata[libdataItem++] = new Array("brdf/roujean_brdf_compute_rho.html", "roujean_brdf_compute_rho.pro", '.pro file in <a href="brdf/dir-overview.html">brdf/ directory</a>', "roujean_brdf_compute_rho.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("brdf/roujean_brdf_compute_rho.html#ROUJEAN_BRDF_COMPUTE_RHO", "ROUJEAN_BRDF_COMPUTE_RHO", 'routine in <a href="brdf/roujean_brdf_compute_rho.html">roujean_brdf_compute_rho.pro</a>', "roujean_brdf_compute_rho.pro", "", "ROUJEAN_BRDF_COMPUTE_RHO", "", "DEGREESVERBOSERHO_SZARHO_VZARHO_DPHIK_COEFFICIENT", "          -1", "");
  
  

libdata[libdataItem++] = new Array("brdf/roujean_brdf_kernel_f1.html", "roujean_brdf_kernel_f1.pro", '.pro file in <a href="brdf/dir-overview.html">brdf/ directory</a>', "roujean_brdf_kernel_f1.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("brdf/roujean_brdf_kernel_f1.html#ROUJEAN_BRDF_KERNEL_F1", "ROUJEAN_BRDF_KERNEL_F1", 'routine in <a href="brdf/roujean_brdf_kernel_f1.html">roujean_brdf_kernel_f1.pro</a>', "roujean_brdf_kernel_f1.pro", "", "ROUJEAN_BRDF_KERNEL_F1", "", "DEGREESVERBOSEK1_SZAK1_VZAK1_RAA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("brdf/roujean_brdf_kernel_f2.html", "roujean_brdf_kernel_f2.pro", '.pro file in <a href="brdf/dir-overview.html">brdf/ directory</a>', "roujean_brdf_kernel_f2.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("brdf/roujean_brdf_kernel_f2.html#ROUJEAN_BRDF_KERNEL_F2", "ROUJEAN_BRDF_KERNEL_F2", 'routine in <a href="brdf/roujean_brdf_kernel_f2.html">roujean_brdf_kernel_f2.pro</a>', "roujean_brdf_kernel_f2.pro", "", "ROUJEAN_BRDF_KERNEL_F2", "", "DEGREESVERBOSEK2_SZAK2_VZAK2_RAA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("brdf/roujean_brdf_old.html", "roujean_brdf_old.pro", '.pro file in <a href="brdf/dir-overview.html">brdf/ directory</a>', "roujean_brdf_old.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("brdf/roujean_brdf_old.html#ROUJEAN_BRDF", "ROUJEAN_BRDF", 'routine in <a href="brdf/roujean_brdf_old.html">roujean_brdf_old.pro</a>', "roujean_brdf_old.pro", "", "ROUJEAN_BRDF", "", "NO_PLOTSVERBOSEOFOLDERRB_REGIONREF_SENSORREF_PROC_VERBRDF_BIN", "          -1", "");
  
  

libdata[libdataItem++] = new Array("brdf/roujean_brdf_plots.html", "roujean_brdf_plots.pro", '.pro file in <a href="brdf/dir-overview.html">brdf/ directory</a>', "roujean_brdf_plots.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("brdf/roujean_brdf_plots.html#ROUJEAN_BRDF_PLOTS", "ROUJEAN_BRDF_PLOTS", 'routine in <a href="brdf/roujean_brdf_plots.html">roujean_brdf_plots.pro</a>', "roujean_brdf_plots.pro", "", "ROUJEAN_BRDF_PLOTS", "", "BRDF_SZAN_POINTSNO_ZBUFFVERBOSEJPEG_NAME_BASEBD_REGIONBD_SENSORK1_ROUJEANK2_ROUJEANK3_ROUJEANERR_ROUJEAN", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/rsr_legend_update.html", "rsr_legend_update.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "rsr_legend_update.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/rsr_legend_update.html#RSR_LEGEND_UPDATE", "RSR_LEGEND_UPDATE", 'routine in <a href="hmi/rsr_legend_update.html">rsr_legend_update.pro</a>', "rsr_legend_update.pro", "", "RSR_LEGEND_UPDATE", "", "VERBOSERSR_INFO", "          -1", "");
  
  

libdata[libdataItem++] = new Array("hmi/rsr_plot_reset.html", "rsr_plot_reset.pro", '.pro file in <a href="hmi/dir-overview.html">hmi/ directory</a>', "rsr_plot_reset.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("hmi/rsr_plot_reset.html#RSR_PLOT_RESET", "RSR_PLOT_RESET", 'routine in <a href="hmi/rsr_plot_reset.html">rsr_plot_reset.pro</a>', "rsr_plot_reset.pro", "", "RSR_PLOT_RESET", "", "VERBOSERSR_INFO", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/save_dimitri_configuration.html", "save_dimitri_configuration.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "save_dimitri_configuration.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/save_dimitri_configuration.html#SAVE_DIMITRI_CONFIGURATION", "SAVE_DIMITRI_CONFIGURATION", 'routine in <a href="misc/save_dimitri_configuration.html">save_dimitri_configuration.pro</a>', "save_dimitri_configuration.pro", "", "SAVE_DIMITRI_CONFIGURATION", "", "VERBOSECFIG_DATA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("database/save_dimitri_database.html", "save_dimitri_database.pro", '.pro file in <a href="database/dir-overview.html">database/ directory</a>', "save_dimitri_database.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("database/save_dimitri_database.html#SAVE_DIMITRI_DATABASE", "SAVE_DIMITRI_DATABASE", 'routine in <a href="database/save_dimitri_database.html">save_dimitri_database.pro</a>', "save_dimitri_database.pro", "", "SAVE_DIMITRI_DATABASE", "", "VERBOSEDB_DATA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/sensor_band_info.html", "sensor_band_info.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "sensor_band_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/sensor_band_info.html#SENSOR_BAND_INFO", "SENSOR_BAND_INFO", 'routine in <a href="misc/sensor_band_info.html">sensor_band_info.pro</a>', "sensor_band_info.pro", "", "SENSOR_BAND_INFO", "", "VERBOSESENSOR_BD", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/sensor_direction_info.html", "sensor_direction_info.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "sensor_direction_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/sensor_direction_info.html#SENSOR_DIRECTION_INFO", "SENSOR_DIRECTION_INFO", 'routine in <a href="misc/sensor_direction_info.html">sensor_direction_info.pro</a>', "sensor_direction_info.pro", "", "SENSOR_DIRECTION_INFO", "", "VERBOSESENSOR_BD", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/sensor_pixel_size.html", "sensor_pixel_size.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "sensor_pixel_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/sensor_pixel_size.html#SENSOR_PIXEL_SIZE", "SENSOR_PIXEL_SIZE", 'routine in <a href="misc/sensor_pixel_size.html">sensor_pixel_size.pro</a>', "sensor_pixel_size.pro", "", "SENSOR_PIXEL_SIZE", "", "AREAVERBOSESENSOR_PX", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/simulate_vgt_from_merisaatsr.html", "simulate_vgt_from_merisaatsr.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "simulate_vgt_from_merisaatsr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/simulate_vgt_from_merisaatsr.html#simulate_VGT_from_MERISAATSR", "simulate_VGT_from_MERISAATSR", 'routine in <a href="validation/simulate_vgt_from_merisaatsr.html">simulate_vgt_from_merisaatsr.pro</a>', "simulate_vgt_from_merisaatsr.pro", "", "simulate_VGT_from_MERISAATSR", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/sort_vgt_vaa.html", "sort_vgt_vaa.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "sort_vgt_vaa.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/sort_vgt_vaa.html#sort_VGT_VAA", "sort_VGT_VAA", 'routine in <a href="validation/sort_vgt_vaa.html">sort_vgt_vaa.pro</a>', "sort_vgt_vaa.pro", "", "sort_VGT_VAA", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/statistical_cloud_screening.html", "statistical_cloud_screening.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "statistical_cloud_screening.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/statistical_cloud_screening.html#STATISTICAL_CLOUD_SCREENING", "STATISTICAL_CLOUD_SCREENING", 'routine in <a href="validation/statistical_cloud_screening.html">statistical_cloud_screening.pro</a>', "statistical_cloud_screening.pro", "", "STATISTICAL_CLOUD_SCREENING", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/strmatch.html", "strmatch.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "strmatch.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/strmatch.html#STRMATCH_STRREPLACE", "STRMATCH_STRREPLACE", 'routine in <a href="gdl/strmatch.html">strmatch.pro</a>', "strmatch.pro", "", "STRMATCH_STRREPLACE", "", "strab", "          -1", "");
  
  libdata[libdataItem++] = new Array("gdl/strmatch.html#STRMATCH", "STRMATCH", 'routine in <a href="gdl/strmatch.html">strmatch.pro</a>', "strmatch.pro", "", "STRMATCH", "", "fold_casemstrsstr", "          -1", "");
  
  

libdata[libdataItem++] = new Array("gdl/tagsize.html", "tagsize.pro", '.pro file in <a href="gdl/dir-overview.html">gdl/ directory</a>', "tagsize.pro", "", "", " NAME:    TAGSIZE   AUTHOR:    Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770    craigm@lheamail.gsfc.nasa.gov   PURPOSE:    Compute SIZE descriptors for each tag in a structure   CALLING SEQUENCE:    SIZES = TAGSIZE(STRUCT, N_TAGS=ntags, TAG_NAMES=tagnames,                    STRUCTURE_NAME=structname, STATUS=status, LENGTH=length)   DESCRIPTION:     The TAGSIZE function determines the types and sizes of each tag in    a structure.  This is not as easy as it may seem, because IDL    makes it very, *very* difficult to find out the true dimensions of    a structure element.     Here is a brief explanation.  It is known that IDL drops trailing    dimensions of size 1 in many situations.  Also, for structures    only, arrays of any dimensionality which have only one element are    RETURNED AS SCALARS.  Thus, if you are doing any heavy duty work    with structures, copying and querying individual elements between    structures, etc., you will find that you will lose some crucial    dimensions which you can't normally regain.     TAGSIZE attempts to work around all of these limitations to    present the true dimensions of all elements in a structure.     It returns an 11xNTAGS array, which contains a SIZE-style vector    for each element in the structure.  Eleven elements is the largest    array size needed to describe any IDL data type using SIZE.  Thus,    to extract information about the second tag in structure X    (element number 1 starting from zero), you would use the following    code:       SIZES = TAGSIZE(X)  ;; Extract type information from structure X      SIZE_1 = SIZES(*,1) ;; Extract type information about the 2nd element       SIZE_1 = SIZE_1(0:SIZE_1(0)+2) ;; Trim the array if desired     The last command is optional, but trims the resulting array to be    a true SIZE-style result.     TAGSIZE also has several convenience keywords to extract other    relevant information about a structure.   INPUTS:     STRUCTURE - any structure to examine.  If the value is not a                structure then an error is reported.   KEYWORDS:     N_TAGS - upon return, the number of tags in the structure is             stored in this keyword.     TAG_NAMES - upon return, the names of each tag are stored in this                keyword, as an array of strings.     STRUCTURE_NAME - upon return, the name of the structure is stored                     in this keyword.  If the structure is anonymous                     then the empty string ('') is returned.     LENGTH - upon return, the size in bytes of each tag element in the             structure is stored in this keyword, as an array of             integers.     STATUS - upon return, the status is stored in this keyword.  A             value of 1 indicates success, 0 indicates failure.   RETURNS:     A two dimensional array, with dimensions LONARR(11,NTAGS),    containing the size information of all tag elements in the    structure.  SIZES(*,i) is the SIZE-style vector for tag element i.   EXAMPLE:     Compute the sizes of the elements in X, defined here.      IDL&gt; x = {a: [1], b: intarr(2,2), c: reform(strarr(2,1),2,1)}      IDL&gt; help, /struct, x      ** Structure &lt;818c8b4&gt;, 3 tags, length=28, refs=1:         A               INT       Array[1]         B               INT       Array[2, 2]         C               STRING    Array[2, 1]      IDL&gt; print, byte(tagsize(x))         1  [1]  2   1   0   0   0   0   0   0   0         2  [2   2]  2   4   0   0   0   0   0   0         2  [2   1]  7   2   0   0   0   0   0   0      [ Array dimensions are emphasized with brackets ]     Compare this to the type information returned by HELP, which is    incorrect for tags A and C.      IDL&gt; help, x.a, x.b, x.c      &lt;Expression&gt;    INT       =        1      &lt;Expression&gt;    INT       = Array[2, 2]      &lt;Expression&gt;    STRING    = Array[2]   SEE ALSO:     TAG_NAMES, N_TAGS, SIZE, HELP, INPUTFORM, HELPFORM   MODIFICATION HISTORY:    Written, CM, 13 May 2000    Documented, 05 Jul 2000    Small documentation changes, CM, 31 Aug 2000    Signficant cleanup of HELP parsing, CM, 04 Dec 2000    Added case for array of structures with new parsing, CM 12 Jan      2001    $Id: tagsize.pro,v 1.4 2001/02/09 04:57:42 craigm Exp $   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("gdl/tagsize.html#tagsize", "tagsize", 'routine in <a href="gdl/tagsize.html">tagsize.pro</a>', "tagsize.pro", "", "tagsize", "", "n_tagstag_namesstructure_namestatusnocatchlengthstructure", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_date_info.html", "test_get_viirs_date_info.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_get_viirs_date_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_date_info.html#TEST_GET_VIIRS_DATE_INFO", "TEST_GET_VIIRS_DATE_INFO", 'routine in <a href="viirs/test/test_get_viirs_date_info.html">test_get_viirs_date_info.pro</a>', "test_get_viirs_date_info.pro", "", "TEST_GET_VIIRS_DATE_INFO", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_emissive_btemp.html", "test_get_viirs_emissive_btemp.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_get_viirs_emissive_btemp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_emissive_btemp.html#TEST_GET_VIIRS_EMISSIVE_BTEMP", "TEST_GET_VIIRS_EMISSIVE_BTEMP", 'routine in <a href="viirs/test/test_get_viirs_emissive_btemp.html">test_get_viirs_emissive_btemp.pro</a>', "test_get_viirs_emissive_btemp.pro", "", "TEST_GET_VIIRS_EMISSIVE_BTEMP", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_l1b_radiance.html", "test_get_viirs_l1b_radiance.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_get_viirs_l1b_radiance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_l1b_radiance.html#TEST_GET_VIIRS_L1B_RADIANCE", "TEST_GET_VIIRS_L1B_RADIANCE", 'routine in <a href="viirs/test/test_get_viirs_l1b_radiance.html">test_get_viirs_l1b_radiance.pro</a>', "test_get_viirs_l1b_radiance.pro", "", "TEST_GET_VIIRS_L1B_RADIANCE", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_l1b_reflectance.html", "test_get_viirs_l1b_reflectance.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_get_viirs_l1b_reflectance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_l1b_reflectance.html#TEST_GET_VIIRS_L1B_REFLECTANCE", "TEST_GET_VIIRS_L1B_REFLECTANCE", 'routine in <a href="viirs/test/test_get_viirs_l1b_reflectance.html">test_get_viirs_l1b_reflectance.pro</a>', "test_get_viirs_l1b_reflectance.pro", "", "TEST_GET_VIIRS_L1B_REFLECTANCE", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_lat_lon.html", "test_get_viirs_lat_lon.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_get_viirs_lat_lon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_lat_lon.html#TEST_GET_VIIRS_LAT_LON", "TEST_GET_VIIRS_LAT_LON", 'routine in <a href="viirs/test/test_get_viirs_lat_lon.html">test_get_viirs_lat_lon.pro</a>', "test_get_viirs_lat_lon.pro", "", "TEST_GET_VIIRS_LAT_LON", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_quicklook.html", "test_get_viirs_quicklook.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_get_viirs_quicklook.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_quicklook.html#TEST_GET_VIIRS_QUICKLOOK", "TEST_GET_VIIRS_QUICKLOOK", 'routine in <a href="viirs/test/test_get_viirs_quicklook.html">test_get_viirs_quicklook.pro</a>', "test_get_viirs_quicklook.pro", "", "TEST_GET_VIIRS_QUICKLOOK", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_viewing_geometries.html", "test_get_viirs_viewing_geometries.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_get_viirs_viewing_geometries.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_get_viirs_viewing_geometries.html#TEST_GET_VIIRS_VIEWING_GEOMETRIES", "TEST_GET_VIIRS_VIEWING_GEOMETRIES", 'routine in <a href="viirs/test/test_get_viirs_viewing_geometries.html">test_get_viirs_viewing_geometries.pro</a>', "test_get_viirs_viewing_geometries.pro", "", "TEST_GET_VIIRS_VIEWING_GEOMETRIES", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("meris/test_ingest_meris_product.html", "test_ingest_meris_product.pro", '.pro file in <a href="meris/dir-overview.html">meris/ directory</a>', "test_ingest_meris_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("meris/test_ingest_meris_product.html#test_ingest_meris_product", "test_ingest_meris_product", 'routine in <a href="meris/test_ingest_meris_product.html">test_ingest_meris_product.pro</a>', "test_ingest_meris_product.pro", "", "test_ingest_meris_product", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("modisa/test/test_ingest_modisa_product.html", "test_ingest_modisa_product.pro", '.pro file in <a href="modisa/test/dir-overview.html">modisa/test/ directory</a>', "test_ingest_modisa_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("modisa/test/test_ingest_modisa_product.html#TEST_INGEST_MODISA_PRODUCT", "TEST_INGEST_MODISA_PRODUCT", 'routine in <a href="modisa/test/test_ingest_modisa_product.html">test_ingest_modisa_product.pro</a>', "test_ingest_modisa_product.pro", "", "TEST_INGEST_MODISA_PRODUCT", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_ingest_viirs_product.html", "test_ingest_viirs_product.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_ingest_viirs_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_ingest_viirs_product.html#TEST_INGEST_VIIRS_PRODUCT", "TEST_INGEST_VIIRS_PRODUCT", 'routine in <a href="viirs/test/test_ingest_viirs_product.html">test_ingest_viirs_product.pro</a>', "test_ingest_viirs_product.pro", "", "TEST_INGEST_VIIRS_PRODUCT", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/test_transmission.html", "test_transmission.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "test_transmission.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/test_transmission.html#test_transmission", "test_transmission", 'routine in <a href="validation/test_transmission.html">test_transmission.pro</a>', "test_transmission.pro", "", "test_transmission", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/test_vgt_stereo_coord.html", "test_vgt_stereo_coord.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "test_vgt_stereo_coord.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/test_vgt_stereo_coord.html#test_vgt_stereo_coord", "test_vgt_stereo_coord", 'routine in <a href="validation/test_vgt_stereo_coord.html">test_vgt_stereo_coord.pro</a>', "test_vgt_stereo_coord.pro", "", "test_vgt_stereo_coord", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("viirs/test/test_viirs_l1b_emmisive.html", "test_viirs_l1b_emmisive.pro", '.pro file in <a href="viirs/test/dir-overview.html">viirs/test/ directory</a>', "test_viirs_l1b_emmisive.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("viirs/test/test_viirs_l1b_emmisive.html#TEST_VIIRS_L1B_EMMISIVE", "TEST_VIIRS_L1B_EMMISIVE", 'routine in <a href="viirs/test/test_viirs_l1b_emmisive.html">test_viirs_l1b_emmisive.pro</a>', "test_viirs_l1b_emmisive.pro", "", "TEST_VIIRS_L1B_EMMISIVE", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/timestr_to_julday.html", "timestr_to_julday.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "timestr_to_julday.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/timestr_to_julday.html#TIMESTR_TO_JULDAY", "TIMESTR_TO_JULDAY", 'routine in <a href="misc/timestr_to_julday.html">timestr_to_julday.pro</a>', "timestr_to_julday.pro", "", "TIMESTR_TO_JULDAY", "", "TIMESTR", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/untitled_1.html", "untitled_1.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "untitled_1.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("database/update_dimitri_database.html", "update_dimitri_database.pro", '.pro file in <a href="database/dir-overview.html">database/ directory</a>', "update_dimitri_database.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("database/update_dimitri_database.html#UPDATE_DIMITRI_DATABASE", "UPDATE_DIMITRI_DATABASE", 'routine in <a href="database/update_dimitri_database.html">update_dimitri_database.pro</a>', "update_dimitri_database.pro", "", "UPDATE_DIMITRI_DATABASE", "", "SORT_DBVERBOSEDB_DATA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/update_dimitri_extract_toa_ncdf.html", "update_dimitri_extract_toa_ncdf.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "update_dimitri_extract_toa_ncdf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/update_dimitri_extract_toa_ncdf.html#UPDATE_DIMITRI_EXTRACT_TOA_NCDF", "UPDATE_DIMITRI_EXTRACT_TOA_NCDF", 'routine in <a href="misc/update_dimitri_extract_toa_ncdf.html">update_dimitri_extract_toa_ncdf.pro</a>', "update_dimitri_extract_toa_ncdf.pro", "", "UPDATE_DIMITRI_EXTRACT_TOA_NCDF", "", "VERBOSENSITENSENSORNPROCVVARNAMEVARDATA", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/update_netcdfs.html", "update_netcdfs.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "update_netcdfs.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/update_netcdfs.html#update_netcdfs", "update_netcdfs", 'routine in <a href="validation/update_netcdfs.html">update_netcdfs.pro</a>', "update_netcdfs.pro", "", "update_netcdfs", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_aatsr.html", "validate_aatsr.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_aatsr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_aatsr.html#validate_aatsr", "validate_aatsr", 'routine in <a href="validation/validate_aatsr.html">validate_aatsr.pro</a>', "validate_aatsr.pro", "", "validate_aatsr", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_brdf.html", "validate_brdf.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_brdf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_brdf.html#VALIDATE_BRDF", "VALIDATE_BRDF", 'routine in <a href="validation/validate_brdf.html">validate_brdf.pro</a>', "validate_brdf.pro", "", "VALIDATE_BRDF", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_cloud_screening.html", "validate_cloud_screening.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_cloud_screening.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_cloud_screening.html#VALIDATE_CLOUD_SCREENING", "VALIDATE_CLOUD_SCREENING", 'routine in <a href="validation/validate_cloud_screening.html">validate_cloud_screening.pro</a>', "validate_cloud_screening.pro", "", "VALIDATE_CLOUD_SCREENING", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_doublet.html", "validate_doublet.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_doublet.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_doublet.html#VALIDATE_doublet", "VALIDATE_doublet", 'routine in <a href="validation/validate_doublet.html">validate_doublet.pro</a>', "validate_doublet.pro", "", "VALIDATE_doublet", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_ingest.html", "validate_ingest.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_ingest.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_ingest.html#validate_ingest", "validate_ingest", 'routine in <a href="validation/validate_ingest.html">validate_ingest.pro</a>', "validate_ingest.pro", "", "validate_ingest", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_intercal.html", "validate_intercal.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_intercal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_intercal.html#VALIDATE_intercal", "VALIDATE_intercal", 'routine in <a href="validation/validate_intercal.html">validate_intercal.pro</a>', "validate_intercal.pro", "", "VALIDATE_intercal", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_recal.html", "validate_recal.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_recal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_recal.html#VALIDATE_recal", "VALIDATE_recal", 'routine in <a href="validation/validate_recal.html">validate_recal.pro</a>', "validate_recal.pro", "", "VALIDATE_recal", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_roi.html", "validate_roi.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_roi.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_roi.html#validate_roi", "validate_roi", 'routine in <a href="validation/validate_roi.html">validate_roi.pro</a>', "validate_roi.pro", "", "validate_roi", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_vgt_simulation.html", "validate_vgt_simulation.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_vgt_simulation.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_vgt_simulation.html#validate_vgt_simulation", "validate_vgt_simulation", 'routine in <a href="validation/validate_vgt_simulation.html">validate_vgt_simulation.pro</a>', "validate_vgt_simulation.pro", "", "validate_vgt_simulation", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/validate_visu.html", "validate_visu.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "validate_visu.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/validate_visu.html#validate_visu", "validate_visu", 'routine in <a href="validation/validate_visu.html">validate_visu.pro</a>', "validate_visu.pro", "", "validate_visu", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/vgt_child/vgt_child_log.html", "vgt_child_log.pro", '.pro file in <a href="validation/vgt_child/dir-overview.html">validation/vgt_child/ directory</a>', "vgt_child_log.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/vgt_child/vgt_child_log.html#vgt_child_log", "vgt_child_log", 'routine in <a href="validation/vgt_child/vgt_child_log.html">vgt_child_log.pro</a>', "vgt_child_log.pro", "", "vgt_child_log", "", "log_fileofolderpcoordsgcoords", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/vgt_child/vgt_child_main.html", "vgt_child_main.pro", '.pro file in <a href="validation/vgt_child/dir-overview.html">validation/vgt_child/ directory</a>', "vgt_child_main.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/vgt_child/vgt_child_main.html#vgt_child_main", "vgt_child_main", 'routine in <a href="validation/vgt_child/vgt_child_main.html">vgt_child_main.pro</a>', "vgt_child_main.pro", "", "vgt_child_main", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/vgt_child/vgt_child_product.html", "vgt_child_product.pro", '.pro file in <a href="validation/vgt_child/dir-overview.html">validation/vgt_child/ directory</a>', "vgt_child_product.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/vgt_child/vgt_child_product.html#vgt_child_product", "vgt_child_product", 'routine in <a href="validation/vgt_child/vgt_child_product.html">vgt_child_product.pro</a>', "vgt_child_product.pro", "", "vgt_child_product", "", "ifolderofolderdlicoords", "          -1", "");
  
  

libdata[libdataItem++] = new Array("vegetation/vgt_correction_template.html", "vgt_correction_template.pro", '.pro file in <a href="vegetation/dir-overview.html">vegetation/ directory</a>', "vgt_correction_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("vegetation/vgt_correction_template.html#VGT_CORRECTION_TEMPLATE", "VGT_CORRECTION_TEMPLATE", 'routine in <a href="vegetation/vgt_correction_template.html">vgt_correction_template.pro</a>', "vgt_correction_template.pro", "", "VGT_CORRECTION_TEMPLATE", "", "VERBOSE", "          -1", "");
  
  

libdata[libdataItem++] = new Array("toa_simulation/vgt_simulation.html", "vgt_simulation.pro", '.pro file in <a href="toa_simulation/dir-overview.html">toa_simulation/ directory</a>', "vgt_simulation.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("toa_simulation/vgt_simulation.html#VGT_SIMULATION", "VGT_SIMULATION", 'routine in <a href="toa_simulation/vgt_simulation.html">vgt_simulation.pro</a>', "vgt_simulation.pro", "", "VGT_SIMULATION", "", "VERBOSEVGT_SADESL_REGIONMER_FOLDERMER_PROC_VERATS_FOLDERATS_PROC_VERVGT_PROC_VERCLOUD_PERCENTAGEROI_PERCENTAGEBRDF_BIN_PERIODVZAMINVZAMAXVAAMINVAAMAXSZAMINSZAMAXSAAMINSAAMAX", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/vgtbatch.html", "vgtbatch.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "vgtbatch.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/vgtbatch.html#vgtbatch", "vgtbatch", 'routine in <a href="validation/vgtbatch.html">vgtbatch.pro</a>', "vgtbatch.pro", "", "vgtbatch", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("validation/vgtextract.html", "vgtextract.pro", '.pro file in <a href="validation/dir-overview.html">validation/ directory</a>', "vgtextract.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("validation/vgtextract.html#vgtextract", "vgtextract", 'routine in <a href="validation/vgtextract.html">vgtextract.pro</a>', "vgtextract.pro", "", "vgtextract", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("misc/write_dimitri_extract_toa_ncdf.html", "write_dimitri_extract_toa_ncdf.pro", '.pro file in <a href="misc/dir-overview.html">misc/ directory</a>', "write_dimitri_extract_toa_ncdf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("misc/write_dimitri_extract_toa_ncdf.html#WRITE_DIMITRI_EXTRACT_TOA_NCDF", "WRITE_DIMITRI_EXTRACT_TOA_NCDF", 'routine in <a href="misc/write_dimitri_extract_toa_ncdf.html">write_dimitri_extract_toa_ncdf.pro</a>', "write_dimitri_extract_toa_ncdf.pro", "", "WRITE_DIMITRI_EXTRACT_TOA_NCDF", "", "VERBOSENCDF_OUTDATANCDF_FILENAME", "          -1", "");
  
  

